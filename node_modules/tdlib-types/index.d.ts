// TDLib v1.8.0

/** An object of this type can be returned on every function call, in case of an error */
export type error = {
  _: 'error',
  /**
   * Error code; subject to future changes. If the error code is 406, the error message
   * must not be processed in any way and must not be displayed to the user
   */
  code: number,
  /** Error message; subject to future changes */
  message: string,
}

/** An object of this type can be returned on every function call, in case of an error */
export type error$Input = {
  readonly _: 'error',
  /**
   * Error code; subject to future changes. If the error code is 406, the error message
   * must not be processed in any way and must not be displayed to the user
   */
  readonly code?: number,
  /** Error message; subject to future changes */
  readonly message?: string,
}

/** An object of this type is returned on a successful function call for certain functions */
export type ok = {
  _: 'ok',
}

/** An object of this type is returned on a successful function call for certain functions */
export type ok$Input = {
  readonly _: 'ok',
}

/** Contains parameters for TDLib initialization */
export type tdlibParameters = {
  _: 'tdlibParameters',
  /**
   * If set to true, the Telegram test environment will be used instead of the production
   * environment
   */
  use_test_dc: boolean,
  /**
   * The path to the directory for the persistent database; if empty, the current working
   * directory will be used
   */
  database_directory: string,
  /**
   * The path to the directory for storing files; if empty, database_directory will be
   * used
   */
  files_directory: string,
  /**
   * If set to true, information about downloaded and uploaded files will be saved between
   * application restarts
   */
  use_file_database: boolean,
  /**
   * If set to true, the library will maintain a cache of users, basic groups, supergroups,
   * channels and secret chats. Implies use_file_database
   */
  use_chat_info_database: boolean,
  /**
   * If set to true, the library will maintain a cache of chats and messages. Implies
   * use_chat_info_database
   */
  use_message_database: boolean,
  /** If set to true, support for secret chats will be enabled */
  use_secret_chats: boolean,
  /** Application identifier for Telegram API access, which can be obtained at https://my.telegram.org */
  api_id: number,
  /** Application identifier hash for Telegram API access, which can be obtained at https://my.telegram.org */
  api_hash: string,
  /** IETF language tag of the user's operating system language; must be non-empty */
  system_language_code: string,
  /** Model of the device the application is being run on; must be non-empty */
  device_model: string,
  /**
   * Version of the operating system the application is being run on. If empty, the version
   * is automatically detected by TDLib
   */
  system_version: string,
  /** Application version; must be non-empty */
  application_version: string,
  /** If set to true, old files will automatically be deleted */
  enable_storage_optimizer: boolean,
  /**
   * If set to true, original file names will be ignored. Otherwise, downloaded files
   * will be saved under names as close as possible to the original name
   */
  ignore_file_names: boolean,
}

/** Contains parameters for TDLib initialization */
export type tdlibParameters$Input = {
  readonly _: 'tdlibParameters',
  /**
   * If set to true, the Telegram test environment will be used instead of the production
   * environment
   */
  readonly use_test_dc?: boolean,
  /**
   * The path to the directory for the persistent database; if empty, the current working
   * directory will be used
   */
  readonly database_directory?: string,
  /**
   * The path to the directory for storing files; if empty, database_directory will be
   * used
   */
  readonly files_directory?: string,
  /**
   * If set to true, information about downloaded and uploaded files will be saved between
   * application restarts
   */
  readonly use_file_database?: boolean,
  /**
   * If set to true, the library will maintain a cache of users, basic groups, supergroups,
   * channels and secret chats. Implies use_file_database
   */
  readonly use_chat_info_database?: boolean,
  /**
   * If set to true, the library will maintain a cache of chats and messages. Implies
   * use_chat_info_database
   */
  readonly use_message_database?: boolean,
  /** If set to true, support for secret chats will be enabled */
  readonly use_secret_chats?: boolean,
  /** Application identifier for Telegram API access, which can be obtained at https://my.telegram.org */
  readonly api_id?: number,
  /** Application identifier hash for Telegram API access, which can be obtained at https://my.telegram.org */
  readonly api_hash?: string,
  /** IETF language tag of the user's operating system language; must be non-empty */
  readonly system_language_code?: string,
  /** Model of the device the application is being run on; must be non-empty */
  readonly device_model?: string,
  /**
   * Version of the operating system the application is being run on. If empty, the version
   * is automatically detected by TDLib
   */
  readonly system_version?: string,
  /** Application version; must be non-empty */
  readonly application_version?: string,
  /** If set to true, old files will automatically be deleted */
  readonly enable_storage_optimizer?: boolean,
  /**
   * If set to true, original file names will be ignored. Otherwise, downloaded files
   * will be saved under names as close as possible to the original name
   */
  readonly ignore_file_names?: boolean,
}

/**
 * An authentication code is delivered via a private Telegram message, which can be
 * viewed from another active session
 */
export type authenticationCodeTypeTelegramMessage = {
  _: 'authenticationCodeTypeTelegramMessage',
  /** Length of the code */
  length: number,
}

/**
 * An authentication code is delivered via a private Telegram message, which can be
 * viewed from another active session
 */
export type authenticationCodeTypeTelegramMessage$Input = {
  readonly _: 'authenticationCodeTypeTelegramMessage',
  /** Length of the code */
  readonly length?: number,
}

/** An authentication code is delivered via an SMS message to the specified phone number */
export type authenticationCodeTypeSms = {
  _: 'authenticationCodeTypeSms',
  /** Length of the code */
  length: number,
}

/** An authentication code is delivered via an SMS message to the specified phone number */
export type authenticationCodeTypeSms$Input = {
  readonly _: 'authenticationCodeTypeSms',
  /** Length of the code */
  readonly length?: number,
}

/** An authentication code is delivered via a phone call to the specified phone number */
export type authenticationCodeTypeCall = {
  _: 'authenticationCodeTypeCall',
  /** Length of the code */
  length: number,
}

/** An authentication code is delivered via a phone call to the specified phone number */
export type authenticationCodeTypeCall$Input = {
  readonly _: 'authenticationCodeTypeCall',
  /** Length of the code */
  readonly length?: number,
}

/**
 * An authentication code is delivered by an immediately canceled call to the specified
 * phone number. The phone number that calls is the code that must be entered automatically
 */
export type authenticationCodeTypeFlashCall = {
  _: 'authenticationCodeTypeFlashCall',
  /** Pattern of the phone number from which the call will be made */
  pattern: string,
}

/**
 * An authentication code is delivered by an immediately canceled call to the specified
 * phone number. The phone number that calls is the code that must be entered automatically
 */
export type authenticationCodeTypeFlashCall$Input = {
  readonly _: 'authenticationCodeTypeFlashCall',
  /** Pattern of the phone number from which the call will be made */
  readonly pattern?: string,
}

/**
 * An authentication code is delivered by an immediately canceled call to the specified
 * phone number. The last digits of the phone number that calls are the code that must
 * be entered manually by the user
 */
export type authenticationCodeTypeMissedCall = {
  _: 'authenticationCodeTypeMissedCall',
  /** Prefix of the phone number from which the call will be made */
  phone_number_prefix: string,
  /** Number of digits in the code, excluding the prefix */
  length: number,
}

/**
 * An authentication code is delivered by an immediately canceled call to the specified
 * phone number. The last digits of the phone number that calls are the code that must
 * be entered manually by the user
 */
export type authenticationCodeTypeMissedCall$Input = {
  readonly _: 'authenticationCodeTypeMissedCall',
  /** Prefix of the phone number from which the call will be made */
  readonly phone_number_prefix?: string,
  /** Number of digits in the code, excluding the prefix */
  readonly length?: number,
}

/** Information about the authentication code that was sent */
export type authenticationCodeInfo = {
  _: 'authenticationCodeInfo',
  /** A phone number that is being authenticated */
  phone_number: string,
  /** The way the code was sent to the user */
  type: AuthenticationCodeType,
  /** The way the next code will be sent to the user; may be null */
  next_type: AuthenticationCodeType | undefined,
  /** Timeout before the code can be re-sent, in seconds */
  timeout: number,
}

/** Information about the authentication code that was sent */
export type authenticationCodeInfo$Input = {
  readonly _: 'authenticationCodeInfo',
  /** A phone number that is being authenticated */
  readonly phone_number?: string,
  /** The way the code was sent to the user */
  readonly type?: AuthenticationCodeType$Input,
  /** The way the next code will be sent to the user; may be null */
  readonly next_type?: AuthenticationCodeType$Input | undefined,
  /** Timeout before the code can be re-sent, in seconds */
  readonly timeout?: number,
}

/** Information about the email address authentication code that was sent */
export type emailAddressAuthenticationCodeInfo = {
  _: 'emailAddressAuthenticationCodeInfo',
  /** Pattern of the email address to which an authentication code was sent */
  email_address_pattern: string,
  /** Length of the code; 0 if unknown */
  length: number,
}

/** Information about the email address authentication code that was sent */
export type emailAddressAuthenticationCodeInfo$Input = {
  readonly _: 'emailAddressAuthenticationCodeInfo',
  /** Pattern of the email address to which an authentication code was sent */
  readonly email_address_pattern?: string,
  /** Length of the code; 0 if unknown */
  readonly length?: number,
}

/** Represents a part of the text that needs to be formatted in some unusual way */
export type textEntity = {
  _: 'textEntity',
  /** Offset of the entity, in UTF-16 code units */
  offset: number,
  /** Length of the entity, in UTF-16 code units */
  length: number,
  /** Type of the entity */
  type: TextEntityType,
}

/** Represents a part of the text that needs to be formatted in some unusual way */
export type textEntity$Input = {
  readonly _: 'textEntity',
  /** Offset of the entity, in UTF-16 code units */
  readonly offset?: number,
  /** Length of the entity, in UTF-16 code units */
  readonly length?: number,
  /** Type of the entity */
  readonly type?: TextEntityType$Input,
}

/** Contains a list of text entities */
export type textEntities = {
  _: 'textEntities',
  /** List of text entities */
  entities: Array<textEntity>,
}

/** Contains a list of text entities */
export type textEntities$Input = {
  readonly _: 'textEntities',
  /** List of text entities */
  readonly entities?: ReadonlyArray<textEntity$Input>,
}

/** A text with some entities */
export type formattedText = {
  _: 'formattedText',
  /** The text */
  text: string,
  /**
   * Entities contained in the text. Entities can be nested, but must not mutually intersect
   * with each other. Pre, Code and PreCode entities can't contain other entities. Bold,
   * Italic, Underline and Strikethrough entities can contain and to be contained in all
   * other entities. All other entities can't contain each other
   */
  entities: Array<textEntity>,
}

/** A text with some entities */
export type formattedText$Input = {
  readonly _: 'formattedText',
  /** The text */
  readonly text?: string,
  /**
   * Entities contained in the text. Entities can be nested, but must not mutually intersect
   * with each other. Pre, Code and PreCode entities can't contain other entities. Bold,
   * Italic, Underline and Strikethrough entities can contain and to be contained in all
   * other entities. All other entities can't contain each other
   */
  readonly entities?: ReadonlyArray<textEntity$Input>,
}

/** Contains Telegram terms of service */
export type termsOfService = {
  _: 'termsOfService',
  /** Text of the terms of service */
  text: formattedText,
  /** The minimum age of a user to be able to accept the terms; 0 if any */
  min_user_age: number,
  /** True, if a blocking popup with terms of service must be shown to the user */
  show_popup: boolean,
}

/** Contains Telegram terms of service */
export type termsOfService$Input = {
  readonly _: 'termsOfService',
  /** Text of the terms of service */
  readonly text?: formattedText$Input,
  /** The minimum age of a user to be able to accept the terms; 0 if any */
  readonly min_user_age?: number,
  /** True, if a blocking popup with terms of service must be shown to the user */
  readonly show_popup?: boolean,
}

/** TDLib needs TdlibParameters for initialization */
export type authorizationStateWaitTdlibParameters = {
  _: 'authorizationStateWaitTdlibParameters',
}

/** TDLib needs TdlibParameters for initialization */
export type authorizationStateWaitTdlibParameters$Input = {
  readonly _: 'authorizationStateWaitTdlibParameters',
}

/** TDLib needs an encryption key to decrypt the local database */
export type authorizationStateWaitEncryptionKey = {
  _: 'authorizationStateWaitEncryptionKey',
  /** True, if the database is currently encrypted */
  is_encrypted: boolean,
}

/** TDLib needs an encryption key to decrypt the local database */
export type authorizationStateWaitEncryptionKey$Input = {
  readonly _: 'authorizationStateWaitEncryptionKey',
  /** True, if the database is currently encrypted */
  readonly is_encrypted?: boolean,
}

/**
 * TDLib needs the user's phone number to authorize. Call `setAuthenticationPhoneNumber`
 * to provide the phone number, or use `requestQrCodeAuthentication`, or `checkAuthenticationBotToken`
 * for other authentication options
 */
export type authorizationStateWaitPhoneNumber = {
  _: 'authorizationStateWaitPhoneNumber',
}

/**
 * TDLib needs the user's phone number to authorize. Call `setAuthenticationPhoneNumber`
 * to provide the phone number, or use `requestQrCodeAuthentication`, or `checkAuthenticationBotToken`
 * for other authentication options
 */
export type authorizationStateWaitPhoneNumber$Input = {
  readonly _: 'authorizationStateWaitPhoneNumber',
}

/** TDLib needs the user's authentication code to authorize */
export type authorizationStateWaitCode = {
  _: 'authorizationStateWaitCode',
  /** Information about the authorization code that was sent */
  code_info: authenticationCodeInfo,
}

/** TDLib needs the user's authentication code to authorize */
export type authorizationStateWaitCode$Input = {
  readonly _: 'authorizationStateWaitCode',
  /** Information about the authorization code that was sent */
  readonly code_info?: authenticationCodeInfo$Input,
}

/**
 * The user needs to confirm authorization on another logged in device by scanning a
 * QR code with the provided link
 */
export type authorizationStateWaitOtherDeviceConfirmation = {
  _: 'authorizationStateWaitOtherDeviceConfirmation',
  /** A tg:// URL for the QR code. The link will be updated frequently */
  link: string,
}

/**
 * The user needs to confirm authorization on another logged in device by scanning a
 * QR code with the provided link
 */
export type authorizationStateWaitOtherDeviceConfirmation$Input = {
  readonly _: 'authorizationStateWaitOtherDeviceConfirmation',
  /** A tg:// URL for the QR code. The link will be updated frequently */
  readonly link?: string,
}

/**
 * The user is unregistered and need to accept terms of service and enter their first
 * name and last name to finish registration
 */
export type authorizationStateWaitRegistration = {
  _: 'authorizationStateWaitRegistration',
  /** Telegram terms of service */
  terms_of_service: termsOfService,
}

/**
 * The user is unregistered and need to accept terms of service and enter their first
 * name and last name to finish registration
 */
export type authorizationStateWaitRegistration$Input = {
  readonly _: 'authorizationStateWaitRegistration',
  /** Telegram terms of service */
  readonly terms_of_service?: termsOfService$Input,
}

/** The user has been authorized, but needs to enter a password to start using the application */
export type authorizationStateWaitPassword = {
  _: 'authorizationStateWaitPassword',
  /** Hint for the password; may be empty */
  password_hint: string,
  /** True, if a recovery email address has been set up */
  has_recovery_email_address: boolean,
  /**
   * Pattern of the email address to which the recovery email was sent; empty until a
   * recovery email has been sent
   */
  recovery_email_address_pattern: string,
}

/** The user has been authorized, but needs to enter a password to start using the application */
export type authorizationStateWaitPassword$Input = {
  readonly _: 'authorizationStateWaitPassword',
  /** Hint for the password; may be empty */
  readonly password_hint?: string,
  /** True, if a recovery email address has been set up */
  readonly has_recovery_email_address?: boolean,
  /**
   * Pattern of the email address to which the recovery email was sent; empty until a
   * recovery email has been sent
   */
  readonly recovery_email_address_pattern?: string,
}

/** The user has been successfully authorized. TDLib is now ready to answer queries */
export type authorizationStateReady = {
  _: 'authorizationStateReady',
}

/** The user has been successfully authorized. TDLib is now ready to answer queries */
export type authorizationStateReady$Input = {
  readonly _: 'authorizationStateReady',
}

/** The user is currently logging out */
export type authorizationStateLoggingOut = {
  _: 'authorizationStateLoggingOut',
}

/** The user is currently logging out */
export type authorizationStateLoggingOut$Input = {
  readonly _: 'authorizationStateLoggingOut',
}

/**
 * TDLib is closing, all subsequent queries will be answered with the error 500. Note
 * that closing TDLib can take a while. All resources will be freed only after authorizationStateClosed
 * has been received
 */
export type authorizationStateClosing = {
  _: 'authorizationStateClosing',
}

/**
 * TDLib is closing, all subsequent queries will be answered with the error 500. Note
 * that closing TDLib can take a while. All resources will be freed only after authorizationStateClosed
 * has been received
 */
export type authorizationStateClosing$Input = {
  readonly _: 'authorizationStateClosing',
}

/**
 * TDLib client is in its final state. All databases are closed and all resources are
 * released. No other updates will be received after this. All queries will be responded
 * to with error code 500. To continue working, one must create a new instance of the
 * TDLib client
 */
export type authorizationStateClosed = {
  _: 'authorizationStateClosed',
}

/**
 * TDLib client is in its final state. All databases are closed and all resources are
 * released. No other updates will be received after this. All queries will be responded
 * to with error code 500. To continue working, one must create a new instance of the
 * TDLib client
 */
export type authorizationStateClosed$Input = {
  readonly _: 'authorizationStateClosed',
}

/** Represents the current state of 2-step verification */
export type passwordState = {
  _: 'passwordState',
  /** True, if a 2-step verification password is set */
  has_password: boolean,
  /** Hint for the password; may be empty */
  password_hint: string,
  /** True, if a recovery email is set */
  has_recovery_email_address: boolean,
  /** True, if some Telegram Passport elements were saved */
  has_passport_data: boolean,
  /**
   * Information about the recovery email address to which the confirmation email was
   * sent; may be null
   */
  recovery_email_address_code_info: emailAddressAuthenticationCodeInfo | undefined,
  /**
   * If not 0, point in time (Unix timestamp) after which the password can be reset immediately
   * using resetPassword
   */
  pending_reset_date: number,
}

/** Represents the current state of 2-step verification */
export type passwordState$Input = {
  readonly _: 'passwordState',
  /** True, if a 2-step verification password is set */
  readonly has_password?: boolean,
  /** Hint for the password; may be empty */
  readonly password_hint?: string,
  /** True, if a recovery email is set */
  readonly has_recovery_email_address?: boolean,
  /** True, if some Telegram Passport elements were saved */
  readonly has_passport_data?: boolean,
  /**
   * Information about the recovery email address to which the confirmation email was
   * sent; may be null
   */
  readonly recovery_email_address_code_info?: emailAddressAuthenticationCodeInfo$Input | undefined,
  /**
   * If not 0, point in time (Unix timestamp) after which the password can be reset immediately
   * using resetPassword
   */
  readonly pending_reset_date?: number,
}

/** Contains information about the current recovery email address */
export type recoveryEmailAddress = {
  _: 'recoveryEmailAddress',
  /** Recovery email address */
  recovery_email_address: string,
}

/** Contains information about the current recovery email address */
export type recoveryEmailAddress$Input = {
  readonly _: 'recoveryEmailAddress',
  /** Recovery email address */
  readonly recovery_email_address?: string,
}

/**
 * Returns information about the availability of a temporary password, which can be
 * used for payments
 */
export type temporaryPasswordState = {
  _: 'temporaryPasswordState',
  /** True, if a temporary password is available */
  has_password: boolean,
  /** Time left before the temporary password expires, in seconds */
  valid_for: number,
}

/**
 * Returns information about the availability of a temporary password, which can be
 * used for payments
 */
export type temporaryPasswordState$Input = {
  readonly _: 'temporaryPasswordState',
  /** True, if a temporary password is available */
  readonly has_password?: boolean,
  /** Time left before the temporary password expires, in seconds */
  readonly valid_for?: number,
}

/** Represents a local file */
export type localFile = {
  _: 'localFile',
  /** Local path to the locally available file part; may be empty */
  path: string,
  /** True, if it is possible to download or generate the file */
  can_be_downloaded: boolean,
  /** True, if the file can be deleted */
  can_be_deleted: boolean,
  /**
   * True, if the file is currently being downloaded (or a local copy is being generated
   * by some other means)
   */
  is_downloading_active: boolean,
  /** True, if the local copy is fully available */
  is_downloading_completed: boolean,
  /**
   * Download will be started from this offset. downloaded_prefix_size is calculated from
   * this offset
   */
  download_offset: number,
  /**
   * If is_downloading_completed is false, then only some prefix of the file starting
   * from download_offset is ready to be read. downloaded_prefix_size is the size of that
   * prefix in bytes
   */
  downloaded_prefix_size: number,
  /**
   * Total downloaded file size, in bytes. Can be used only for calculating download progress.
   * The actual file size may be bigger, and some parts of it may contain garbage
   */
  downloaded_size: number,
}

/** Represents a local file */
export type localFile$Input = {
  readonly _: 'localFile',
  /** Local path to the locally available file part; may be empty */
  readonly path?: string,
  /** True, if it is possible to download or generate the file */
  readonly can_be_downloaded?: boolean,
  /** True, if the file can be deleted */
  readonly can_be_deleted?: boolean,
  /**
   * True, if the file is currently being downloaded (or a local copy is being generated
   * by some other means)
   */
  readonly is_downloading_active?: boolean,
  /** True, if the local copy is fully available */
  readonly is_downloading_completed?: boolean,
  /**
   * Download will be started from this offset. downloaded_prefix_size is calculated from
   * this offset
   */
  readonly download_offset?: number,
  /**
   * If is_downloading_completed is false, then only some prefix of the file starting
   * from download_offset is ready to be read. downloaded_prefix_size is the size of that
   * prefix in bytes
   */
  readonly downloaded_prefix_size?: number,
  /**
   * Total downloaded file size, in bytes. Can be used only for calculating download progress.
   * The actual file size may be bigger, and some parts of it may contain garbage
   */
  readonly downloaded_size?: number,
}

/** Represents a remote file */
export type remoteFile = {
  _: 'remoteFile',
  /**
   * Remote file identifier; may be empty. Can be used by the current user across application
   * restarts or even from other devices. Uniquely identifies a file, but a file can have
   * a lot of different valid identifiers. If the ID starts with "http://" or "https://",
   * it represents the HTTP URL of the file. TDLib is currently unable to download files
   * if only their URL is known. If downloadFile is called on such a file or if it is
   * sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart
   * to the application with the HTTP URL in the original_path and "#url#" as the conversion
   * string. Application must generate the file by downloading it to the specified location
   */
  id: string,
  /**
   * Unique file identifier; may be empty if unknown. The unique file identifier which
   * is the same for the same file even for different users and is persistent over time
   */
  unique_id: string,
  /**
   * True, if the file is currently being uploaded (or a remote copy is being generated
   * by some other means)
   */
  is_uploading_active: boolean,
  /** True, if a remote copy is fully available */
  is_uploading_completed: boolean,
  /** Size of the remote available part of the file, in bytes; 0 if unknown */
  uploaded_size: number,
}

/** Represents a remote file */
export type remoteFile$Input = {
  readonly _: 'remoteFile',
  /**
   * Remote file identifier; may be empty. Can be used by the current user across application
   * restarts or even from other devices. Uniquely identifies a file, but a file can have
   * a lot of different valid identifiers. If the ID starts with "http://" or "https://",
   * it represents the HTTP URL of the file. TDLib is currently unable to download files
   * if only their URL is known. If downloadFile is called on such a file or if it is
   * sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart
   * to the application with the HTTP URL in the original_path and "#url#" as the conversion
   * string. Application must generate the file by downloading it to the specified location
   */
  readonly id?: string,
  /**
   * Unique file identifier; may be empty if unknown. The unique file identifier which
   * is the same for the same file even for different users and is persistent over time
   */
  readonly unique_id?: string,
  /**
   * True, if the file is currently being uploaded (or a remote copy is being generated
   * by some other means)
   */
  readonly is_uploading_active?: boolean,
  /** True, if a remote copy is fully available */
  readonly is_uploading_completed?: boolean,
  /** Size of the remote available part of the file, in bytes; 0 if unknown */
  readonly uploaded_size?: number,
}

/** Represents a file */
export type file = {
  _: 'file',
  /** Unique file identifier */
  id: number,
  /** File size, in bytes; 0 if unknown */
  size: number,
  /**
   * Approximate file size in bytes in case the exact file size is unknown. Can be used
   * to show download/upload progress
   */
  expected_size: number,
  /** Information about the local copy of the file */
  local: localFile,
  /** Information about the remote copy of the file */
  remote: remoteFile,
}

/** Represents a file */
export type file$Input = {
  readonly _: 'file',
  /** Unique file identifier */
  readonly id?: number,
  /** File size, in bytes; 0 if unknown */
  readonly size?: number,
  /**
   * Approximate file size in bytes in case the exact file size is unknown. Can be used
   * to show download/upload progress
   */
  readonly expected_size?: number,
  /** Information about the local copy of the file */
  readonly local?: localFile$Input,
  /** Information about the remote copy of the file */
  readonly remote?: remoteFile$Input,
}

/** A file defined by its unique ID */
export type inputFileId = {
  _: 'inputFileId',
  /** Unique file identifier */
  id: number,
}

/** A file defined by its unique ID */
export type inputFileId$Input = {
  readonly _: 'inputFileId',
  /** Unique file identifier */
  readonly id?: number,
}

/**
 * A file defined by its remote ID. The remote ID is guaranteed to be usable only if
 * the corresponding file is still accessible to the user and known to TDLib. For example,
 * if the file is from a message, then the message must be not deleted and accessible
 * to the user. If the file database is disabled, then the corresponding object with
 * the file must be preloaded by the application
 */
export type inputFileRemote = {
  _: 'inputFileRemote',
  /** Remote file identifier */
  id: string,
}

/**
 * A file defined by its remote ID. The remote ID is guaranteed to be usable only if
 * the corresponding file is still accessible to the user and known to TDLib. For example,
 * if the file is from a message, then the message must be not deleted and accessible
 * to the user. If the file database is disabled, then the corresponding object with
 * the file must be preloaded by the application
 */
export type inputFileRemote$Input = {
  readonly _: 'inputFileRemote',
  /** Remote file identifier */
  readonly id?: string,
}

/** A file defined by a local path */
export type inputFileLocal = {
  _: 'inputFileLocal',
  /** Local path to the file */
  path: string,
}

/** A file defined by a local path */
export type inputFileLocal$Input = {
  readonly _: 'inputFileLocal',
  /** Local path to the file */
  readonly path?: string,
}

/** A file generated by the application */
export type inputFileGenerated = {
  _: 'inputFileGenerated',
  /**
   * Local path to a file from which the file is generated; may be empty if there is no
   * such file
   */
  original_path: string,
  /**
   * String specifying the conversion applied to the original file; must be persistent
   * across application restarts. Conversions beginning with '#' are reserved for internal
   * TDLib usage
   */
  conversion: string,
  /** Expected size of the generated file, in bytes; 0 if unknown */
  expected_size: number,
}

/** A file generated by the application */
export type inputFileGenerated$Input = {
  readonly _: 'inputFileGenerated',
  /**
   * Local path to a file from which the file is generated; may be empty if there is no
   * such file
   */
  readonly original_path?: string,
  /**
   * String specifying the conversion applied to the original file; must be persistent
   * across application restarts. Conversions beginning with '#' are reserved for internal
   * TDLib usage
   */
  readonly conversion?: string,
  /** Expected size of the generated file, in bytes; 0 if unknown */
  readonly expected_size?: number,
}

/** Describes an image in JPEG format */
export type photoSize = {
  _: 'photoSize',
  /** Image type (see https://core.telegram.org/constructor/photoSize) */
  type: string,
  /** Information about the image file */
  photo: file,
  /** Image width */
  width: number,
  /** Image height */
  height: number,
  /**
   * Sizes of progressive JPEG file prefixes, which can be used to preliminarily show
   * the image; in bytes
   */
  progressive_sizes: Array<number>,
}

/** Describes an image in JPEG format */
export type photoSize$Input = {
  readonly _: 'photoSize',
  /** Image type (see https://core.telegram.org/constructor/photoSize) */
  readonly type?: string,
  /** Information about the image file */
  readonly photo?: file$Input,
  /** Image width */
  readonly width?: number,
  /** Image height */
  readonly height?: number,
  /**
   * Sizes of progressive JPEG file prefixes, which can be used to preliminarily show
   * the image; in bytes
   */
  readonly progressive_sizes?: ReadonlyArray<number>,
}

/** Thumbnail image of a very poor quality and low resolution */
export type minithumbnail = {
  _: 'minithumbnail',
  /** Thumbnail width, usually doesn't exceed 40 */
  width: number,
  /** Thumbnail height, usually doesn't exceed 40 */
  height: number,
  /** The thumbnail in JPEG format */
  data: string,
}

/** Thumbnail image of a very poor quality and low resolution */
export type minithumbnail$Input = {
  readonly _: 'minithumbnail',
  /** Thumbnail width, usually doesn't exceed 40 */
  readonly width?: number,
  /** Thumbnail height, usually doesn't exceed 40 */
  readonly height?: number,
  /** The thumbnail in JPEG format */
  readonly data?: string,
}

/** The thumbnail is in JPEG format */
export type thumbnailFormatJpeg = {
  _: 'thumbnailFormatJpeg',
}

/** The thumbnail is in JPEG format */
export type thumbnailFormatJpeg$Input = {
  readonly _: 'thumbnailFormatJpeg',
}

/** The thumbnail is in PNG format. It will be used only for background patterns */
export type thumbnailFormatPng = {
  _: 'thumbnailFormatPng',
}

/** The thumbnail is in PNG format. It will be used only for background patterns */
export type thumbnailFormatPng$Input = {
  readonly _: 'thumbnailFormatPng',
}

/** The thumbnail is in WEBP format. It will be used only for some stickers */
export type thumbnailFormatWebp = {
  _: 'thumbnailFormatWebp',
}

/** The thumbnail is in WEBP format. It will be used only for some stickers */
export type thumbnailFormatWebp$Input = {
  readonly _: 'thumbnailFormatWebp',
}

/** The thumbnail is in static GIF format. It will be used only for some bot inline results */
export type thumbnailFormatGif = {
  _: 'thumbnailFormatGif',
}

/** The thumbnail is in static GIF format. It will be used only for some bot inline results */
export type thumbnailFormatGif$Input = {
  readonly _: 'thumbnailFormatGif',
}

/** The thumbnail is in TGS format. It will be used only for animated sticker sets */
export type thumbnailFormatTgs = {
  _: 'thumbnailFormatTgs',
}

/** The thumbnail is in TGS format. It will be used only for animated sticker sets */
export type thumbnailFormatTgs$Input = {
  readonly _: 'thumbnailFormatTgs',
}

/** The thumbnail is in MPEG4 format. It will be used only for some animations and videos */
export type thumbnailFormatMpeg4 = {
  _: 'thumbnailFormatMpeg4',
}

/** The thumbnail is in MPEG4 format. It will be used only for some animations and videos */
export type thumbnailFormatMpeg4$Input = {
  readonly _: 'thumbnailFormatMpeg4',
}

/** Represents a thumbnail */
export type thumbnail = {
  _: 'thumbnail',
  /** Thumbnail format */
  format: ThumbnailFormat,
  /** Thumbnail width */
  width: number,
  /** Thumbnail height */
  height: number,
  /** The thumbnail */
  file: file,
}

/** Represents a thumbnail */
export type thumbnail$Input = {
  readonly _: 'thumbnail',
  /** Thumbnail format */
  readonly format?: ThumbnailFormat$Input,
  /** Thumbnail width */
  readonly width?: number,
  /** Thumbnail height */
  readonly height?: number,
  /** The thumbnail */
  readonly file?: file$Input,
}

/** The mask is placed relatively to the forehead */
export type maskPointForehead = {
  _: 'maskPointForehead',
}

/** The mask is placed relatively to the forehead */
export type maskPointForehead$Input = {
  readonly _: 'maskPointForehead',
}

/** The mask is placed relatively to the eyes */
export type maskPointEyes = {
  _: 'maskPointEyes',
}

/** The mask is placed relatively to the eyes */
export type maskPointEyes$Input = {
  readonly _: 'maskPointEyes',
}

/** The mask is placed relatively to the mouth */
export type maskPointMouth = {
  _: 'maskPointMouth',
}

/** The mask is placed relatively to the mouth */
export type maskPointMouth$Input = {
  readonly _: 'maskPointMouth',
}

/** The mask is placed relatively to the chin */
export type maskPointChin = {
  _: 'maskPointChin',
}

/** The mask is placed relatively to the chin */
export type maskPointChin$Input = {
  readonly _: 'maskPointChin',
}

/** Position on a photo where a mask is placed */
export type maskPosition = {
  _: 'maskPosition',
  /** Part of the face, relative to which the mask is placed */
  point: MaskPoint,
  /**
   * Shift by X-axis measured in widths of the mask scaled to the face size, from left
   * to right. (For example, -1.0 will place the mask just to the left of the default
   * mask position)
   */
  x_shift: number,
  /**
   * Shift by Y-axis measured in heights of the mask scaled to the face size, from top
   * to bottom. (For example, 1.0 will place the mask just below the default mask position)
   */
  y_shift: number,
  /** Mask scaling coefficient. (For example, 2.0 means a doubled size) */
  scale: number,
}

/** Position on a photo where a mask is placed */
export type maskPosition$Input = {
  readonly _: 'maskPosition',
  /** Part of the face, relative to which the mask is placed */
  readonly point?: MaskPoint$Input,
  /**
   * Shift by X-axis measured in widths of the mask scaled to the face size, from left
   * to right. (For example, -1.0 will place the mask just to the left of the default
   * mask position)
   */
  readonly x_shift?: number,
  /**
   * Shift by Y-axis measured in heights of the mask scaled to the face size, from top
   * to bottom. (For example, 1.0 will place the mask just below the default mask position)
   */
  readonly y_shift?: number,
  /** Mask scaling coefficient. (For example, 2.0 means a doubled size) */
  readonly scale?: number,
}

/** Represents a closed vector path. The path begins at the end point of the last command */
export type closedVectorPath = {
  _: 'closedVectorPath',
  /** List of vector path commands */
  commands: Array<VectorPathCommand>,
}

/** Represents a closed vector path. The path begins at the end point of the last command */
export type closedVectorPath$Input = {
  readonly _: 'closedVectorPath',
  /** List of vector path commands */
  readonly commands?: ReadonlyArray<VectorPathCommand$Input>,
}

/** Describes one answer option of a poll */
export type pollOption = {
  _: 'pollOption',
  /** Option text; 1-100 characters */
  text: string,
  /** Number of voters for this option, available only for closed or voted polls */
  voter_count: number,
  /** The percentage of votes for this option; 0-100 */
  vote_percentage: number,
  /** True, if the option was chosen by the user */
  is_chosen: boolean,
  /** True, if the option is being chosen by a pending setPollAnswer request */
  is_being_chosen: boolean,
}

/** Describes one answer option of a poll */
export type pollOption$Input = {
  readonly _: 'pollOption',
  /** Option text; 1-100 characters */
  readonly text?: string,
  /** Number of voters for this option, available only for closed or voted polls */
  readonly voter_count?: number,
  /** The percentage of votes for this option; 0-100 */
  readonly vote_percentage?: number,
  /** True, if the option was chosen by the user */
  readonly is_chosen?: boolean,
  /** True, if the option is being chosen by a pending setPollAnswer request */
  readonly is_being_chosen?: boolean,
}

/** A regular poll */
export type pollTypeRegular = {
  _: 'pollTypeRegular',
  /** True, if multiple answer options can be chosen simultaneously */
  allow_multiple_answers: boolean,
}

/** A regular poll */
export type pollTypeRegular$Input = {
  readonly _: 'pollTypeRegular',
  /** True, if multiple answer options can be chosen simultaneously */
  readonly allow_multiple_answers?: boolean,
}

/**
 * A poll in quiz mode, which has exactly one correct answer option and can be answered
 * only once
 */
export type pollTypeQuiz = {
  _: 'pollTypeQuiz',
  /** 0-based identifier of the correct answer option; -1 for a yet unanswered poll */
  correct_option_id: number,
  /**
   * Text that is shown when the user chooses an incorrect answer or taps on the lamp
   * icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered poll
   */
  explanation: formattedText,
}

/**
 * A poll in quiz mode, which has exactly one correct answer option and can be answered
 * only once
 */
export type pollTypeQuiz$Input = {
  readonly _: 'pollTypeQuiz',
  /** 0-based identifier of the correct answer option; -1 for a yet unanswered poll */
  readonly correct_option_id?: number,
  /**
   * Text that is shown when the user chooses an incorrect answer or taps on the lamp
   * icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered poll
   */
  readonly explanation?: formattedText$Input,
}

/** Describes an animation file. The animation must be encoded in GIF or MPEG4 format */
export type animation = {
  _: 'animation',
  /** Duration of the animation, in seconds; as defined by the sender */
  duration: number,
  /** Width of the animation */
  width: number,
  /** Height of the animation */
  height: number,
  /** Original name of the file; as defined by the sender */
  file_name: string,
  /** MIME type of the file, usually "image/gif" or "video/mp4" */
  mime_type: string,
  /**
   * True, if stickers were added to the animation. The list of corresponding sticker
   * set can be received using getAttachedStickerSets
   */
  has_stickers: boolean,
  /** Animation minithumbnail; may be null */
  minithumbnail: minithumbnail | undefined,
  /** Animation thumbnail in JPEG or MPEG4 format; may be null */
  thumbnail: thumbnail | undefined,
  /** File containing the animation */
  animation: file,
}

/** Describes an animation file. The animation must be encoded in GIF or MPEG4 format */
export type animation$Input = {
  readonly _: 'animation',
  /** Duration of the animation, in seconds; as defined by the sender */
  readonly duration?: number,
  /** Width of the animation */
  readonly width?: number,
  /** Height of the animation */
  readonly height?: number,
  /** Original name of the file; as defined by the sender */
  readonly file_name?: string,
  /** MIME type of the file, usually "image/gif" or "video/mp4" */
  readonly mime_type?: string,
  /**
   * True, if stickers were added to the animation. The list of corresponding sticker
   * set can be received using getAttachedStickerSets
   */
  readonly has_stickers?: boolean,
  /** Animation minithumbnail; may be null */
  readonly minithumbnail?: minithumbnail$Input | undefined,
  /** Animation thumbnail in JPEG or MPEG4 format; may be null */
  readonly thumbnail?: thumbnail$Input | undefined,
  /** File containing the animation */
  readonly animation?: file$Input,
}

/** Describes an audio file. Audio is usually in MP3 or M4A format */
export type audio = {
  _: 'audio',
  /** Duration of the audio, in seconds; as defined by the sender */
  duration: number,
  /** Title of the audio; as defined by the sender */
  title: string,
  /** Performer of the audio; as defined by the sender */
  performer: string,
  /** Original name of the file; as defined by the sender */
  file_name: string,
  /** The MIME type of the file; as defined by the sender */
  mime_type: string,
  /** The minithumbnail of the album cover; may be null */
  album_cover_minithumbnail: minithumbnail | undefined,
  /**
   * The thumbnail of the album cover in JPEG format; as defined by the sender. The full
   * size thumbnail is supposed to be extracted from the downloaded file; may be null
   */
  album_cover_thumbnail: thumbnail | undefined,
  /** File containing the audio */
  audio: file,
}

/** Describes an audio file. Audio is usually in MP3 or M4A format */
export type audio$Input = {
  readonly _: 'audio',
  /** Duration of the audio, in seconds; as defined by the sender */
  readonly duration?: number,
  /** Title of the audio; as defined by the sender */
  readonly title?: string,
  /** Performer of the audio; as defined by the sender */
  readonly performer?: string,
  /** Original name of the file; as defined by the sender */
  readonly file_name?: string,
  /** The MIME type of the file; as defined by the sender */
  readonly mime_type?: string,
  /** The minithumbnail of the album cover; may be null */
  readonly album_cover_minithumbnail?: minithumbnail$Input | undefined,
  /**
   * The thumbnail of the album cover in JPEG format; as defined by the sender. The full
   * size thumbnail is supposed to be extracted from the downloaded file; may be null
   */
  readonly album_cover_thumbnail?: thumbnail$Input | undefined,
  /** File containing the audio */
  readonly audio?: file$Input,
}

/** Describes a document of any type */
export type document = {
  _: 'document',
  /** Original name of the file; as defined by the sender */
  file_name: string,
  /** MIME type of the file; as defined by the sender */
  mime_type: string,
  /** Document minithumbnail; may be null */
  minithumbnail: minithumbnail | undefined,
  /**
   * Document thumbnail in JPEG or PNG format (PNG will be used only for background patterns);
   * as defined by the sender; may be null
   */
  thumbnail: thumbnail | undefined,
  /** File containing the document */
  document: file,
}

/** Describes a document of any type */
export type document$Input = {
  readonly _: 'document',
  /** Original name of the file; as defined by the sender */
  readonly file_name?: string,
  /** MIME type of the file; as defined by the sender */
  readonly mime_type?: string,
  /** Document minithumbnail; may be null */
  readonly minithumbnail?: minithumbnail$Input | undefined,
  /**
   * Document thumbnail in JPEG or PNG format (PNG will be used only for background patterns);
   * as defined by the sender; may be null
   */
  readonly thumbnail?: thumbnail$Input | undefined,
  /** File containing the document */
  readonly document?: file$Input,
}

/** Describes a photo */
export type photo = {
  _: 'photo',
  /**
   * True, if stickers were added to the photo. The list of corresponding sticker sets
   * can be received using getAttachedStickerSets
   */
  has_stickers: boolean,
  /** Photo minithumbnail; may be null */
  minithumbnail: minithumbnail | undefined,
  /** Available variants of the photo, in different sizes */
  sizes: Array<photoSize>,
}

/** Describes a photo */
export type photo$Input = {
  readonly _: 'photo',
  /**
   * True, if stickers were added to the photo. The list of corresponding sticker sets
   * can be received using getAttachedStickerSets
   */
  readonly has_stickers?: boolean,
  /** Photo minithumbnail; may be null */
  readonly minithumbnail?: minithumbnail$Input | undefined,
  /** Available variants of the photo, in different sizes */
  readonly sizes?: ReadonlyArray<photoSize$Input>,
}

/** Describes a sticker */
export type sticker = {
  _: 'sticker',
  /** The identifier of the sticker set to which the sticker belongs; 0 if none */
  set_id: number | string,
  /** Sticker width; as defined by the sender */
  width: number,
  /** Sticker height; as defined by the sender */
  height: number,
  /** Emoji corresponding to the sticker */
  emoji: string,
  /** True, if the sticker is an animated sticker in TGS format */
  is_animated: boolean,
  /** True, if the sticker is a mask */
  is_mask: boolean,
  /** Position where the mask is placed; may be null */
  mask_position: maskPosition | undefined,
  /**
   * Sticker's outline represented as a list of closed vector paths; may be empty. The
   * coordinate system origin is in the upper-left corner
   */
  outline: Array<closedVectorPath>,
  /** Sticker thumbnail in WEBP or JPEG format; may be null */
  thumbnail: thumbnail | undefined,
  /** File containing the sticker */
  sticker: file,
}

/** Describes a sticker */
export type sticker$Input = {
  readonly _: 'sticker',
  /** The identifier of the sticker set to which the sticker belongs; 0 if none */
  readonly set_id?: number | string,
  /** Sticker width; as defined by the sender */
  readonly width?: number,
  /** Sticker height; as defined by the sender */
  readonly height?: number,
  /** Emoji corresponding to the sticker */
  readonly emoji?: string,
  /** True, if the sticker is an animated sticker in TGS format */
  readonly is_animated?: boolean,
  /** True, if the sticker is a mask */
  readonly is_mask?: boolean,
  /** Position where the mask is placed; may be null */
  readonly mask_position?: maskPosition$Input | undefined,
  /**
   * Sticker's outline represented as a list of closed vector paths; may be empty. The
   * coordinate system origin is in the upper-left corner
   */
  readonly outline?: ReadonlyArray<closedVectorPath$Input>,
  /** Sticker thumbnail in WEBP or JPEG format; may be null */
  readonly thumbnail?: thumbnail$Input | undefined,
  /** File containing the sticker */
  readonly sticker?: file$Input,
}

/** Describes a video file */
export type video = {
  _: 'video',
  /** Duration of the video, in seconds; as defined by the sender */
  duration: number,
  /** Video width; as defined by the sender */
  width: number,
  /** Video height; as defined by the sender */
  height: number,
  /** Original name of the file; as defined by the sender */
  file_name: string,
  /** MIME type of the file; as defined by the sender */
  mime_type: string,
  /**
   * True, if stickers were added to the video. The list of corresponding sticker sets
   * can be received using getAttachedStickerSets
   */
  has_stickers: boolean,
  /** True, if the video is supposed to be streamed */
  supports_streaming: boolean,
  /** Video minithumbnail; may be null */
  minithumbnail: minithumbnail | undefined,
  /** Video thumbnail in JPEG or MPEG4 format; as defined by the sender; may be null */
  thumbnail: thumbnail | undefined,
  /** File containing the video */
  video: file,
}

/** Describes a video file */
export type video$Input = {
  readonly _: 'video',
  /** Duration of the video, in seconds; as defined by the sender */
  readonly duration?: number,
  /** Video width; as defined by the sender */
  readonly width?: number,
  /** Video height; as defined by the sender */
  readonly height?: number,
  /** Original name of the file; as defined by the sender */
  readonly file_name?: string,
  /** MIME type of the file; as defined by the sender */
  readonly mime_type?: string,
  /**
   * True, if stickers were added to the video. The list of corresponding sticker sets
   * can be received using getAttachedStickerSets
   */
  readonly has_stickers?: boolean,
  /** True, if the video is supposed to be streamed */
  readonly supports_streaming?: boolean,
  /** Video minithumbnail; may be null */
  readonly minithumbnail?: minithumbnail$Input | undefined,
  /** Video thumbnail in JPEG or MPEG4 format; as defined by the sender; may be null */
  readonly thumbnail?: thumbnail$Input | undefined,
  /** File containing the video */
  readonly video?: file$Input,
}

/**
 * Describes a video note. The video must be equal in width and height, cropped to a
 * circle, and stored in MPEG4 format
 */
export type videoNote = {
  _: 'videoNote',
  /** Duration of the video, in seconds; as defined by the sender */
  duration: number,
  /** Video width and height; as defined by the sender */
  length: number,
  /** Video minithumbnail; may be null */
  minithumbnail: minithumbnail | undefined,
  /** Video thumbnail in JPEG format; as defined by the sender; may be null */
  thumbnail: thumbnail | undefined,
  /** File containing the video */
  video: file,
}

/**
 * Describes a video note. The video must be equal in width and height, cropped to a
 * circle, and stored in MPEG4 format
 */
export type videoNote$Input = {
  readonly _: 'videoNote',
  /** Duration of the video, in seconds; as defined by the sender */
  readonly duration?: number,
  /** Video width and height; as defined by the sender */
  readonly length?: number,
  /** Video minithumbnail; may be null */
  readonly minithumbnail?: minithumbnail$Input | undefined,
  /** Video thumbnail in JPEG format; as defined by the sender; may be null */
  readonly thumbnail?: thumbnail$Input | undefined,
  /** File containing the video */
  readonly video?: file$Input,
}

/**
 * Describes a voice note. The voice note must be encoded with the Opus codec, and stored
 * inside an OGG container. Voice notes can have only a single audio channel
 */
export type voiceNote = {
  _: 'voiceNote',
  /** Duration of the voice note, in seconds; as defined by the sender */
  duration: number,
  /** A waveform representation of the voice note in 5-bit format */
  waveform: string,
  /** MIME type of the file; as defined by the sender */
  mime_type: string,
  /** File containing the voice note */
  voice: file,
}

/**
 * Describes a voice note. The voice note must be encoded with the Opus codec, and stored
 * inside an OGG container. Voice notes can have only a single audio channel
 */
export type voiceNote$Input = {
  readonly _: 'voiceNote',
  /** Duration of the voice note, in seconds; as defined by the sender */
  readonly duration?: number,
  /** A waveform representation of the voice note in 5-bit format */
  readonly waveform?: string,
  /** MIME type of the file; as defined by the sender */
  readonly mime_type?: string,
  /** File containing the voice note */
  readonly voice?: file$Input,
}

/** Describes an animated representation of an emoji */
export type animatedEmoji = {
  _: 'animatedEmoji',
  /** Animated sticker for the emoji */
  sticker: sticker,
  /** Emoji modifier fitzpatrick type; 0-6; 0 if none */
  fitzpatrick_type: number,
  /**
   * File containing the sound to be played when the animated emoji is clicked if any;
   * may be null. The sound is encoded with the Opus codec, and stored inside an OGG container
   */
  sound: file | undefined,
}

/** Describes an animated representation of an emoji */
export type animatedEmoji$Input = {
  readonly _: 'animatedEmoji',
  /** Animated sticker for the emoji */
  readonly sticker?: sticker$Input,
  /** Emoji modifier fitzpatrick type; 0-6; 0 if none */
  readonly fitzpatrick_type?: number,
  /**
   * File containing the sound to be played when the animated emoji is clicked if any;
   * may be null. The sound is encoded with the Opus codec, and stored inside an OGG container
   */
  readonly sound?: file$Input | undefined,
}

/** Describes a user contact */
export type contact = {
  _: 'contact',
  /** Phone number of the user */
  phone_number: string,
  /** First name of the user; 1-255 characters in length */
  first_name: string,
  /** Last name of the user */
  last_name: string,
  /** Additional data about the user in a form of vCard; 0-2048 bytes in length */
  vcard: string,
  /** Identifier of the user, if known; otherwise 0 */
  user_id: number,
}

/** Describes a user contact */
export type contact$Input = {
  readonly _: 'contact',
  /** Phone number of the user */
  readonly phone_number?: string,
  /** First name of the user; 1-255 characters in length */
  readonly first_name?: string,
  /** Last name of the user */
  readonly last_name?: string,
  /** Additional data about the user in a form of vCard; 0-2048 bytes in length */
  readonly vcard?: string,
  /** Identifier of the user, if known; otherwise 0 */
  readonly user_id?: number,
}

/** Describes a location on planet Earth */
export type location = {
  _: 'location',
  /** Latitude of the location in degrees; as defined by the sender */
  latitude: number,
  /** Longitude of the location, in degrees; as defined by the sender */
  longitude: number,
  /**
   * The estimated horizontal accuracy of the location, in meters; as defined by the sender.
   * 0 if unknown
   */
  horizontal_accuracy: number,
}

/** Describes a location on planet Earth */
export type location$Input = {
  readonly _: 'location',
  /** Latitude of the location in degrees; as defined by the sender */
  readonly latitude?: number,
  /** Longitude of the location, in degrees; as defined by the sender */
  readonly longitude?: number,
  /**
   * The estimated horizontal accuracy of the location, in meters; as defined by the sender.
   * 0 if unknown
   */
  readonly horizontal_accuracy?: number,
}

/** Describes a venue */
export type venue = {
  _: 'venue',
  /** Venue location; as defined by the sender */
  location: location,
  /** Venue name; as defined by the sender */
  title: string,
  /** Venue address; as defined by the sender */
  address: string,
  /**
   * Provider of the venue database; as defined by the sender. Currently, only "foursquare"
   * and "gplaces" (Google Places) need to be supported
   */
  provider: string,
  /** Identifier of the venue in the provider database; as defined by the sender */
  id: string,
  /** Type of the venue in the provider database; as defined by the sender */
  type: string,
}

/** Describes a venue */
export type venue$Input = {
  readonly _: 'venue',
  /** Venue location; as defined by the sender */
  readonly location?: location$Input,
  /** Venue name; as defined by the sender */
  readonly title?: string,
  /** Venue address; as defined by the sender */
  readonly address?: string,
  /**
   * Provider of the venue database; as defined by the sender. Currently, only "foursquare"
   * and "gplaces" (Google Places) need to be supported
   */
  readonly provider?: string,
  /** Identifier of the venue in the provider database; as defined by the sender */
  readonly id?: string,
  /** Type of the venue in the provider database; as defined by the sender */
  readonly type?: string,
}

/** Describes a game */
export type game = {
  _: 'game',
  /** Game ID */
  id: number | string,
  /** Game short name. To share a game use the URL https://t.me/{bot_username}?game={game_short_name} */
  short_name: string,
  /** Game title */
  title: string,
  /** Game text, usually containing scoreboards for a game */
  text: formattedText,
  /** Game description */
  description: string,
  /** Game photo */
  photo: photo,
  /** Game animation; may be null */
  animation: animation | undefined,
}

/** Describes a game */
export type game$Input = {
  readonly _: 'game',
  /** Game ID */
  readonly id?: number | string,
  /** Game short name. To share a game use the URL https://t.me/{bot_username}?game={game_short_name} */
  readonly short_name?: string,
  /** Game title */
  readonly title?: string,
  /** Game text, usually containing scoreboards for a game */
  readonly text?: formattedText$Input,
  /** Game description */
  readonly description?: string,
  /** Game photo */
  readonly photo?: photo$Input,
  /** Game animation; may be null */
  readonly animation?: animation$Input | undefined,
}

/** Describes a poll */
export type poll = {
  _: 'poll',
  /** Unique poll identifier */
  id: number | string,
  /** Poll question; 1-300 characters */
  question: string,
  /** List of poll answer options */
  options: Array<pollOption>,
  /** Total number of voters, participating in the poll */
  total_voter_count: number,
  /** User identifiers of recent voters, if the poll is non-anonymous */
  recent_voter_user_ids: Array<number>,
  /** True, if the poll is anonymous */
  is_anonymous: boolean,
  /** Type of the poll */
  type: PollType,
  /** Amount of time the poll will be active after creation, in seconds */
  open_period: number,
  /** Point in time (Unix timestamp) when the poll will automatically be closed */
  close_date: number,
  /** True, if the poll is closed */
  is_closed: boolean,
}

/** Describes a poll */
export type poll$Input = {
  readonly _: 'poll',
  /** Unique poll identifier */
  readonly id?: number | string,
  /** Poll question; 1-300 characters */
  readonly question?: string,
  /** List of poll answer options */
  readonly options?: ReadonlyArray<pollOption$Input>,
  /** Total number of voters, participating in the poll */
  readonly total_voter_count?: number,
  /** User identifiers of recent voters, if the poll is non-anonymous */
  readonly recent_voter_user_ids?: ReadonlyArray<number>,
  /** True, if the poll is anonymous */
  readonly is_anonymous?: boolean,
  /** Type of the poll */
  readonly type?: PollType$Input,
  /** Amount of time the poll will be active after creation, in seconds */
  readonly open_period?: number,
  /** Point in time (Unix timestamp) when the poll will automatically be closed */
  readonly close_date?: number,
  /** True, if the poll is closed */
  readonly is_closed?: boolean,
}

/** Describes a user profile photo */
export type profilePhoto = {
  _: 'profilePhoto',
  /**
   * Photo identifier; 0 for an empty photo. Can be used to find a photo in a list of
   * user profile photos
   */
  id: number | string,
  /**
   * A small (160x160) user profile photo. The file can be downloaded only before the
   * photo is changed
   */
  small: file,
  /**
   * A big (640x640) user profile photo. The file can be downloaded only before the photo
   * is changed
   */
  big: file,
  /** User profile photo minithumbnail; may be null */
  minithumbnail: minithumbnail | undefined,
  /** True, if the photo has animated variant */
  has_animation: boolean,
}

/** Describes a user profile photo */
export type profilePhoto$Input = {
  readonly _: 'profilePhoto',
  /**
   * Photo identifier; 0 for an empty photo. Can be used to find a photo in a list of
   * user profile photos
   */
  readonly id?: number | string,
  /**
   * A small (160x160) user profile photo. The file can be downloaded only before the
   * photo is changed
   */
  readonly small?: file$Input,
  /**
   * A big (640x640) user profile photo. The file can be downloaded only before the photo
   * is changed
   */
  readonly big?: file$Input,
  /** User profile photo minithumbnail; may be null */
  readonly minithumbnail?: minithumbnail$Input | undefined,
  /** True, if the photo has animated variant */
  readonly has_animation?: boolean,
}

/** Contains basic information about the photo of a chat */
export type chatPhotoInfo = {
  _: 'chatPhotoInfo',
  /**
   * A small (160x160) chat photo variant in JPEG format. The file can be downloaded only
   * before the photo is changed
   */
  small: file,
  /**
   * A big (640x640) chat photo variant in JPEG format. The file can be downloaded only
   * before the photo is changed
   */
  big: file,
  /** Chat photo minithumbnail; may be null */
  minithumbnail: minithumbnail | undefined,
  /** True, if the photo has animated variant */
  has_animation: boolean,
}

/** Contains basic information about the photo of a chat */
export type chatPhotoInfo$Input = {
  readonly _: 'chatPhotoInfo',
  /**
   * A small (160x160) chat photo variant in JPEG format. The file can be downloaded only
   * before the photo is changed
   */
  readonly small?: file$Input,
  /**
   * A big (640x640) chat photo variant in JPEG format. The file can be downloaded only
   * before the photo is changed
   */
  readonly big?: file$Input,
  /** Chat photo minithumbnail; may be null */
  readonly minithumbnail?: minithumbnail$Input | undefined,
  /** True, if the photo has animated variant */
  readonly has_animation?: boolean,
}

/** A regular user */
export type userTypeRegular = {
  _: 'userTypeRegular',
}

/** A regular user */
export type userTypeRegular$Input = {
  readonly _: 'userTypeRegular',
}

/**
 * A deleted user or deleted bot. No information on the user besides the user identifier
 * is available. It is not possible to perform any active actions on this type of user
 */
export type userTypeDeleted = {
  _: 'userTypeDeleted',
}

/**
 * A deleted user or deleted bot. No information on the user besides the user identifier
 * is available. It is not possible to perform any active actions on this type of user
 */
export type userTypeDeleted$Input = {
  readonly _: 'userTypeDeleted',
}

/** A bot (see https://core.telegram.org/bots) */
export type userTypeBot = {
  _: 'userTypeBot',
  /** True, if the bot can be invited to basic group and supergroup chats */
  can_join_groups: boolean,
  /**
   * True, if the bot can read all messages in basic group or supergroup chats and not
   * just those addressed to the bot. In private and channel chats a bot can always read
   * all messages
   */
  can_read_all_group_messages: boolean,
  /** True, if the bot supports inline queries */
  is_inline: boolean,
  /** Placeholder for inline queries (displayed on the application input field) */
  inline_query_placeholder: string,
  /**
   * True, if the location of the user is expected to be sent with every inline query
   * to this bot
   */
  need_location: boolean,
}

/** A bot (see https://core.telegram.org/bots) */
export type userTypeBot$Input = {
  readonly _: 'userTypeBot',
  /** True, if the bot can be invited to basic group and supergroup chats */
  readonly can_join_groups?: boolean,
  /**
   * True, if the bot can read all messages in basic group or supergroup chats and not
   * just those addressed to the bot. In private and channel chats a bot can always read
   * all messages
   */
  readonly can_read_all_group_messages?: boolean,
  /** True, if the bot supports inline queries */
  readonly is_inline?: boolean,
  /** Placeholder for inline queries (displayed on the application input field) */
  readonly inline_query_placeholder?: string,
  /**
   * True, if the location of the user is expected to be sent with every inline query
   * to this bot
   */
  readonly need_location?: boolean,
}

/**
 * No information on the user besides the user identifier is available, yet this user
 * has not been deleted. This object is extremely rare and must be handled like a deleted
 * user. It is not possible to perform any actions on users of this type
 */
export type userTypeUnknown = {
  _: 'userTypeUnknown',
}

/**
 * No information on the user besides the user identifier is available, yet this user
 * has not been deleted. This object is extremely rare and must be handled like a deleted
 * user. It is not possible to perform any actions on users of this type
 */
export type userTypeUnknown$Input = {
  readonly _: 'userTypeUnknown',
}

/** Represents a command supported by a bot */
export type botCommand = {
  _: 'botCommand',
  /** Text of the bot command */
  command: string,
  /** Description of the bot command */
  description: string,
}

/** Represents a command supported by a bot */
export type botCommand$Input = {
  readonly _: 'botCommand',
  /** Text of the bot command */
  readonly command?: string,
  /** Description of the bot command */
  readonly description?: string,
}

/** Contains a list of bot commands */
export type botCommands = {
  _: 'botCommands',
  /** Bot's user identifier */
  bot_user_id: number,
  /** List of bot commands */
  commands: Array<botCommand>,
}

/** Contains a list of bot commands */
export type botCommands$Input = {
  readonly _: 'botCommands',
  /** Bot's user identifier */
  readonly bot_user_id?: number,
  /** List of bot commands */
  readonly commands?: ReadonlyArray<botCommand$Input>,
}

/** Represents a location to which a chat is connected */
export type chatLocation = {
  _: 'chatLocation',
  /** The location */
  location: location,
  /** Location address; 1-64 characters, as defined by the chat owner */
  address: string,
}

/** Represents a location to which a chat is connected */
export type chatLocation$Input = {
  readonly _: 'chatLocation',
  /** The location */
  readonly location?: location$Input,
  /** Location address; 1-64 characters, as defined by the chat owner */
  readonly address?: string,
}

/** Animated variant of a chat photo in MPEG4 format */
export type animatedChatPhoto = {
  _: 'animatedChatPhoto',
  /** Animation width and height */
  length: number,
  /** Information about the animation file */
  file: file,
  /** Timestamp of the frame, used as a static chat photo */
  main_frame_timestamp: number,
}

/** Animated variant of a chat photo in MPEG4 format */
export type animatedChatPhoto$Input = {
  readonly _: 'animatedChatPhoto',
  /** Animation width and height */
  readonly length?: number,
  /** Information about the animation file */
  readonly file?: file$Input,
  /** Timestamp of the frame, used as a static chat photo */
  readonly main_frame_timestamp?: number,
}

/** Describes a chat or user profile photo */
export type chatPhoto = {
  _: 'chatPhoto',
  /** Unique photo identifier */
  id: number | string,
  /** Point in time (Unix timestamp) when the photo has been added */
  added_date: number,
  /** Photo minithumbnail; may be null */
  minithumbnail: minithumbnail | undefined,
  /** Available variants of the photo in JPEG format, in different size */
  sizes: Array<photoSize>,
  /** Animated variant of the photo in MPEG4 format; may be null */
  animation: animatedChatPhoto | undefined,
}

/** Describes a chat or user profile photo */
export type chatPhoto$Input = {
  readonly _: 'chatPhoto',
  /** Unique photo identifier */
  readonly id?: number | string,
  /** Point in time (Unix timestamp) when the photo has been added */
  readonly added_date?: number,
  /** Photo minithumbnail; may be null */
  readonly minithumbnail?: minithumbnail$Input | undefined,
  /** Available variants of the photo in JPEG format, in different size */
  readonly sizes?: ReadonlyArray<photoSize$Input>,
  /** Animated variant of the photo in MPEG4 format; may be null */
  readonly animation?: animatedChatPhoto$Input | undefined,
}

/** Contains a list of chat or user profile photos */
export type chatPhotos = {
  _: 'chatPhotos',
  /** Total number of photos */
  total_count: number,
  /** List of photos */
  photos: Array<chatPhoto>,
}

/** Contains a list of chat or user profile photos */
export type chatPhotos$Input = {
  readonly _: 'chatPhotos',
  /** Total number of photos */
  readonly total_count?: number,
  /** List of photos */
  readonly photos?: ReadonlyArray<chatPhoto$Input>,
}

/** A previously used profile photo of the current user */
export type inputChatPhotoPrevious = {
  _: 'inputChatPhotoPrevious',
  /** Identifier of the current user's profile photo to reuse */
  chat_photo_id: number | string,
}

/** A previously used profile photo of the current user */
export type inputChatPhotoPrevious$Input = {
  readonly _: 'inputChatPhotoPrevious',
  /** Identifier of the current user's profile photo to reuse */
  readonly chat_photo_id?: number | string,
}

/** A static photo in JPEG format */
export type inputChatPhotoStatic = {
  _: 'inputChatPhotoStatic',
  /**
   * Photo to be set as profile photo. Only inputFileLocal and inputFileGenerated are
   * allowed
   */
  photo: InputFile,
}

/** A static photo in JPEG format */
export type inputChatPhotoStatic$Input = {
  readonly _: 'inputChatPhotoStatic',
  /**
   * Photo to be set as profile photo. Only inputFileLocal and inputFileGenerated are
   * allowed
   */
  readonly photo?: InputFile$Input,
}

/**
 * An animation in MPEG4 format; must be square, at most 10 seconds long, have width
 * between 160 and 800 and be at most 2MB in size
 */
export type inputChatPhotoAnimation = {
  _: 'inputChatPhotoAnimation',
  /**
   * Animation to be set as profile photo. Only inputFileLocal and inputFileGenerated
   * are allowed
   */
  animation: InputFile,
  /** Timestamp of the frame, which will be used as static chat photo */
  main_frame_timestamp: number,
}

/**
 * An animation in MPEG4 format; must be square, at most 10 seconds long, have width
 * between 160 and 800 and be at most 2MB in size
 */
export type inputChatPhotoAnimation$Input = {
  readonly _: 'inputChatPhotoAnimation',
  /**
   * Animation to be set as profile photo. Only inputFileLocal and inputFileGenerated
   * are allowed
   */
  readonly animation?: InputFile$Input,
  /** Timestamp of the frame, which will be used as static chat photo */
  readonly main_frame_timestamp?: number,
}

/** Represents a user */
export type user = {
  _: 'user',
  /** User identifier */
  id: number,
  /** First name of the user */
  first_name: string,
  /** Last name of the user */
  last_name: string,
  /** Username of the user */
  username: string,
  /** Phone number of the user */
  phone_number: string,
  /** Current online status of the user */
  status: UserStatus,
  /** Profile photo of the user; may be null */
  profile_photo: profilePhoto | undefined,
  /** The user is a contact of the current user */
  is_contact: boolean,
  /**
   * The user is a contact of the current user and the current user is a contact of the
   * user
   */
  is_mutual_contact: boolean,
  /** True, if the user is verified */
  is_verified: boolean,
  /** True, if the user is Telegram support account */
  is_support: boolean,
  /**
   * If non-empty, it contains a human-readable description of the reason why access to
   * this user must be restricted
   */
  restriction_reason: string,
  /** True, if many users reported this user as a scam */
  is_scam: boolean,
  /** True, if many users reported this user as a fake account */
  is_fake: boolean,
  /**
   * If false, the user is inaccessible, and the only information known about the user
   * is inside this class. It can't be passed to any method except GetUser
   */
  have_access: boolean,
  /** Type of the user */
  type: UserType,
  /** IETF language tag of the user's language; only available to bots */
  language_code: string,
}

/** Represents a user */
export type user$Input = {
  readonly _: 'user',
  /** User identifier */
  readonly id?: number,
  /** First name of the user */
  readonly first_name?: string,
  /** Last name of the user */
  readonly last_name?: string,
  /** Username of the user */
  readonly username?: string,
  /** Phone number of the user */
  readonly phone_number?: string,
  /** Current online status of the user */
  readonly status?: UserStatus$Input,
  /** Profile photo of the user; may be null */
  readonly profile_photo?: profilePhoto$Input | undefined,
  /** The user is a contact of the current user */
  readonly is_contact?: boolean,
  /**
   * The user is a contact of the current user and the current user is a contact of the
   * user
   */
  readonly is_mutual_contact?: boolean,
  /** True, if the user is verified */
  readonly is_verified?: boolean,
  /** True, if the user is Telegram support account */
  readonly is_support?: boolean,
  /**
   * If non-empty, it contains a human-readable description of the reason why access to
   * this user must be restricted
   */
  readonly restriction_reason?: string,
  /** True, if many users reported this user as a scam */
  readonly is_scam?: boolean,
  /** True, if many users reported this user as a fake account */
  readonly is_fake?: boolean,
  /**
   * If false, the user is inaccessible, and the only information known about the user
   * is inside this class. It can't be passed to any method except GetUser
   */
  readonly have_access?: boolean,
  /** Type of the user */
  readonly type?: UserType$Input,
  /** IETF language tag of the user's language; only available to bots */
  readonly language_code?: string,
}

/** Contains full information about a user */
export type userFullInfo = {
  _: 'userFullInfo',
  /** User profile photo; may be null */
  photo: chatPhoto | undefined,
  /** True, if the user is blocked by the current user */
  is_blocked: boolean,
  /** True, if the user can be called */
  can_be_called: boolean,
  /** True, if a video call can be created with the user */
  supports_video_calls: boolean,
  /** True, if the user can't be called due to their privacy settings */
  has_private_calls: boolean,
  /** True, if the user can't be linked in forwarded messages due to their privacy settings */
  has_private_forwards: boolean,
  /**
   * True, if the current user needs to explicitly allow to share their phone number with
   * the user when the method addContact is used
   */
  need_phone_number_privacy_exception: boolean,
  /** A short user bio */
  bio: string,
  /**
   * For bots, the text that is shown on the bot's profile page and is sent together with
   * the link when users share the bot
   */
  share_text: string,
  /** For bots, the text shown in the chat with the bot if the chat is empty */
  description: string,
  /**
   * Number of group chats where both the other user and the current user are a member;
   * 0 for the current user
   */
  group_in_common_count: number,
  /** For bots, list of the bot commands */
  commands: Array<botCommand>,
}

/** Contains full information about a user */
export type userFullInfo$Input = {
  readonly _: 'userFullInfo',
  /** User profile photo; may be null */
  readonly photo?: chatPhoto$Input | undefined,
  /** True, if the user is blocked by the current user */
  readonly is_blocked?: boolean,
  /** True, if the user can be called */
  readonly can_be_called?: boolean,
  /** True, if a video call can be created with the user */
  readonly supports_video_calls?: boolean,
  /** True, if the user can't be called due to their privacy settings */
  readonly has_private_calls?: boolean,
  /** True, if the user can't be linked in forwarded messages due to their privacy settings */
  readonly has_private_forwards?: boolean,
  /**
   * True, if the current user needs to explicitly allow to share their phone number with
   * the user when the method addContact is used
   */
  readonly need_phone_number_privacy_exception?: boolean,
  /** A short user bio */
  readonly bio?: string,
  /**
   * For bots, the text that is shown on the bot's profile page and is sent together with
   * the link when users share the bot
   */
  readonly share_text?: string,
  /** For bots, the text shown in the chat with the bot if the chat is empty */
  readonly description?: string,
  /**
   * Number of group chats where both the other user and the current user are a member;
   * 0 for the current user
   */
  readonly group_in_common_count?: number,
  /** For bots, list of the bot commands */
  readonly commands?: ReadonlyArray<botCommand$Input>,
}

/** Represents a list of users */
export type users = {
  _: 'users',
  /** Approximate total count of users found */
  total_count: number,
  /** A list of user identifiers */
  user_ids: Array<number>,
}

/** Represents a list of users */
export type users$Input = {
  readonly _: 'users',
  /** Approximate total count of users found */
  readonly total_count?: number,
  /** A list of user identifiers */
  readonly user_ids?: ReadonlyArray<number>,
}

/** Contains information about a chat administrator */
export type chatAdministrator = {
  _: 'chatAdministrator',
  /** User identifier of the administrator */
  user_id: number,
  /** Custom title of the administrator */
  custom_title: string,
  /** True, if the user is the owner of the chat */
  is_owner: boolean,
}

/** Contains information about a chat administrator */
export type chatAdministrator$Input = {
  readonly _: 'chatAdministrator',
  /** User identifier of the administrator */
  readonly user_id?: number,
  /** Custom title of the administrator */
  readonly custom_title?: string,
  /** True, if the user is the owner of the chat */
  readonly is_owner?: boolean,
}

/** Represents a list of chat administrators */
export type chatAdministrators = {
  _: 'chatAdministrators',
  /** A list of chat administrators */
  administrators: Array<chatAdministrator>,
}

/** Represents a list of chat administrators */
export type chatAdministrators$Input = {
  readonly _: 'chatAdministrators',
  /** A list of chat administrators */
  readonly administrators?: ReadonlyArray<chatAdministrator$Input>,
}

/** Describes actions that a user is allowed to take in a chat */
export type chatPermissions = {
  _: 'chatPermissions',
  /** True, if the user can send text messages, contacts, locations, and venues */
  can_send_messages: boolean,
  /**
   * True, if the user can send audio files, documents, photos, videos, video notes, and
   * voice notes. Implies can_send_messages permissions
   */
  can_send_media_messages: boolean,
  /** True, if the user can send polls. Implies can_send_messages permissions */
  can_send_polls: boolean,
  /**
   * True, if the user can send animations, games, stickers, and dice and use inline bots.
   * Implies can_send_messages permissions
   */
  can_send_other_messages: boolean,
  /**
   * True, if the user may add a web page preview to their messages. Implies can_send_messages
   * permissions
   */
  can_add_web_page_previews: boolean,
  /** True, if the user can change the chat title, photo, and other settings */
  can_change_info: boolean,
  /** True, if the user can invite new users to the chat */
  can_invite_users: boolean,
  /** True, if the user can pin messages */
  can_pin_messages: boolean,
}

/** Describes actions that a user is allowed to take in a chat */
export type chatPermissions$Input = {
  readonly _: 'chatPermissions',
  /** True, if the user can send text messages, contacts, locations, and venues */
  readonly can_send_messages?: boolean,
  /**
   * True, if the user can send audio files, documents, photos, videos, video notes, and
   * voice notes. Implies can_send_messages permissions
   */
  readonly can_send_media_messages?: boolean,
  /** True, if the user can send polls. Implies can_send_messages permissions */
  readonly can_send_polls?: boolean,
  /**
   * True, if the user can send animations, games, stickers, and dice and use inline bots.
   * Implies can_send_messages permissions
   */
  readonly can_send_other_messages?: boolean,
  /**
   * True, if the user may add a web page preview to their messages. Implies can_send_messages
   * permissions
   */
  readonly can_add_web_page_previews?: boolean,
  /** True, if the user can change the chat title, photo, and other settings */
  readonly can_change_info?: boolean,
  /** True, if the user can invite new users to the chat */
  readonly can_invite_users?: boolean,
  /** True, if the user can pin messages */
  readonly can_pin_messages?: boolean,
}

/** The user is the owner of the chat and has all the administrator privileges */
export type chatMemberStatusCreator = {
  _: 'chatMemberStatusCreator',
  /**
   * A custom title of the owner; 0-16 characters without emojis; applicable to supergroups
   * only
   */
  custom_title: string,
  /**
   * True, if the creator isn't shown in the chat member list and sends messages anonymously;
   * applicable to supergroups only
   */
  is_anonymous: boolean,
  /** True, if the user is a member of the chat */
  is_member: boolean,
}

/** The user is the owner of the chat and has all the administrator privileges */
export type chatMemberStatusCreator$Input = {
  readonly _: 'chatMemberStatusCreator',
  /**
   * A custom title of the owner; 0-16 characters without emojis; applicable to supergroups
   * only
   */
  readonly custom_title?: string,
  /**
   * True, if the creator isn't shown in the chat member list and sends messages anonymously;
   * applicable to supergroups only
   */
  readonly is_anonymous?: boolean,
  /** True, if the user is a member of the chat */
  readonly is_member?: boolean,
}

/**
 * The user is a member of the chat and has some additional privileges. In basic groups,
 * administrators can edit and delete messages sent by others, add new members, ban
 * unprivileged members, and manage video chats. In supergroups and channels, there
 * are more detailed options for administrator privileges
 */
export type chatMemberStatusAdministrator = {
  _: 'chatMemberStatusAdministrator',
  /**
   * A custom title of the administrator; 0-16 characters without emojis; applicable to
   * supergroups only
   */
  custom_title: string,
  /** True, if the current user can edit the administrator privileges for the called user */
  can_be_edited: boolean,
  /**
   * True, if the administrator can get chat event log, get chat statistics, get message
   * statistics in channels, get channel members, see anonymous administrators in supergroups
   * and ignore slow mode. Implied by any other privilege; applicable to supergroups and
   * channels only
   */
  can_manage_chat: boolean,
  /** True, if the administrator can change the chat title, photo, and other settings */
  can_change_info: boolean,
  /** True, if the administrator can create channel posts; applicable to channels only */
  can_post_messages: boolean,
  /**
   * True, if the administrator can edit messages of other users and pin messages; applicable
   * to channels only
   */
  can_edit_messages: boolean,
  /** True, if the administrator can delete messages of other users */
  can_delete_messages: boolean,
  /** True, if the administrator can invite new users to the chat */
  can_invite_users: boolean,
  /**
   * True, if the administrator can restrict, ban, or unban chat members; always true
   * for channels
   */
  can_restrict_members: boolean,
  /**
   * True, if the administrator can pin messages; applicable to basic groups and supergroups
   * only
   */
  can_pin_messages: boolean,
  /**
   * True, if the administrator can add new administrators with a subset of their own
   * privileges or demote administrators that were directly or indirectly promoted by
   * them
   */
  can_promote_members: boolean,
  /** True, if the administrator can manage video chats */
  can_manage_video_chats: boolean,
  /**
   * True, if the administrator isn't shown in the chat member list and sends messages
   * anonymously; applicable to supergroups only
   */
  is_anonymous: boolean,
}

/**
 * The user is a member of the chat and has some additional privileges. In basic groups,
 * administrators can edit and delete messages sent by others, add new members, ban
 * unprivileged members, and manage video chats. In supergroups and channels, there
 * are more detailed options for administrator privileges
 */
export type chatMemberStatusAdministrator$Input = {
  readonly _: 'chatMemberStatusAdministrator',
  /**
   * A custom title of the administrator; 0-16 characters without emojis; applicable to
   * supergroups only
   */
  readonly custom_title?: string,
  /** True, if the current user can edit the administrator privileges for the called user */
  readonly can_be_edited?: boolean,
  /**
   * True, if the administrator can get chat event log, get chat statistics, get message
   * statistics in channels, get channel members, see anonymous administrators in supergroups
   * and ignore slow mode. Implied by any other privilege; applicable to supergroups and
   * channels only
   */
  readonly can_manage_chat?: boolean,
  /** True, if the administrator can change the chat title, photo, and other settings */
  readonly can_change_info?: boolean,
  /** True, if the administrator can create channel posts; applicable to channels only */
  readonly can_post_messages?: boolean,
  /**
   * True, if the administrator can edit messages of other users and pin messages; applicable
   * to channels only
   */
  readonly can_edit_messages?: boolean,
  /** True, if the administrator can delete messages of other users */
  readonly can_delete_messages?: boolean,
  /** True, if the administrator can invite new users to the chat */
  readonly can_invite_users?: boolean,
  /**
   * True, if the administrator can restrict, ban, or unban chat members; always true
   * for channels
   */
  readonly can_restrict_members?: boolean,
  /**
   * True, if the administrator can pin messages; applicable to basic groups and supergroups
   * only
   */
  readonly can_pin_messages?: boolean,
  /**
   * True, if the administrator can add new administrators with a subset of their own
   * privileges or demote administrators that were directly or indirectly promoted by
   * them
   */
  readonly can_promote_members?: boolean,
  /** True, if the administrator can manage video chats */
  readonly can_manage_video_chats?: boolean,
  /**
   * True, if the administrator isn't shown in the chat member list and sends messages
   * anonymously; applicable to supergroups only
   */
  readonly is_anonymous?: boolean,
}

/** The user is a member of the chat, without any additional privileges or restrictions */
export type chatMemberStatusMember = {
  _: 'chatMemberStatusMember',
}

/** The user is a member of the chat, without any additional privileges or restrictions */
export type chatMemberStatusMember$Input = {
  readonly _: 'chatMemberStatusMember',
}

/**
 * The user is under certain restrictions in the chat. Not supported in basic groups
 * and channels
 */
export type chatMemberStatusRestricted = {
  _: 'chatMemberStatusRestricted',
  /** True, if the user is a member of the chat */
  is_member: boolean,
  /**
   * Point in time (Unix timestamp) when restrictions will be lifted from the user; 0
   * if never. If the user is restricted for more than 366 days or for less than 30 seconds
   * from the current time, the user is considered to be restricted forever
   */
  restricted_until_date: number,
  /** User permissions in the chat */
  permissions: chatPermissions,
}

/**
 * The user is under certain restrictions in the chat. Not supported in basic groups
 * and channels
 */
export type chatMemberStatusRestricted$Input = {
  readonly _: 'chatMemberStatusRestricted',
  /** True, if the user is a member of the chat */
  readonly is_member?: boolean,
  /**
   * Point in time (Unix timestamp) when restrictions will be lifted from the user; 0
   * if never. If the user is restricted for more than 366 days or for less than 30 seconds
   * from the current time, the user is considered to be restricted forever
   */
  readonly restricted_until_date?: number,
  /** User permissions in the chat */
  readonly permissions?: chatPermissions$Input,
}

/** The user or the chat is not a chat member */
export type chatMemberStatusLeft = {
  _: 'chatMemberStatusLeft',
}

/** The user or the chat is not a chat member */
export type chatMemberStatusLeft$Input = {
  readonly _: 'chatMemberStatusLeft',
}

/**
 * The user or the chat was banned (and hence is not a member of the chat). Implies
 * the user can't return to the chat, view messages, or be used as a participant identifier
 * to join a video chat of the chat
 */
export type chatMemberStatusBanned = {
  _: 'chatMemberStatusBanned',
  /**
   * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the
   * user is banned for more than 366 days or for less than 30 seconds from the current
   * time, the user is considered to be banned forever. Always 0 in basic groups
   */
  banned_until_date: number,
}

/**
 * The user or the chat was banned (and hence is not a member of the chat). Implies
 * the user can't return to the chat, view messages, or be used as a participant identifier
 * to join a video chat of the chat
 */
export type chatMemberStatusBanned$Input = {
  readonly _: 'chatMemberStatusBanned',
  /**
   * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the
   * user is banned for more than 366 days or for less than 30 seconds from the current
   * time, the user is considered to be banned forever. Always 0 in basic groups
   */
  readonly banned_until_date?: number,
}

/** Describes a user or a chat as a member of another chat */
export type chatMember = {
  _: 'chatMember',
  /**
   * Identifier of the chat member. Currently, other chats can be only Left or Banned.
   * Only supergroups and channels can have other chats as Left or Banned members and
   * these chats must be supergroups or channels
   */
  member_id: MessageSender,
  /** Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown */
  inviter_user_id: number,
  /** Point in time (Unix timestamp) when the user joined the chat */
  joined_chat_date: number,
  /** Status of the member in the chat */
  status: ChatMemberStatus,
}

/** Describes a user or a chat as a member of another chat */
export type chatMember$Input = {
  readonly _: 'chatMember',
  /**
   * Identifier of the chat member. Currently, other chats can be only Left or Banned.
   * Only supergroups and channels can have other chats as Left or Banned members and
   * these chats must be supergroups or channels
   */
  readonly member_id?: MessageSender$Input,
  /** Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown */
  readonly inviter_user_id?: number,
  /** Point in time (Unix timestamp) when the user joined the chat */
  readonly joined_chat_date?: number,
  /** Status of the member in the chat */
  readonly status?: ChatMemberStatus$Input,
}

/** Contains a list of chat members */
export type chatMembers = {
  _: 'chatMembers',
  /** Approximate total count of chat members found */
  total_count: number,
  /** A list of chat members */
  members: Array<chatMember>,
}

/** Contains a list of chat members */
export type chatMembers$Input = {
  readonly _: 'chatMembers',
  /** Approximate total count of chat members found */
  readonly total_count?: number,
  /** A list of chat members */
  readonly members?: ReadonlyArray<chatMember$Input>,
}

/** Returns contacts of the user */
export type chatMembersFilterContacts = {
  _: 'chatMembersFilterContacts',
}

/** Returns contacts of the user */
export type chatMembersFilterContacts$Input = {
  readonly _: 'chatMembersFilterContacts',
}

/** Returns the owner and administrators */
export type chatMembersFilterAdministrators = {
  _: 'chatMembersFilterAdministrators',
}

/** Returns the owner and administrators */
export type chatMembersFilterAdministrators$Input = {
  readonly _: 'chatMembersFilterAdministrators',
}

/** Returns all chat members, including restricted chat members */
export type chatMembersFilterMembers = {
  _: 'chatMembersFilterMembers',
}

/** Returns all chat members, including restricted chat members */
export type chatMembersFilterMembers$Input = {
  readonly _: 'chatMembersFilterMembers',
}

/** Returns users which can be mentioned in the chat */
export type chatMembersFilterMention = {
  _: 'chatMembersFilterMention',
  /** If non-zero, the identifier of the current message thread */
  message_thread_id: number,
}

/** Returns users which can be mentioned in the chat */
export type chatMembersFilterMention$Input = {
  readonly _: 'chatMembersFilterMention',
  /** If non-zero, the identifier of the current message thread */
  readonly message_thread_id?: number,
}

/**
 * Returns users under certain restrictions in the chat; can be used only by administrators
 * in a supergroup
 */
export type chatMembersFilterRestricted = {
  _: 'chatMembersFilterRestricted',
}

/**
 * Returns users under certain restrictions in the chat; can be used only by administrators
 * in a supergroup
 */
export type chatMembersFilterRestricted$Input = {
  readonly _: 'chatMembersFilterRestricted',
}

/**
 * Returns users banned from the chat; can be used only by administrators in a supergroup
 * or in a channel
 */
export type chatMembersFilterBanned = {
  _: 'chatMembersFilterBanned',
}

/**
 * Returns users banned from the chat; can be used only by administrators in a supergroup
 * or in a channel
 */
export type chatMembersFilterBanned$Input = {
  readonly _: 'chatMembersFilterBanned',
}

/** Returns bot members of the chat */
export type chatMembersFilterBots = {
  _: 'chatMembersFilterBots',
}

/** Returns bot members of the chat */
export type chatMembersFilterBots$Input = {
  readonly _: 'chatMembersFilterBots',
}

/** Returns recently active users in reverse chronological order */
export type supergroupMembersFilterRecent = {
  _: 'supergroupMembersFilterRecent',
}

/** Returns recently active users in reverse chronological order */
export type supergroupMembersFilterRecent$Input = {
  readonly _: 'supergroupMembersFilterRecent',
}

/** Returns contacts of the user, which are members of the supergroup or channel */
export type supergroupMembersFilterContacts = {
  _: 'supergroupMembersFilterContacts',
  /** Query to search for */
  query: string,
}

/** Returns contacts of the user, which are members of the supergroup or channel */
export type supergroupMembersFilterContacts$Input = {
  readonly _: 'supergroupMembersFilterContacts',
  /** Query to search for */
  readonly query?: string,
}

/** Returns the owner and administrators */
export type supergroupMembersFilterAdministrators = {
  _: 'supergroupMembersFilterAdministrators',
}

/** Returns the owner and administrators */
export type supergroupMembersFilterAdministrators$Input = {
  readonly _: 'supergroupMembersFilterAdministrators',
}

/** Used to search for supergroup or channel members via a (string) query */
export type supergroupMembersFilterSearch = {
  _: 'supergroupMembersFilterSearch',
  /** Query to search for */
  query: string,
}

/** Used to search for supergroup or channel members via a (string) query */
export type supergroupMembersFilterSearch$Input = {
  readonly _: 'supergroupMembersFilterSearch',
  /** Query to search for */
  readonly query?: string,
}

/** Returns restricted supergroup members; can be used only by administrators */
export type supergroupMembersFilterRestricted = {
  _: 'supergroupMembersFilterRestricted',
  /** Query to search for */
  query: string,
}

/** Returns restricted supergroup members; can be used only by administrators */
export type supergroupMembersFilterRestricted$Input = {
  readonly _: 'supergroupMembersFilterRestricted',
  /** Query to search for */
  readonly query?: string,
}

/** Returns users banned from the supergroup or channel; can be used only by administrators */
export type supergroupMembersFilterBanned = {
  _: 'supergroupMembersFilterBanned',
  /** Query to search for */
  query: string,
}

/** Returns users banned from the supergroup or channel; can be used only by administrators */
export type supergroupMembersFilterBanned$Input = {
  readonly _: 'supergroupMembersFilterBanned',
  /** Query to search for */
  readonly query?: string,
}

/** Returns users which can be mentioned in the supergroup */
export type supergroupMembersFilterMention = {
  _: 'supergroupMembersFilterMention',
  /** Query to search for */
  query: string,
  /** If non-zero, the identifier of the current message thread */
  message_thread_id: number,
}

/** Returns users which can be mentioned in the supergroup */
export type supergroupMembersFilterMention$Input = {
  readonly _: 'supergroupMembersFilterMention',
  /** Query to search for */
  readonly query?: string,
  /** If non-zero, the identifier of the current message thread */
  readonly message_thread_id?: number,
}

/** Returns bot members of the supergroup or channel */
export type supergroupMembersFilterBots = {
  _: 'supergroupMembersFilterBots',
}

/** Returns bot members of the supergroup or channel */
export type supergroupMembersFilterBots$Input = {
  readonly _: 'supergroupMembersFilterBots',
}

/** Contains a chat invite link */
export type chatInviteLink = {
  _: 'chatInviteLink',
  /** Chat invite link */
  invite_link: string,
  /** Name of the link */
  name: string,
  /** User identifier of an administrator created the link */
  creator_user_id: number,
  /** Point in time (Unix timestamp) when the link was created */
  date: number,
  /** Point in time (Unix timestamp) when the link was last edited; 0 if never or unknown */
  edit_date: number,
  /** Point in time (Unix timestamp) when the link will expire; 0 if never */
  expiration_date: number,
  /**
   * The maximum number of members, which can join the chat using the link simultaneously;
   * 0 if not limited. Always 0 if the link requires approval
   */
  member_limit: number,
  /** Number of chat members, which joined the chat using the link */
  member_count: number,
  /** Number of pending join requests created using this link */
  pending_join_request_count: number,
  /**
   * True, if the link only creates join request. If true, total number of joining members
   * will be unlimited
   */
  creates_join_request: boolean,
  /**
   * True, if the link is primary. Primary invite link can't have name, expiration date,
   * or usage limit. There is exactly one primary invite link for each administrator with
   * can_invite_users right at a given time
   */
  is_primary: boolean,
  /** True, if the link was revoked */
  is_revoked: boolean,
}

/** Contains a chat invite link */
export type chatInviteLink$Input = {
  readonly _: 'chatInviteLink',
  /** Chat invite link */
  readonly invite_link?: string,
  /** Name of the link */
  readonly name?: string,
  /** User identifier of an administrator created the link */
  readonly creator_user_id?: number,
  /** Point in time (Unix timestamp) when the link was created */
  readonly date?: number,
  /** Point in time (Unix timestamp) when the link was last edited; 0 if never or unknown */
  readonly edit_date?: number,
  /** Point in time (Unix timestamp) when the link will expire; 0 if never */
  readonly expiration_date?: number,
  /**
   * The maximum number of members, which can join the chat using the link simultaneously;
   * 0 if not limited. Always 0 if the link requires approval
   */
  readonly member_limit?: number,
  /** Number of chat members, which joined the chat using the link */
  readonly member_count?: number,
  /** Number of pending join requests created using this link */
  readonly pending_join_request_count?: number,
  /**
   * True, if the link only creates join request. If true, total number of joining members
   * will be unlimited
   */
  readonly creates_join_request?: boolean,
  /**
   * True, if the link is primary. Primary invite link can't have name, expiration date,
   * or usage limit. There is exactly one primary invite link for each administrator with
   * can_invite_users right at a given time
   */
  readonly is_primary?: boolean,
  /** True, if the link was revoked */
  readonly is_revoked?: boolean,
}

/** Contains a list of chat invite links */
export type chatInviteLinks = {
  _: 'chatInviteLinks',
  /** Approximate total count of chat invite links found */
  total_count: number,
  /** List of invite links */
  invite_links: Array<chatInviteLink>,
}

/** Contains a list of chat invite links */
export type chatInviteLinks$Input = {
  readonly _: 'chatInviteLinks',
  /** Approximate total count of chat invite links found */
  readonly total_count?: number,
  /** List of invite links */
  readonly invite_links?: ReadonlyArray<chatInviteLink$Input>,
}

/** Describes a chat administrator with a number of active and revoked chat invite links */
export type chatInviteLinkCount = {
  _: 'chatInviteLinkCount',
  /** Administrator's user identifier */
  user_id: number,
  /** Number of active invite links */
  invite_link_count: number,
  /** Number of revoked invite links */
  revoked_invite_link_count: number,
}

/** Describes a chat administrator with a number of active and revoked chat invite links */
export type chatInviteLinkCount$Input = {
  readonly _: 'chatInviteLinkCount',
  /** Administrator's user identifier */
  readonly user_id?: number,
  /** Number of active invite links */
  readonly invite_link_count?: number,
  /** Number of revoked invite links */
  readonly revoked_invite_link_count?: number,
}

/** Contains a list of chat invite link counts */
export type chatInviteLinkCounts = {
  _: 'chatInviteLinkCounts',
  /** List of invite link counts */
  invite_link_counts: Array<chatInviteLinkCount>,
}

/** Contains a list of chat invite link counts */
export type chatInviteLinkCounts$Input = {
  readonly _: 'chatInviteLinkCounts',
  /** List of invite link counts */
  readonly invite_link_counts?: ReadonlyArray<chatInviteLinkCount$Input>,
}

/** Describes a chat member joined a chat via an invite link */
export type chatInviteLinkMember = {
  _: 'chatInviteLinkMember',
  /** User identifier */
  user_id: number,
  /** Point in time (Unix timestamp) when the user joined the chat */
  joined_chat_date: number,
  /** User identifier of the chat administrator, approved user join request */
  approver_user_id: number,
}

/** Describes a chat member joined a chat via an invite link */
export type chatInviteLinkMember$Input = {
  readonly _: 'chatInviteLinkMember',
  /** User identifier */
  readonly user_id?: number,
  /** Point in time (Unix timestamp) when the user joined the chat */
  readonly joined_chat_date?: number,
  /** User identifier of the chat administrator, approved user join request */
  readonly approver_user_id?: number,
}

/** Contains a list of chat members joined a chat via an invite link */
export type chatInviteLinkMembers = {
  _: 'chatInviteLinkMembers',
  /** Approximate total count of chat members found */
  total_count: number,
  /** List of chat members, joined a chat via an invite link */
  members: Array<chatInviteLinkMember>,
}

/** Contains a list of chat members joined a chat via an invite link */
export type chatInviteLinkMembers$Input = {
  readonly _: 'chatInviteLinkMembers',
  /** Approximate total count of chat members found */
  readonly total_count?: number,
  /** List of chat members, joined a chat via an invite link */
  readonly members?: ReadonlyArray<chatInviteLinkMember$Input>,
}

/** Contains information about a chat invite link */
export type chatInviteLinkInfo = {
  _: 'chatInviteLinkInfo',
  /**
   * Chat identifier of the invite link; 0 if the user has no access to the chat before
   * joining
   */
  chat_id: number,
  /**
   * If non-zero, the amount of time for which read access to the chat will remain available,
   * in seconds
   */
  accessible_for: number,
  /** Type of the chat */
  type: ChatType,
  /** Title of the chat */
  title: string,
  /** Chat photo; may be null */
  photo: chatPhotoInfo | undefined,
  /** Chat description */
  description: string,
  /** Number of members in the chat */
  member_count: number,
  /** User identifiers of some chat members that may be known to the current user */
  member_user_ids: Array<number>,
  /** True, if the link only creates join request */
  creates_join_request: boolean,
  /**
   * True, if the chat is a public supergroup or channel, i.e. it has a username or it
   * is a location-based supergroup
   */
  is_public: boolean,
}

/** Contains information about a chat invite link */
export type chatInviteLinkInfo$Input = {
  readonly _: 'chatInviteLinkInfo',
  /**
   * Chat identifier of the invite link; 0 if the user has no access to the chat before
   * joining
   */
  readonly chat_id?: number,
  /**
   * If non-zero, the amount of time for which read access to the chat will remain available,
   * in seconds
   */
  readonly accessible_for?: number,
  /** Type of the chat */
  readonly type?: ChatType$Input,
  /** Title of the chat */
  readonly title?: string,
  /** Chat photo; may be null */
  readonly photo?: chatPhotoInfo$Input | undefined,
  /** Chat description */
  readonly description?: string,
  /** Number of members in the chat */
  readonly member_count?: number,
  /** User identifiers of some chat members that may be known to the current user */
  readonly member_user_ids?: ReadonlyArray<number>,
  /** True, if the link only creates join request */
  readonly creates_join_request?: boolean,
  /**
   * True, if the chat is a public supergroup or channel, i.e. it has a username or it
   * is a location-based supergroup
   */
  readonly is_public?: boolean,
}

/** Describes a user that sent a join request and waits for administrator approval */
export type chatJoinRequest = {
  _: 'chatJoinRequest',
  /** User identifier */
  user_id: number,
  /** Point in time (Unix timestamp) when the user sent the join request */
  date: number,
  /** A short bio of the user */
  bio: string,
}

/** Describes a user that sent a join request and waits for administrator approval */
export type chatJoinRequest$Input = {
  readonly _: 'chatJoinRequest',
  /** User identifier */
  readonly user_id?: number,
  /** Point in time (Unix timestamp) when the user sent the join request */
  readonly date?: number,
  /** A short bio of the user */
  readonly bio?: string,
}

/** Contains a list of requests to join a chat */
export type chatJoinRequests = {
  _: 'chatJoinRequests',
  /** Approximate total count of requests found */
  total_count: number,
  /** List of the requests */
  requests: Array<chatJoinRequest>,
}

/** Contains a list of requests to join a chat */
export type chatJoinRequests$Input = {
  readonly _: 'chatJoinRequests',
  /** Approximate total count of requests found */
  readonly total_count?: number,
  /** List of the requests */
  readonly requests?: ReadonlyArray<chatJoinRequest$Input>,
}

/** Contains information about pending join requests for a chat */
export type chatJoinRequestsInfo = {
  _: 'chatJoinRequestsInfo',
  /** Total number of pending join requests */
  total_count: number,
  /** Identifiers of at most 3 users sent the newest pending join requests */
  user_ids: Array<number>,
}

/** Contains information about pending join requests for a chat */
export type chatJoinRequestsInfo$Input = {
  readonly _: 'chatJoinRequestsInfo',
  /** Total number of pending join requests */
  readonly total_count?: number,
  /** Identifiers of at most 3 users sent the newest pending join requests */
  readonly user_ids?: ReadonlyArray<number>,
}

/**
 * Represents a basic group of 0-200 users (must be upgraded to a supergroup to accommodate
 * more than 200 users)
 */
export type basicGroup = {
  _: 'basicGroup',
  /** Group identifier */
  id: number,
  /** Number of members in the group */
  member_count: number,
  /** Status of the current user in the group */
  status: ChatMemberStatus,
  /** True, if the group is active */
  is_active: boolean,
  /** Identifier of the supergroup to which this group was upgraded; 0 if none */
  upgraded_to_supergroup_id: number,
}

/**
 * Represents a basic group of 0-200 users (must be upgraded to a supergroup to accommodate
 * more than 200 users)
 */
export type basicGroup$Input = {
  readonly _: 'basicGroup',
  /** Group identifier */
  readonly id?: number,
  /** Number of members in the group */
  readonly member_count?: number,
  /** Status of the current user in the group */
  readonly status?: ChatMemberStatus$Input,
  /** True, if the group is active */
  readonly is_active?: boolean,
  /** Identifier of the supergroup to which this group was upgraded; 0 if none */
  readonly upgraded_to_supergroup_id?: number,
}

/** Contains full information about a basic group */
export type basicGroupFullInfo = {
  _: 'basicGroupFullInfo',
  /** Chat photo; may be null */
  photo: chatPhoto | undefined,
  /** Group description. Updated only after the basic group is opened */
  description: string,
  /** User identifier of the creator of the group; 0 if unknown */
  creator_user_id: number,
  /** Group members */
  members: Array<chatMember>,
  /**
   * Primary invite link for this group; may be null. For chat administrators with can_invite_users
   * right only. Updated only after the basic group is opened
   */
  invite_link: chatInviteLink | undefined,
  /** List of commands of bots in the group */
  bot_commands: Array<botCommands>,
}

/** Contains full information about a basic group */
export type basicGroupFullInfo$Input = {
  readonly _: 'basicGroupFullInfo',
  /** Chat photo; may be null */
  readonly photo?: chatPhoto$Input | undefined,
  /** Group description. Updated only after the basic group is opened */
  readonly description?: string,
  /** User identifier of the creator of the group; 0 if unknown */
  readonly creator_user_id?: number,
  /** Group members */
  readonly members?: ReadonlyArray<chatMember$Input>,
  /**
   * Primary invite link for this group; may be null. For chat administrators with can_invite_users
   * right only. Updated only after the basic group is opened
   */
  readonly invite_link?: chatInviteLink$Input | undefined,
  /** List of commands of bots in the group */
  readonly bot_commands?: ReadonlyArray<botCommands$Input>,
}

/**
 * Represents a supergroup or channel with zero or more members (subscribers in the
 * case of channels). From the point of view of the system, a channel is a special kind
 * of a supergroup: only administrators can post and see the list of members, and posts
 * from all administrators use the name and photo of the channel instead of individual
 * names and profile photos. Unlike supergroups, channels can have an unlimited number
 * of subscribers
 */
export type supergroup = {
  _: 'supergroup',
  /** Supergroup or channel identifier */
  id: number,
  /** Username of the supergroup or channel; empty for private supergroups or channels */
  username: string,
  /**
   * Point in time (Unix timestamp) when the current user joined, or the point in time
   * when the supergroup or channel was created, in case the user is not a member
   */
  date: number,
  /**
   * Status of the current user in the supergroup or channel; custom title will be always
   * empty
   */
  status: ChatMemberStatus,
  /**
   * Number of members in the supergroup or channel; 0 if unknown. Currently, it is guaranteed
   * to be known only if the supergroup or channel was received through searchPublicChats,
   * searchChatsNearby, getInactiveSupergroupChats, getSuitableDiscussionChats, getGroupsInCommon,
   * or getUserPrivacySettingRules
   */
  member_count: number,
  /**
   * True, if the channel has a discussion group, or the supergroup is the designated
   * discussion group for a channel
   */
  has_linked_chat: boolean,
  /**
   * True, if the supergroup is connected to a location, i.e. the supergroup is a location-based
   * supergroup
   */
  has_location: boolean,
  /**
   * True, if messages sent to the channel need to contain information about the sender.
   * This field is only applicable to channels
   */
  sign_messages: boolean,
  /** True, if the slow mode is enabled in the supergroup */
  is_slow_mode_enabled: boolean,
  /** True, if the supergroup is a channel */
  is_channel: boolean,
  /**
   * True, if the supergroup is a broadcast group, i.e. only administrators can send messages
   * and there is no limit on the number of members
   */
  is_broadcast_group: boolean,
  /** True, if the supergroup or channel is verified */
  is_verified: boolean,
  /**
   * If non-empty, contains a human-readable description of the reason why access to this
   * supergroup or channel must be restricted
   */
  restriction_reason: string,
  /** True, if many users reported this supergroup or channel as a scam */
  is_scam: boolean,
  /** True, if many users reported this supergroup or channel as a fake account */
  is_fake: boolean,
}

/**
 * Represents a supergroup or channel with zero or more members (subscribers in the
 * case of channels). From the point of view of the system, a channel is a special kind
 * of a supergroup: only administrators can post and see the list of members, and posts
 * from all administrators use the name and photo of the channel instead of individual
 * names and profile photos. Unlike supergroups, channels can have an unlimited number
 * of subscribers
 */
export type supergroup$Input = {
  readonly _: 'supergroup',
  /** Supergroup or channel identifier */
  readonly id?: number,
  /** Username of the supergroup or channel; empty for private supergroups or channels */
  readonly username?: string,
  /**
   * Point in time (Unix timestamp) when the current user joined, or the point in time
   * when the supergroup or channel was created, in case the user is not a member
   */
  readonly date?: number,
  /**
   * Status of the current user in the supergroup or channel; custom title will be always
   * empty
   */
  readonly status?: ChatMemberStatus$Input,
  /**
   * Number of members in the supergroup or channel; 0 if unknown. Currently, it is guaranteed
   * to be known only if the supergroup or channel was received through searchPublicChats,
   * searchChatsNearby, getInactiveSupergroupChats, getSuitableDiscussionChats, getGroupsInCommon,
   * or getUserPrivacySettingRules
   */
  readonly member_count?: number,
  /**
   * True, if the channel has a discussion group, or the supergroup is the designated
   * discussion group for a channel
   */
  readonly has_linked_chat?: boolean,
  /**
   * True, if the supergroup is connected to a location, i.e. the supergroup is a location-based
   * supergroup
   */
  readonly has_location?: boolean,
  /**
   * True, if messages sent to the channel need to contain information about the sender.
   * This field is only applicable to channels
   */
  readonly sign_messages?: boolean,
  /** True, if the slow mode is enabled in the supergroup */
  readonly is_slow_mode_enabled?: boolean,
  /** True, if the supergroup is a channel */
  readonly is_channel?: boolean,
  /**
   * True, if the supergroup is a broadcast group, i.e. only administrators can send messages
   * and there is no limit on the number of members
   */
  readonly is_broadcast_group?: boolean,
  /** True, if the supergroup or channel is verified */
  readonly is_verified?: boolean,
  /**
   * If non-empty, contains a human-readable description of the reason why access to this
   * supergroup or channel must be restricted
   */
  readonly restriction_reason?: string,
  /** True, if many users reported this supergroup or channel as a scam */
  readonly is_scam?: boolean,
  /** True, if many users reported this supergroup or channel as a fake account */
  readonly is_fake?: boolean,
}

/** Contains full information about a supergroup or channel */
export type supergroupFullInfo = {
  _: 'supergroupFullInfo',
  /** Chat photo; may be null */
  photo: chatPhoto | undefined,
  /** Supergroup or channel description */
  description: string,
  /** Number of members in the supergroup or channel; 0 if unknown */
  member_count: number,
  /** Number of privileged users in the supergroup or channel; 0 if unknown */
  administrator_count: number,
  /** Number of restricted users in the supergroup; 0 if unknown */
  restricted_count: number,
  /** Number of users banned from chat; 0 if unknown */
  banned_count: number,
  /**
   * Chat identifier of a discussion group for the channel, or a channel, for which the
   * supergroup is the designated discussion group; 0 if none or unknown
   */
  linked_chat_id: number,
  /**
   * Delay between consecutive sent messages for non-administrator supergroup members,
   * in seconds
   */
  slow_mode_delay: number,
  /**
   * Time left before next message can be sent in the supergroup, in seconds. An updateSupergroupFullInfo
   * update is not triggered when value of this field changes, but both new and old values
   * are non-zero
   */
  slow_mode_delay_expires_in: number,
  /** True, if members of the chat can be retrieved */
  can_get_members: boolean,
  /** True, if the chat username can be changed */
  can_set_username: boolean,
  /** True, if the supergroup sticker set can be changed */
  can_set_sticker_set: boolean,
  /** True, if the supergroup location can be changed */
  can_set_location: boolean,
  /** True, if the supergroup or channel statistics are available */
  can_get_statistics: boolean,
  /**
   * True, if new chat members will have access to old messages. In public or discussion
   * groups and both public and private channels, old messages are always available, so
   * this option affects only private supergroups without a linked chat. The value of
   * this field is only available for chat administrators
   */
  is_all_history_available: boolean,
  /** Identifier of the supergroup sticker set; 0 if none */
  sticker_set_id: number | string,
  /** Location to which the supergroup is connected; may be null */
  location: chatLocation | undefined,
  /**
   * Primary invite link for this chat; may be null. For chat administrators with can_invite_users
   * right only
   */
  invite_link: chatInviteLink | undefined,
  /** List of commands of bots in the group */
  bot_commands: Array<botCommands>,
  /** Identifier of the basic group from which supergroup was upgraded; 0 if none */
  upgraded_from_basic_group_id: number,
  /**
   * Identifier of the last message in the basic group from which supergroup was upgraded;
   * 0 if none
   */
  upgraded_from_max_message_id: number,
}

/** Contains full information about a supergroup or channel */
export type supergroupFullInfo$Input = {
  readonly _: 'supergroupFullInfo',
  /** Chat photo; may be null */
  readonly photo?: chatPhoto$Input | undefined,
  /** Supergroup or channel description */
  readonly description?: string,
  /** Number of members in the supergroup or channel; 0 if unknown */
  readonly member_count?: number,
  /** Number of privileged users in the supergroup or channel; 0 if unknown */
  readonly administrator_count?: number,
  /** Number of restricted users in the supergroup; 0 if unknown */
  readonly restricted_count?: number,
  /** Number of users banned from chat; 0 if unknown */
  readonly banned_count?: number,
  /**
   * Chat identifier of a discussion group for the channel, or a channel, for which the
   * supergroup is the designated discussion group; 0 if none or unknown
   */
  readonly linked_chat_id?: number,
  /**
   * Delay between consecutive sent messages for non-administrator supergroup members,
   * in seconds
   */
  readonly slow_mode_delay?: number,
  /**
   * Time left before next message can be sent in the supergroup, in seconds. An updateSupergroupFullInfo
   * update is not triggered when value of this field changes, but both new and old values
   * are non-zero
   */
  readonly slow_mode_delay_expires_in?: number,
  /** True, if members of the chat can be retrieved */
  readonly can_get_members?: boolean,
  /** True, if the chat username can be changed */
  readonly can_set_username?: boolean,
  /** True, if the supergroup sticker set can be changed */
  readonly can_set_sticker_set?: boolean,
  /** True, if the supergroup location can be changed */
  readonly can_set_location?: boolean,
  /** True, if the supergroup or channel statistics are available */
  readonly can_get_statistics?: boolean,
  /**
   * True, if new chat members will have access to old messages. In public or discussion
   * groups and both public and private channels, old messages are always available, so
   * this option affects only private supergroups without a linked chat. The value of
   * this field is only available for chat administrators
   */
  readonly is_all_history_available?: boolean,
  /** Identifier of the supergroup sticker set; 0 if none */
  readonly sticker_set_id?: number | string,
  /** Location to which the supergroup is connected; may be null */
  readonly location?: chatLocation$Input | undefined,
  /**
   * Primary invite link for this chat; may be null. For chat administrators with can_invite_users
   * right only
   */
  readonly invite_link?: chatInviteLink$Input | undefined,
  /** List of commands of bots in the group */
  readonly bot_commands?: ReadonlyArray<botCommands$Input>,
  /** Identifier of the basic group from which supergroup was upgraded; 0 if none */
  readonly upgraded_from_basic_group_id?: number,
  /**
   * Identifier of the last message in the basic group from which supergroup was upgraded;
   * 0 if none
   */
  readonly upgraded_from_max_message_id?: number,
}

/** The secret chat is not yet created; waiting for the other user to get online */
export type secretChatStatePending = {
  _: 'secretChatStatePending',
}

/** The secret chat is not yet created; waiting for the other user to get online */
export type secretChatStatePending$Input = {
  readonly _: 'secretChatStatePending',
}

/** The secret chat is ready to use */
export type secretChatStateReady = {
  _: 'secretChatStateReady',
}

/** The secret chat is ready to use */
export type secretChatStateReady$Input = {
  readonly _: 'secretChatStateReady',
}

/** The secret chat is closed */
export type secretChatStateClosed = {
  _: 'secretChatStateClosed',
}

/** The secret chat is closed */
export type secretChatStateClosed$Input = {
  readonly _: 'secretChatStateClosed',
}

/** Represents a secret chat */
export type secretChat = {
  _: 'secretChat',
  /** Secret chat identifier */
  id: number,
  /** Identifier of the chat partner */
  user_id: number,
  /** State of the secret chat */
  state: SecretChatState,
  /** True, if the chat was created by the current user; otherwise false */
  is_outbound: boolean,
  /**
   * Hash of the currently used key for comparison with the hash of the chat partner's
   * key. This is a string of 36 little-endian bytes, which must be split into groups
   * of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775, and 2F99C9.
   * The pixels must be used to make a 12x12 square image filled from left to right, top
   * to bottom. Alternatively, the first 32 bytes of the hash can be converted to the
   * hexadecimal format and printed as 32 2-digit hex numbers
   */
  key_hash: string,
  /**
   * Secret chat layer; determines features supported by the chat partner's application.
   * Nested text entities and underline and strikethrough entities are supported if the
   * layer >= 101
   */
  layer: number,
}

/** Represents a secret chat */
export type secretChat$Input = {
  readonly _: 'secretChat',
  /** Secret chat identifier */
  readonly id?: number,
  /** Identifier of the chat partner */
  readonly user_id?: number,
  /** State of the secret chat */
  readonly state?: SecretChatState$Input,
  /** True, if the chat was created by the current user; otherwise false */
  readonly is_outbound?: boolean,
  /**
   * Hash of the currently used key for comparison with the hash of the chat partner's
   * key. This is a string of 36 little-endian bytes, which must be split into groups
   * of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775, and 2F99C9.
   * The pixels must be used to make a 12x12 square image filled from left to right, top
   * to bottom. Alternatively, the first 32 bytes of the hash can be converted to the
   * hexadecimal format and printed as 32 2-digit hex numbers
   */
  readonly key_hash?: string,
  /**
   * Secret chat layer; determines features supported by the chat partner's application.
   * Nested text entities and underline and strikethrough entities are supported if the
   * layer >= 101
   */
  readonly layer?: number,
}

/** The message was sent by a known user */
export type messageSenderUser = {
  _: 'messageSenderUser',
  /** Identifier of the user that sent the message */
  user_id: number,
}

/** The message was sent by a known user */
export type messageSenderUser$Input = {
  readonly _: 'messageSenderUser',
  /** Identifier of the user that sent the message */
  readonly user_id?: number,
}

/** The message was sent on behalf of a chat */
export type messageSenderChat = {
  _: 'messageSenderChat',
  /** Identifier of the chat that sent the message */
  chat_id: number,
}

/** The message was sent on behalf of a chat */
export type messageSenderChat$Input = {
  readonly _: 'messageSenderChat',
  /** Identifier of the chat that sent the message */
  readonly chat_id?: number,
}

/** Represents a list of message senders */
export type messageSenders = {
  _: 'messageSenders',
  /** Approximate total count of messages senders found */
  total_count: number,
  /** List of message senders */
  senders: Array<MessageSender>,
}

/** Represents a list of message senders */
export type messageSenders$Input = {
  readonly _: 'messageSenders',
  /** Approximate total count of messages senders found */
  readonly total_count?: number,
  /** List of message senders */
  readonly senders?: ReadonlyArray<MessageSender$Input>,
}

/** The message was originally sent by a known user */
export type messageForwardOriginUser = {
  _: 'messageForwardOriginUser',
  /** Identifier of the user that originally sent the message */
  sender_user_id: number,
}

/** The message was originally sent by a known user */
export type messageForwardOriginUser$Input = {
  readonly _: 'messageForwardOriginUser',
  /** Identifier of the user that originally sent the message */
  readonly sender_user_id?: number,
}

/** The message was originally sent on behalf of a chat */
export type messageForwardOriginChat = {
  _: 'messageForwardOriginChat',
  /** Identifier of the chat that originally sent the message */
  sender_chat_id: number,
  /**
   * For messages originally sent by an anonymous chat administrator, original message
   * author signature
   */
  author_signature: string,
}

/** The message was originally sent on behalf of a chat */
export type messageForwardOriginChat$Input = {
  readonly _: 'messageForwardOriginChat',
  /** Identifier of the chat that originally sent the message */
  readonly sender_chat_id?: number,
  /**
   * For messages originally sent by an anonymous chat administrator, original message
   * author signature
   */
  readonly author_signature?: string,
}

/** The message was originally sent by a user, which is hidden by their privacy settings */
export type messageForwardOriginHiddenUser = {
  _: 'messageForwardOriginHiddenUser',
  /** Name of the sender */
  sender_name: string,
}

/** The message was originally sent by a user, which is hidden by their privacy settings */
export type messageForwardOriginHiddenUser$Input = {
  readonly _: 'messageForwardOriginHiddenUser',
  /** Name of the sender */
  readonly sender_name?: string,
}

/** The message was originally a post in a channel */
export type messageForwardOriginChannel = {
  _: 'messageForwardOriginChannel',
  /** Identifier of the chat from which the message was originally forwarded */
  chat_id: number,
  /** Message identifier of the original message */
  message_id: number,
  /** Original post author signature */
  author_signature: string,
}

/** The message was originally a post in a channel */
export type messageForwardOriginChannel$Input = {
  readonly _: 'messageForwardOriginChannel',
  /** Identifier of the chat from which the message was originally forwarded */
  readonly chat_id?: number,
  /** Message identifier of the original message */
  readonly message_id?: number,
  /** Original post author signature */
  readonly author_signature?: string,
}

/** The message was imported from an exported message history */
export type messageForwardOriginMessageImport = {
  _: 'messageForwardOriginMessageImport',
  /** Name of the sender */
  sender_name: string,
}

/** The message was imported from an exported message history */
export type messageForwardOriginMessageImport$Input = {
  readonly _: 'messageForwardOriginMessageImport',
  /** Name of the sender */
  readonly sender_name?: string,
}

/** Contains information about a forwarded message */
export type messageForwardInfo = {
  _: 'messageForwardInfo',
  /** Origin of a forwarded message */
  origin: MessageForwardOrigin,
  /** Point in time (Unix timestamp) when the message was originally sent */
  date: number,
  /** The type of a public service announcement for the forwarded message */
  public_service_announcement_type: string,
  /**
   * For messages forwarded to the chat with the current user (Saved Messages), to the
   * Replies bot chat, or to the channel's discussion group, the identifier of the chat
   * from which the message was forwarded last time; 0 if unknown
   */
  from_chat_id: number,
  /**
   * For messages forwarded to the chat with the current user (Saved Messages), to the
   * Replies bot chat, or to the channel's discussion group, the identifier of the original
   * message from which the new message was forwarded last time; 0 if unknown
   */
  from_message_id: number,
}

/** Contains information about a forwarded message */
export type messageForwardInfo$Input = {
  readonly _: 'messageForwardInfo',
  /** Origin of a forwarded message */
  readonly origin?: MessageForwardOrigin$Input,
  /** Point in time (Unix timestamp) when the message was originally sent */
  readonly date?: number,
  /** The type of a public service announcement for the forwarded message */
  readonly public_service_announcement_type?: string,
  /**
   * For messages forwarded to the chat with the current user (Saved Messages), to the
   * Replies bot chat, or to the channel's discussion group, the identifier of the chat
   * from which the message was forwarded last time; 0 if unknown
   */
  readonly from_chat_id?: number,
  /**
   * For messages forwarded to the chat with the current user (Saved Messages), to the
   * Replies bot chat, or to the channel's discussion group, the identifier of the original
   * message from which the new message was forwarded last time; 0 if unknown
   */
  readonly from_message_id?: number,
}

/** Contains information about replies to a message */
export type messageReplyInfo = {
  _: 'messageReplyInfo',
  /** Number of times the message was directly or indirectly replied */
  reply_count: number,
  /**
   * Identifiers of at most 3 recent repliers to the message; available in channels with
   * a discussion supergroup. The users and chats are expected to be inaccessible: only
   * their photo and name will be available
   */
  recent_replier_ids: Array<MessageSender>,
  /** Identifier of the last read incoming reply to the message */
  last_read_inbox_message_id: number,
  /** Identifier of the last read outgoing reply to the message */
  last_read_outbox_message_id: number,
  /** Identifier of the last reply to the message */
  last_message_id: number,
}

/** Contains information about replies to a message */
export type messageReplyInfo$Input = {
  readonly _: 'messageReplyInfo',
  /** Number of times the message was directly or indirectly replied */
  readonly reply_count?: number,
  /**
   * Identifiers of at most 3 recent repliers to the message; available in channels with
   * a discussion supergroup. The users and chats are expected to be inaccessible: only
   * their photo and name will be available
   */
  readonly recent_replier_ids?: ReadonlyArray<MessageSender$Input>,
  /** Identifier of the last read incoming reply to the message */
  readonly last_read_inbox_message_id?: number,
  /** Identifier of the last read outgoing reply to the message */
  readonly last_read_outbox_message_id?: number,
  /** Identifier of the last reply to the message */
  readonly last_message_id?: number,
}

/** Contains information about interactions with a message */
export type messageInteractionInfo = {
  _: 'messageInteractionInfo',
  /** Number of times the message was viewed */
  view_count: number,
  /** Number of times the message was forwarded */
  forward_count: number,
  /**
   * Information about direct or indirect replies to the message; may be null. Currently,
   * available only in channels with a discussion supergroup and discussion supergroups
   * for messages, which are not replies itself
   */
  reply_info: messageReplyInfo | undefined,
}

/** Contains information about interactions with a message */
export type messageInteractionInfo$Input = {
  readonly _: 'messageInteractionInfo',
  /** Number of times the message was viewed */
  readonly view_count?: number,
  /** Number of times the message was forwarded */
  readonly forward_count?: number,
  /**
   * Information about direct or indirect replies to the message; may be null. Currently,
   * available only in channels with a discussion supergroup and discussion supergroups
   * for messages, which are not replies itself
   */
  readonly reply_info?: messageReplyInfo$Input | undefined,
}

/** The message is being sent now, but has not yet been delivered to the server */
export type messageSendingStatePending = {
  _: 'messageSendingStatePending',
}

/** The message is being sent now, but has not yet been delivered to the server */
export type messageSendingStatePending$Input = {
  readonly _: 'messageSendingStatePending',
}

/** The message failed to be sent */
export type messageSendingStateFailed = {
  _: 'messageSendingStateFailed',
  /** An error code; 0 if unknown */
  error_code: number,
  /** Error message */
  error_message: string,
  /** True, if the message can be re-sent */
  can_retry: boolean,
  /** True, if the message can be re-sent only on behalf of a different sender */
  need_another_sender: boolean,
  /**
   * Time left before the message can be re-sent, in seconds. No update is sent when this
   * field changes
   */
  retry_after: number,
}

/** The message failed to be sent */
export type messageSendingStateFailed$Input = {
  readonly _: 'messageSendingStateFailed',
  /** An error code; 0 if unknown */
  readonly error_code?: number,
  /** Error message */
  readonly error_message?: string,
  /** True, if the message can be re-sent */
  readonly can_retry?: boolean,
  /** True, if the message can be re-sent only on behalf of a different sender */
  readonly need_another_sender?: boolean,
  /**
   * Time left before the message can be re-sent, in seconds. No update is sent when this
   * field changes
   */
  readonly retry_after?: number,
}

/** Describes a message */
export type message = {
  _: 'message',
  /** Message identifier; unique for the chat to which the message belongs */
  id: number,
  /** Identifier of the sender of the message */
  sender_id: MessageSender,
  /** Chat identifier */
  chat_id: number,
  /** The sending state of the message; may be null */
  sending_state: MessageSendingState | undefined,
  /** The scheduling state of the message; may be null */
  scheduling_state: MessageSchedulingState | undefined,
  /** True, if the message is outgoing */
  is_outgoing: boolean,
  /** True, if the message is pinned */
  is_pinned: boolean,
  /**
   * True, if the message can be edited. For live location and poll messages this fields
   * shows whether editMessageLiveLocation or stopPoll can be used with this message by
   * the application
   */
  can_be_edited: boolean,
  /** True, if the message can be forwarded */
  can_be_forwarded: boolean,
  /** True, if content of the message can be saved locally or copied */
  can_be_saved: boolean,
  /**
   * True, if the message can be deleted only for the current user while other users will
   * continue to see it
   */
  can_be_deleted_only_for_self: boolean,
  /** True, if the message can be deleted for all users */
  can_be_deleted_for_all_users: boolean,
  /** True, if the message statistics are available */
  can_get_statistics: boolean,
  /** True, if the message thread info is available */
  can_get_message_thread: boolean,
  /** True, if chat members already viewed the message can be received through getMessageViewers */
  can_get_viewers: boolean,
  /**
   * True, if media timestamp links can be generated for media timestamp entities in the
   * message text, caption or web page description
   */
  can_get_media_timestamp_links: boolean,
  /**
   * True, if media timestamp entities refers to a media in this message as opposed to
   * a media in the replied message
   */
  has_timestamped_media: boolean,
  /**
   * True, if the message is a channel post. All messages to channels are channel posts,
   * all other messages are not channel posts
   */
  is_channel_post: boolean,
  /** True, if the message contains an unread mention for the current user */
  contains_unread_mention: boolean,
  /** Point in time (Unix timestamp) when the message was sent */
  date: number,
  /** Point in time (Unix timestamp) when the message was last edited */
  edit_date: number,
  /** Information about the initial message sender; may be null */
  forward_info: messageForwardInfo | undefined,
  /** Information about interactions with the message; may be null */
  interaction_info: messageInteractionInfo | undefined,
  /**
   * If non-zero, the identifier of the chat to which the replied message belongs; Currently,
   * only messages in the Replies chat can have different reply_in_chat_id and chat_id
   */
  reply_in_chat_id: number,
  /**
   * If non-zero, the identifier of the message this message is replying to; can be the
   * identifier of a deleted message
   */
  reply_to_message_id: number,
  /**
   * If non-zero, the identifier of the message thread the message belongs to; unique
   * within the chat to which the message belongs
   */
  message_thread_id: number,
  /**
   * For self-destructing messages, the message's TTL (Time To Live), in seconds; 0 if
   * none. TDLib will send updateDeleteMessages or updateMessageContent once the TTL expires
   */
  ttl: number,
  /**
   * Time left before the message expires, in seconds. If the TTL timer isn't started
   * yet, equals to the value of the ttl field
   */
  ttl_expires_in: number,
  /** If non-zero, the user identifier of the bot through which this message was sent */
  via_bot_user_id: number,
  /** For channel posts and anonymous group messages, optional author signature */
  author_signature: string,
  /**
   * Unique identifier of an album this message belongs to. Only audios, documents, photos
   * and videos can be grouped together in albums
   */
  media_album_id: number | string,
  /**
   * If non-empty, contains a human-readable description of the reason why access to this
   * message must be restricted
   */
  restriction_reason: string,
  /** Content of the message */
  content: MessageContent,
  /** Reply markup for the message; may be null */
  reply_markup: ReplyMarkup | undefined,
}

/** Describes a message */
export type message$Input = {
  readonly _: 'message',
  /** Message identifier; unique for the chat to which the message belongs */
  readonly id?: number,
  /** Identifier of the sender of the message */
  readonly sender_id?: MessageSender$Input,
  /** Chat identifier */
  readonly chat_id?: number,
  /** The sending state of the message; may be null */
  readonly sending_state?: MessageSendingState$Input | undefined,
  /** The scheduling state of the message; may be null */
  readonly scheduling_state?: MessageSchedulingState$Input | undefined,
  /** True, if the message is outgoing */
  readonly is_outgoing?: boolean,
  /** True, if the message is pinned */
  readonly is_pinned?: boolean,
  /**
   * True, if the message can be edited. For live location and poll messages this fields
   * shows whether editMessageLiveLocation or stopPoll can be used with this message by
   * the application
   */
  readonly can_be_edited?: boolean,
  /** True, if the message can be forwarded */
  readonly can_be_forwarded?: boolean,
  /** True, if content of the message can be saved locally or copied */
  readonly can_be_saved?: boolean,
  /**
   * True, if the message can be deleted only for the current user while other users will
   * continue to see it
   */
  readonly can_be_deleted_only_for_self?: boolean,
  /** True, if the message can be deleted for all users */
  readonly can_be_deleted_for_all_users?: boolean,
  /** True, if the message statistics are available */
  readonly can_get_statistics?: boolean,
  /** True, if the message thread info is available */
  readonly can_get_message_thread?: boolean,
  /** True, if chat members already viewed the message can be received through getMessageViewers */
  readonly can_get_viewers?: boolean,
  /**
   * True, if media timestamp links can be generated for media timestamp entities in the
   * message text, caption or web page description
   */
  readonly can_get_media_timestamp_links?: boolean,
  /**
   * True, if media timestamp entities refers to a media in this message as opposed to
   * a media in the replied message
   */
  readonly has_timestamped_media?: boolean,
  /**
   * True, if the message is a channel post. All messages to channels are channel posts,
   * all other messages are not channel posts
   */
  readonly is_channel_post?: boolean,
  /** True, if the message contains an unread mention for the current user */
  readonly contains_unread_mention?: boolean,
  /** Point in time (Unix timestamp) when the message was sent */
  readonly date?: number,
  /** Point in time (Unix timestamp) when the message was last edited */
  readonly edit_date?: number,
  /** Information about the initial message sender; may be null */
  readonly forward_info?: messageForwardInfo$Input | undefined,
  /** Information about interactions with the message; may be null */
  readonly interaction_info?: messageInteractionInfo$Input | undefined,
  /**
   * If non-zero, the identifier of the chat to which the replied message belongs; Currently,
   * only messages in the Replies chat can have different reply_in_chat_id and chat_id
   */
  readonly reply_in_chat_id?: number,
  /**
   * If non-zero, the identifier of the message this message is replying to; can be the
   * identifier of a deleted message
   */
  readonly reply_to_message_id?: number,
  /**
   * If non-zero, the identifier of the message thread the message belongs to; unique
   * within the chat to which the message belongs
   */
  readonly message_thread_id?: number,
  /**
   * For self-destructing messages, the message's TTL (Time To Live), in seconds; 0 if
   * none. TDLib will send updateDeleteMessages or updateMessageContent once the TTL expires
   */
  readonly ttl?: number,
  /**
   * Time left before the message expires, in seconds. If the TTL timer isn't started
   * yet, equals to the value of the ttl field
   */
  readonly ttl_expires_in?: number,
  /** If non-zero, the user identifier of the bot through which this message was sent */
  readonly via_bot_user_id?: number,
  /** For channel posts and anonymous group messages, optional author signature */
  readonly author_signature?: string,
  /**
   * Unique identifier of an album this message belongs to. Only audios, documents, photos
   * and videos can be grouped together in albums
   */
  readonly media_album_id?: number | string,
  /**
   * If non-empty, contains a human-readable description of the reason why access to this
   * message must be restricted
   */
  readonly restriction_reason?: string,
  /** Content of the message */
  readonly content?: MessageContent$Input,
  /** Reply markup for the message; may be null */
  readonly reply_markup?: ReplyMarkup$Input | undefined,
}

/** Contains a list of messages */
export type messages = {
  _: 'messages',
  /** Approximate total count of messages found */
  total_count: number,
  /** List of messages; messages may be null */
  messages: Array<message | undefined>,
}

/** Contains a list of messages */
export type messages$Input = {
  readonly _: 'messages',
  /** Approximate total count of messages found */
  readonly total_count?: number,
  /** List of messages; messages may be null */
  readonly messages?: ReadonlyArray<message$Input | undefined>,
}

/** Contains a list of messages found by a search */
export type foundMessages = {
  _: 'foundMessages',
  /** Approximate total count of messages found; -1 if unknown */
  total_count: number,
  /** List of messages */
  messages: Array<message>,
  /** The offset for the next request. If empty, there are no more results */
  next_offset: string,
}

/** Contains a list of messages found by a search */
export type foundMessages$Input = {
  readonly _: 'foundMessages',
  /** Approximate total count of messages found; -1 if unknown */
  readonly total_count?: number,
  /** List of messages */
  readonly messages?: ReadonlyArray<message$Input>,
  /** The offset for the next request. If empty, there are no more results */
  readonly next_offset?: string,
}

/** Contains information about a message in a specific position */
export type messagePosition = {
  _: 'messagePosition',
  /** 0-based message position in the full list of suitable messages */
  position: number,
  /** Message identifier */
  message_id: number,
  /** Point in time (Unix timestamp) when the message was sent */
  date: number,
}

/** Contains information about a message in a specific position */
export type messagePosition$Input = {
  readonly _: 'messagePosition',
  /** 0-based message position in the full list of suitable messages */
  readonly position?: number,
  /** Message identifier */
  readonly message_id?: number,
  /** Point in time (Unix timestamp) when the message was sent */
  readonly date?: number,
}

/** Contains a list of message positions */
export type messagePositions = {
  _: 'messagePositions',
  /** Total count of messages found */
  total_count: number,
  /** List of message positions */
  positions: Array<messagePosition>,
}

/** Contains a list of message positions */
export type messagePositions$Input = {
  readonly _: 'messagePositions',
  /** Total count of messages found */
  readonly total_count?: number,
  /** List of message positions */
  readonly positions?: ReadonlyArray<messagePosition$Input>,
}

/** Contains information about found messages sent on a specific day */
export type messageCalendarDay = {
  _: 'messageCalendarDay',
  /** Total number of found messages sent on the day */
  total_count: number,
  /** First message sent on the day */
  message: message,
}

/** Contains information about found messages sent on a specific day */
export type messageCalendarDay$Input = {
  readonly _: 'messageCalendarDay',
  /** Total number of found messages sent on the day */
  readonly total_count?: number,
  /** First message sent on the day */
  readonly message?: message$Input,
}

/**
 * Contains information about found messages, split by days according to the option
 * "utc_time_offset"
 */
export type messageCalendar = {
  _: 'messageCalendar',
  /** Total number of found messages */
  total_count: number,
  /** Information about messages sent */
  days: Array<messageCalendarDay>,
}

/**
 * Contains information about found messages, split by days according to the option
 * "utc_time_offset"
 */
export type messageCalendar$Input = {
  readonly _: 'messageCalendar',
  /** Total number of found messages */
  readonly total_count?: number,
  /** Information about messages sent */
  readonly days?: ReadonlyArray<messageCalendarDay$Input>,
}

/** Describes a sponsored message */
export type sponsoredMessage = {
  _: 'sponsoredMessage',
  /**
   * Message identifier; unique for the chat to which the sponsored message belongs among
   * both ordinary and sponsored messages
   */
  message_id: number,
  /** Chat identifier */
  sponsor_chat_id: number,
  /**
   * An internal link to be opened when the sponsored message is clicked; may be null.
   * If null, the sponsor chat needs to be opened instead
   */
  link: InternalLinkType | undefined,
  /** Content of the message. Currently, can be only of the type messageText */
  content: MessageContent,
}

/** Describes a sponsored message */
export type sponsoredMessage$Input = {
  readonly _: 'sponsoredMessage',
  /**
   * Message identifier; unique for the chat to which the sponsored message belongs among
   * both ordinary and sponsored messages
   */
  readonly message_id?: number,
  /** Chat identifier */
  readonly sponsor_chat_id?: number,
  /**
   * An internal link to be opened when the sponsored message is clicked; may be null.
   * If null, the sponsor chat needs to be opened instead
   */
  readonly link?: InternalLinkType$Input | undefined,
  /** Content of the message. Currently, can be only of the type messageText */
  readonly content?: MessageContent$Input,
}

/**
 * Notification settings applied to all private and secret chats when the corresponding
 * chat setting has a default value
 */
export type notificationSettingsScopePrivateChats = {
  _: 'notificationSettingsScopePrivateChats',
}

/**
 * Notification settings applied to all private and secret chats when the corresponding
 * chat setting has a default value
 */
export type notificationSettingsScopePrivateChats$Input = {
  readonly _: 'notificationSettingsScopePrivateChats',
}

/**
 * Notification settings applied to all basic groups and supergroups when the corresponding
 * chat setting has a default value
 */
export type notificationSettingsScopeGroupChats = {
  _: 'notificationSettingsScopeGroupChats',
}

/**
 * Notification settings applied to all basic groups and supergroups when the corresponding
 * chat setting has a default value
 */
export type notificationSettingsScopeGroupChats$Input = {
  readonly _: 'notificationSettingsScopeGroupChats',
}

/**
 * Notification settings applied to all channels when the corresponding chat setting
 * has a default value
 */
export type notificationSettingsScopeChannelChats = {
  _: 'notificationSettingsScopeChannelChats',
}

/**
 * Notification settings applied to all channels when the corresponding chat setting
 * has a default value
 */
export type notificationSettingsScopeChannelChats$Input = {
  readonly _: 'notificationSettingsScopeChannelChats',
}

/** Contains information about notification settings for a chat */
export type chatNotificationSettings = {
  _: 'chatNotificationSettings',
  /**
   * If true, mute_for is ignored and the value for the relevant type of chat is used
   * instead
   */
  use_default_mute_for: boolean,
  /** Time left before notifications will be unmuted, in seconds */
  mute_for: number,
  /** If true, sound is ignored and the value for the relevant type of chat is used instead */
  use_default_sound: boolean,
  /**
   * The name of an audio file to be used for notification sounds; only applies to iOS
   * applications
   */
  sound: string,
  /**
   * If true, show_preview is ignored and the value for the relevant type of chat is used
   * instead
   */
  use_default_show_preview: boolean,
  /** True, if message content must be displayed in notifications */
  show_preview: boolean,
  /**
   * If true, disable_pinned_message_notifications is ignored and the value for the relevant
   * type of chat is used instead
   */
  use_default_disable_pinned_message_notifications: boolean,
  /**
   * If true, notifications for incoming pinned messages will be created as for an ordinary
   * unread message
   */
  disable_pinned_message_notifications: boolean,
  /**
   * If true, disable_mention_notifications is ignored and the value for the relevant
   * type of chat is used instead
   */
  use_default_disable_mention_notifications: boolean,
  /**
   * If true, notifications for messages with mentions will be created as for an ordinary
   * unread message
   */
  disable_mention_notifications: boolean,
}

/** Contains information about notification settings for a chat */
export type chatNotificationSettings$Input = {
  readonly _: 'chatNotificationSettings',
  /**
   * If true, mute_for is ignored and the value for the relevant type of chat is used
   * instead
   */
  readonly use_default_mute_for?: boolean,
  /** Time left before notifications will be unmuted, in seconds */
  readonly mute_for?: number,
  /** If true, sound is ignored and the value for the relevant type of chat is used instead */
  readonly use_default_sound?: boolean,
  /**
   * The name of an audio file to be used for notification sounds; only applies to iOS
   * applications
   */
  readonly sound?: string,
  /**
   * If true, show_preview is ignored and the value for the relevant type of chat is used
   * instead
   */
  readonly use_default_show_preview?: boolean,
  /** True, if message content must be displayed in notifications */
  readonly show_preview?: boolean,
  /**
   * If true, disable_pinned_message_notifications is ignored and the value for the relevant
   * type of chat is used instead
   */
  readonly use_default_disable_pinned_message_notifications?: boolean,
  /**
   * If true, notifications for incoming pinned messages will be created as for an ordinary
   * unread message
   */
  readonly disable_pinned_message_notifications?: boolean,
  /**
   * If true, disable_mention_notifications is ignored and the value for the relevant
   * type of chat is used instead
   */
  readonly use_default_disable_mention_notifications?: boolean,
  /**
   * If true, notifications for messages with mentions will be created as for an ordinary
   * unread message
   */
  readonly disable_mention_notifications?: boolean,
}

/** Contains information about notification settings for several chats */
export type scopeNotificationSettings = {
  _: 'scopeNotificationSettings',
  /** Time left before notifications will be unmuted, in seconds */
  mute_for: number,
  /**
   * The name of an audio file to be used for notification sounds; only applies to iOS
   * applications
   */
  sound: string,
  /** True, if message content must be displayed in notifications */
  show_preview: boolean,
  /**
   * True, if notifications for incoming pinned messages will be created as for an ordinary
   * unread message
   */
  disable_pinned_message_notifications: boolean,
  /**
   * True, if notifications for messages with mentions will be created as for an ordinary
   * unread message
   */
  disable_mention_notifications: boolean,
}

/** Contains information about notification settings for several chats */
export type scopeNotificationSettings$Input = {
  readonly _: 'scopeNotificationSettings',
  /** Time left before notifications will be unmuted, in seconds */
  readonly mute_for?: number,
  /**
   * The name of an audio file to be used for notification sounds; only applies to iOS
   * applications
   */
  readonly sound?: string,
  /** True, if message content must be displayed in notifications */
  readonly show_preview?: boolean,
  /**
   * True, if notifications for incoming pinned messages will be created as for an ordinary
   * unread message
   */
  readonly disable_pinned_message_notifications?: boolean,
  /**
   * True, if notifications for messages with mentions will be created as for an ordinary
   * unread message
   */
  readonly disable_mention_notifications?: boolean,
}

/** Contains information about a message draft */
export type draftMessage = {
  _: 'draftMessage',
  /** Identifier of the message to reply to; 0 if none */
  reply_to_message_id: number,
  /** Point in time (Unix timestamp) when the draft was created */
  date: number,
  /** Content of the message draft; must be of the type inputMessageText */
  input_message_text: InputMessageContent,
}

/** Contains information about a message draft */
export type draftMessage$Input = {
  readonly _: 'draftMessage',
  /** Identifier of the message to reply to; 0 if none */
  readonly reply_to_message_id?: number,
  /** Point in time (Unix timestamp) when the draft was created */
  readonly date?: number,
  /** Content of the message draft; must be of the type inputMessageText */
  readonly input_message_text?: InputMessageContent$Input,
}

/** An ordinary chat with a user */
export type chatTypePrivate = {
  _: 'chatTypePrivate',
  /** User identifier */
  user_id: number,
}

/** An ordinary chat with a user */
export type chatTypePrivate$Input = {
  readonly _: 'chatTypePrivate',
  /** User identifier */
  readonly user_id?: number,
}

/** A basic group (a chat with 0-200 other users) */
export type chatTypeBasicGroup = {
  _: 'chatTypeBasicGroup',
  /** Basic group identifier */
  basic_group_id: number,
}

/** A basic group (a chat with 0-200 other users) */
export type chatTypeBasicGroup$Input = {
  readonly _: 'chatTypeBasicGroup',
  /** Basic group identifier */
  readonly basic_group_id?: number,
}

/** A supergroup or channel (with unlimited members) */
export type chatTypeSupergroup = {
  _: 'chatTypeSupergroup',
  /** Supergroup or channel identifier */
  supergroup_id: number,
  /** True, if the supergroup is a channel */
  is_channel: boolean,
}

/** A supergroup or channel (with unlimited members) */
export type chatTypeSupergroup$Input = {
  readonly _: 'chatTypeSupergroup',
  /** Supergroup or channel identifier */
  readonly supergroup_id?: number,
  /** True, if the supergroup is a channel */
  readonly is_channel?: boolean,
}

/** A secret chat with a user */
export type chatTypeSecret = {
  _: 'chatTypeSecret',
  /** Secret chat identifier */
  secret_chat_id: number,
  /** User identifier of the secret chat peer */
  user_id: number,
}

/** A secret chat with a user */
export type chatTypeSecret$Input = {
  readonly _: 'chatTypeSecret',
  /** Secret chat identifier */
  readonly secret_chat_id?: number,
  /** User identifier of the secret chat peer */
  readonly user_id?: number,
}

/** Represents a filter of user chats */
export type chatFilter = {
  _: 'chatFilter',
  /** The title of the filter; 1-12 characters without line feeds */
  title: string,
  /**
   * The chosen icon name for short filter representation. If non-empty, must be one of
   * "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup",
   * "Cat", "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport",
   * "Study", "Trade", "Travel", "Work". If empty, use getChatFilterDefaultIconName to
   * get default icon name for the filter
   */
  icon_name: string,
  /** The chat identifiers of pinned chats in the filtered chat list */
  pinned_chat_ids: Array<number>,
  /** The chat identifiers of always included chats in the filtered chat list */
  included_chat_ids: Array<number>,
  /** The chat identifiers of always excluded chats in the filtered chat list */
  excluded_chat_ids: Array<number>,
  /** True, if muted chats need to be excluded */
  exclude_muted: boolean,
  /** True, if read chats need to be excluded */
  exclude_read: boolean,
  /** True, if archived chats need to be excluded */
  exclude_archived: boolean,
  /** True, if contacts need to be included */
  include_contacts: boolean,
  /** True, if non-contact users need to be included */
  include_non_contacts: boolean,
  /** True, if bots need to be included */
  include_bots: boolean,
  /** True, if basic groups and supergroups need to be included */
  include_groups: boolean,
  /** True, if channels need to be included */
  include_channels: boolean,
}

/** Represents a filter of user chats */
export type chatFilter$Input = {
  readonly _: 'chatFilter',
  /** The title of the filter; 1-12 characters without line feeds */
  readonly title?: string,
  /**
   * The chosen icon name for short filter representation. If non-empty, must be one of
   * "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup",
   * "Cat", "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport",
   * "Study", "Trade", "Travel", "Work". If empty, use getChatFilterDefaultIconName to
   * get default icon name for the filter
   */
  readonly icon_name?: string,
  /** The chat identifiers of pinned chats in the filtered chat list */
  readonly pinned_chat_ids?: ReadonlyArray<number>,
  /** The chat identifiers of always included chats in the filtered chat list */
  readonly included_chat_ids?: ReadonlyArray<number>,
  /** The chat identifiers of always excluded chats in the filtered chat list */
  readonly excluded_chat_ids?: ReadonlyArray<number>,
  /** True, if muted chats need to be excluded */
  readonly exclude_muted?: boolean,
  /** True, if read chats need to be excluded */
  readonly exclude_read?: boolean,
  /** True, if archived chats need to be excluded */
  readonly exclude_archived?: boolean,
  /** True, if contacts need to be included */
  readonly include_contacts?: boolean,
  /** True, if non-contact users need to be included */
  readonly include_non_contacts?: boolean,
  /** True, if bots need to be included */
  readonly include_bots?: boolean,
  /** True, if basic groups and supergroups need to be included */
  readonly include_groups?: boolean,
  /** True, if channels need to be included */
  readonly include_channels?: boolean,
}

/** Contains basic information about a chat filter */
export type chatFilterInfo = {
  _: 'chatFilterInfo',
  /** Unique chat filter identifier */
  id: number,
  /** The title of the filter; 1-12 characters without line feeds */
  title: string,
  /**
   * The chosen or default icon name for short filter representation. One of "All", "Unread",
   * "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat", "Crown",
   * "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport", "Study",
   * "Trade", "Travel", "Work"
   */
  icon_name: string,
}

/** Contains basic information about a chat filter */
export type chatFilterInfo$Input = {
  readonly _: 'chatFilterInfo',
  /** Unique chat filter identifier */
  readonly id?: number,
  /** The title of the filter; 1-12 characters without line feeds */
  readonly title?: string,
  /**
   * The chosen or default icon name for short filter representation. One of "All", "Unread",
   * "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat", "Crown",
   * "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport", "Study",
   * "Trade", "Travel", "Work"
   */
  readonly icon_name?: string,
}

/** Describes a recommended chat filter */
export type recommendedChatFilter = {
  _: 'recommendedChatFilter',
  /** The chat filter */
  filter: chatFilter,
  /** Chat filter description */
  description: string,
}

/** Describes a recommended chat filter */
export type recommendedChatFilter$Input = {
  readonly _: 'recommendedChatFilter',
  /** The chat filter */
  readonly filter?: chatFilter$Input,
  /** Chat filter description */
  readonly description?: string,
}

/** Contains a list of recommended chat filters */
export type recommendedChatFilters = {
  _: 'recommendedChatFilters',
  /** List of recommended chat filters */
  chat_filters: Array<recommendedChatFilter>,
}

/** Contains a list of recommended chat filters */
export type recommendedChatFilters$Input = {
  readonly _: 'recommendedChatFilters',
  /** List of recommended chat filters */
  readonly chat_filters?: ReadonlyArray<recommendedChatFilter$Input>,
}

/** A main list of chats */
export type chatListMain = {
  _: 'chatListMain',
}

/** A main list of chats */
export type chatListMain$Input = {
  readonly _: 'chatListMain',
}

/**
 * A list of chats usually located at the top of the main chat list. Unmuted chats are
 * automatically moved from the Archive to the Main chat list when a new message arrives
 */
export type chatListArchive = {
  _: 'chatListArchive',
}

/**
 * A list of chats usually located at the top of the main chat list. Unmuted chats are
 * automatically moved from the Archive to the Main chat list when a new message arrives
 */
export type chatListArchive$Input = {
  readonly _: 'chatListArchive',
}

/** A list of chats belonging to a chat filter */
export type chatListFilter = {
  _: 'chatListFilter',
  /** Chat filter identifier */
  chat_filter_id: number,
}

/** A list of chats belonging to a chat filter */
export type chatListFilter$Input = {
  readonly _: 'chatListFilter',
  /** Chat filter identifier */
  readonly chat_filter_id?: number,
}

/** Contains a list of chat lists */
export type chatLists = {
  _: 'chatLists',
  /** List of chat lists */
  chat_lists: Array<ChatList>,
}

/** Contains a list of chat lists */
export type chatLists$Input = {
  readonly _: 'chatLists',
  /** List of chat lists */
  readonly chat_lists?: ReadonlyArray<ChatList$Input>,
}

/** The chat is sponsored by the user's MTProxy server */
export type chatSourceMtprotoProxy = {
  _: 'chatSourceMtprotoProxy',
}

/** The chat is sponsored by the user's MTProxy server */
export type chatSourceMtprotoProxy$Input = {
  readonly _: 'chatSourceMtprotoProxy',
}

/** The chat contains a public service announcement */
export type chatSourcePublicServiceAnnouncement = {
  _: 'chatSourcePublicServiceAnnouncement',
  /** The type of the announcement */
  type: string,
  /** The text of the announcement */
  text: string,
}

/** The chat contains a public service announcement */
export type chatSourcePublicServiceAnnouncement$Input = {
  readonly _: 'chatSourcePublicServiceAnnouncement',
  /** The type of the announcement */
  readonly type?: string,
  /** The text of the announcement */
  readonly text?: string,
}

/** Describes a position of a chat in a chat list */
export type chatPosition = {
  _: 'chatPosition',
  /** The chat list */
  list: ChatList,
  /**
   * A parameter used to determine order of the chat in the chat list. Chats must be sorted
   * by the pair (order, chat.id) in descending order
   */
  order: number | string,
  /** True, if the chat is pinned in the chat list */
  is_pinned: boolean,
  /** Source of the chat in the chat list; may be null */
  source: ChatSource | undefined,
}

/** Describes a position of a chat in a chat list */
export type chatPosition$Input = {
  readonly _: 'chatPosition',
  /** The chat list */
  readonly list?: ChatList$Input,
  /**
   * A parameter used to determine order of the chat in the chat list. Chats must be sorted
   * by the pair (order, chat.id) in descending order
   */
  readonly order?: number | string,
  /** True, if the chat is pinned in the chat list */
  readonly is_pinned?: boolean,
  /** Source of the chat in the chat list; may be null */
  readonly source?: ChatSource$Input | undefined,
}

/** Describes a video chat */
export type videoChat = {
  _: 'videoChat',
  /**
   * Group call identifier of an active video chat; 0 if none. Full information about
   * the video chat can be received through the method getGroupCall
   */
  group_call_id: number,
  /** True, if the video chat has participants */
  has_participants: boolean,
  /** Default group call participant identifier to join the video chat; may be null */
  default_participant_id: MessageSender | undefined,
}

/** Describes a video chat */
export type videoChat$Input = {
  readonly _: 'videoChat',
  /**
   * Group call identifier of an active video chat; 0 if none. Full information about
   * the video chat can be received through the method getGroupCall
   */
  readonly group_call_id?: number,
  /** True, if the video chat has participants */
  readonly has_participants?: boolean,
  /** Default group call participant identifier to join the video chat; may be null */
  readonly default_participant_id?: MessageSender$Input | undefined,
}

/** A chat. (Can be a private chat, basic group, supergroup, or secret chat) */
export type chat = {
  _: 'chat',
  /** Chat unique identifier */
  id: number,
  /** Type of the chat */
  type: ChatType,
  /** Chat title */
  title: string,
  /** Chat photo; may be null */
  photo: chatPhotoInfo | undefined,
  /** Actions that non-administrator chat members are allowed to take in the chat */
  permissions: chatPermissions,
  /** Last message in the chat; may be null */
  last_message: message | undefined,
  /** Positions of the chat in chat lists */
  positions: Array<chatPosition>,
  /**
   * Identifier of a user or chat that is selected to send messages in the chat; may be
   * null if the user can't change message sender
   */
  message_sender_id: MessageSender | undefined,
  /** True, if chat content can't be saved locally, forwarded, or copied */
  has_protected_content: boolean,
  /** True, if the chat is marked as unread */
  is_marked_as_unread: boolean,
  /**
   * True, if the chat is blocked by the current user and private messages from the chat
   * can't be received
   */
  is_blocked: boolean,
  /** True, if the chat has scheduled messages */
  has_scheduled_messages: boolean,
  /**
   * True, if the chat messages can be deleted only for the current user while other users
   * will continue to see the messages
   */
  can_be_deleted_only_for_self: boolean,
  /** True, if the chat messages can be deleted for all users */
  can_be_deleted_for_all_users: boolean,
  /** True, if the chat can be reported to Telegram moderators through reportChat or reportChatPhoto */
  can_be_reported: boolean,
  /**
   * Default value of the disable_notification parameter, used when a message is sent
   * to the chat
   */
  default_disable_notification: boolean,
  /** Number of unread messages in the chat */
  unread_count: number,
  /** Identifier of the last read incoming message */
  last_read_inbox_message_id: number,
  /** Identifier of the last read outgoing message */
  last_read_outbox_message_id: number,
  /** Number of unread messages with a mention/reply in the chat */
  unread_mention_count: number,
  /** Notification settings for this chat */
  notification_settings: chatNotificationSettings,
  /**
   * Current message Time To Live setting (self-destruct timer) for the chat; 0 if not
   * defined. TTL is counted from the time message or its content is viewed in secret
   * chats and from the send date in other chats
   */
  message_ttl: number,
  /** If non-empty, name of a theme, set for the chat */
  theme_name: string,
  /**
   * Information about actions which must be possible to do through the chat action bar;
   * may be null
   */
  action_bar: ChatActionBar | undefined,
  /** Information about video chat of the chat */
  video_chat: videoChat,
  /** Information about pending join requests; may be null */
  pending_join_requests: chatJoinRequestsInfo | undefined,
  /**
   * Identifier of the message from which reply markup needs to be used; 0 if there is
   * no default custom reply markup in the chat
   */
  reply_markup_message_id: number,
  /** A draft of a message in the chat; may be null */
  draft_message: draftMessage | undefined,
  /**
   * Application-specific data associated with the chat. (For example, the chat scroll
   * position or local chat notification settings can be stored here.) Persistent if the
   * message database is used
   */
  client_data: string,
}

/** A chat. (Can be a private chat, basic group, supergroup, or secret chat) */
export type chat$Input = {
  readonly _: 'chat',
  /** Chat unique identifier */
  readonly id?: number,
  /** Type of the chat */
  readonly type?: ChatType$Input,
  /** Chat title */
  readonly title?: string,
  /** Chat photo; may be null */
  readonly photo?: chatPhotoInfo$Input | undefined,
  /** Actions that non-administrator chat members are allowed to take in the chat */
  readonly permissions?: chatPermissions$Input,
  /** Last message in the chat; may be null */
  readonly last_message?: message$Input | undefined,
  /** Positions of the chat in chat lists */
  readonly positions?: ReadonlyArray<chatPosition$Input>,
  /**
   * Identifier of a user or chat that is selected to send messages in the chat; may be
   * null if the user can't change message sender
   */
  readonly message_sender_id?: MessageSender$Input | undefined,
  /** True, if chat content can't be saved locally, forwarded, or copied */
  readonly has_protected_content?: boolean,
  /** True, if the chat is marked as unread */
  readonly is_marked_as_unread?: boolean,
  /**
   * True, if the chat is blocked by the current user and private messages from the chat
   * can't be received
   */
  readonly is_blocked?: boolean,
  /** True, if the chat has scheduled messages */
  readonly has_scheduled_messages?: boolean,
  /**
   * True, if the chat messages can be deleted only for the current user while other users
   * will continue to see the messages
   */
  readonly can_be_deleted_only_for_self?: boolean,
  /** True, if the chat messages can be deleted for all users */
  readonly can_be_deleted_for_all_users?: boolean,
  /** True, if the chat can be reported to Telegram moderators through reportChat or reportChatPhoto */
  readonly can_be_reported?: boolean,
  /**
   * Default value of the disable_notification parameter, used when a message is sent
   * to the chat
   */
  readonly default_disable_notification?: boolean,
  /** Number of unread messages in the chat */
  readonly unread_count?: number,
  /** Identifier of the last read incoming message */
  readonly last_read_inbox_message_id?: number,
  /** Identifier of the last read outgoing message */
  readonly last_read_outbox_message_id?: number,
  /** Number of unread messages with a mention/reply in the chat */
  readonly unread_mention_count?: number,
  /** Notification settings for this chat */
  readonly notification_settings?: chatNotificationSettings$Input,
  /**
   * Current message Time To Live setting (self-destruct timer) for the chat; 0 if not
   * defined. TTL is counted from the time message or its content is viewed in secret
   * chats and from the send date in other chats
   */
  readonly message_ttl?: number,
  /** If non-empty, name of a theme, set for the chat */
  readonly theme_name?: string,
  /**
   * Information about actions which must be possible to do through the chat action bar;
   * may be null
   */
  readonly action_bar?: ChatActionBar$Input | undefined,
  /** Information about video chat of the chat */
  readonly video_chat?: videoChat$Input,
  /** Information about pending join requests; may be null */
  readonly pending_join_requests?: chatJoinRequestsInfo$Input | undefined,
  /**
   * Identifier of the message from which reply markup needs to be used; 0 if there is
   * no default custom reply markup in the chat
   */
  readonly reply_markup_message_id?: number,
  /** A draft of a message in the chat; may be null */
  readonly draft_message?: draftMessage$Input | undefined,
  /**
   * Application-specific data associated with the chat. (For example, the chat scroll
   * position or local chat notification settings can be stored here.) Persistent if the
   * message database is used
   */
  readonly client_data?: string,
}

/** Represents a list of chats */
export type chats = {
  _: 'chats',
  /** Approximate total count of chats found */
  total_count: number,
  /** List of chat identifiers */
  chat_ids: Array<number>,
}

/** Represents a list of chats */
export type chats$Input = {
  readonly _: 'chats',
  /** Approximate total count of chats found */
  readonly total_count?: number,
  /** List of chat identifiers */
  readonly chat_ids?: ReadonlyArray<number>,
}

/** Describes a chat located nearby */
export type chatNearby = {
  _: 'chatNearby',
  /** Chat identifier */
  chat_id: number,
  /** Distance to the chat location, in meters */
  distance: number,
}

/** Describes a chat located nearby */
export type chatNearby$Input = {
  readonly _: 'chatNearby',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Distance to the chat location, in meters */
  readonly distance?: number,
}

/** Represents a list of chats located nearby */
export type chatsNearby = {
  _: 'chatsNearby',
  /** List of users nearby */
  users_nearby: Array<chatNearby>,
  /** List of location-based supergroups nearby */
  supergroups_nearby: Array<chatNearby>,
}

/** Represents a list of chats located nearby */
export type chatsNearby$Input = {
  readonly _: 'chatsNearby',
  /** List of users nearby */
  readonly users_nearby?: ReadonlyArray<chatNearby$Input>,
  /** List of location-based supergroups nearby */
  readonly supergroups_nearby?: ReadonlyArray<chatNearby$Input>,
}

/** The chat is public, because it has username */
export type publicChatTypeHasUsername = {
  _: 'publicChatTypeHasUsername',
}

/** The chat is public, because it has username */
export type publicChatTypeHasUsername$Input = {
  readonly _: 'publicChatTypeHasUsername',
}

/** The chat is public, because it is a location-based supergroup */
export type publicChatTypeIsLocationBased = {
  _: 'publicChatTypeIsLocationBased',
}

/** The chat is public, because it is a location-based supergroup */
export type publicChatTypeIsLocationBased$Input = {
  readonly _: 'publicChatTypeIsLocationBased',
}

/** The chat can be reported as spam using the method reportChat with the reason chatReportReasonSpam */
export type chatActionBarReportSpam = {
  _: 'chatActionBarReportSpam',
  /**
   * If true, the chat was automatically archived and can be moved back to the main chat
   * list using addChatToList simultaneously with setting chat notification settings to
   * default using setChatNotificationSettings
   */
  can_unarchive: boolean,
}

/** The chat can be reported as spam using the method reportChat with the reason chatReportReasonSpam */
export type chatActionBarReportSpam$Input = {
  readonly _: 'chatActionBarReportSpam',
  /**
   * If true, the chat was automatically archived and can be moved back to the main chat
   * list using addChatToList simultaneously with setting chat notification settings to
   * default using setChatNotificationSettings
   */
  readonly can_unarchive?: boolean,
}

/**
 * The chat is a location-based supergroup, which can be reported as having unrelated
 * location using the method reportChat with the reason chatReportReasonUnrelatedLocation
 */
export type chatActionBarReportUnrelatedLocation = {
  _: 'chatActionBarReportUnrelatedLocation',
}

/**
 * The chat is a location-based supergroup, which can be reported as having unrelated
 * location using the method reportChat with the reason chatReportReasonUnrelatedLocation
 */
export type chatActionBarReportUnrelatedLocation$Input = {
  readonly _: 'chatActionBarReportUnrelatedLocation',
}

/** The chat is a recently created group chat to which new members can be invited */
export type chatActionBarInviteMembers = {
  _: 'chatActionBarInviteMembers',
}

/** The chat is a recently created group chat to which new members can be invited */
export type chatActionBarInviteMembers$Input = {
  readonly _: 'chatActionBarInviteMembers',
}

/**
 * The chat is a private or secret chat, which can be reported using the method reportChat,
 * or the other user can be blocked using the method toggleMessageSenderIsBlocked, or
 * the other user can be added to the contact list using the method addContact
 */
export type chatActionBarReportAddBlock = {
  _: 'chatActionBarReportAddBlock',
  /**
   * If true, the chat was automatically archived and can be moved back to the main chat
   * list using addChatToList simultaneously with setting chat notification settings to
   * default using setChatNotificationSettings
   */
  can_unarchive: boolean,
  /**
   * If non-negative, the current user was found by the peer through searchChatsNearby
   * and this is the distance between the users
   */
  distance: number,
}

/**
 * The chat is a private or secret chat, which can be reported using the method reportChat,
 * or the other user can be blocked using the method toggleMessageSenderIsBlocked, or
 * the other user can be added to the contact list using the method addContact
 */
export type chatActionBarReportAddBlock$Input = {
  readonly _: 'chatActionBarReportAddBlock',
  /**
   * If true, the chat was automatically archived and can be moved back to the main chat
   * list using addChatToList simultaneously with setting chat notification settings to
   * default using setChatNotificationSettings
   */
  readonly can_unarchive?: boolean,
  /**
   * If non-negative, the current user was found by the peer through searchChatsNearby
   * and this is the distance between the users
   */
  readonly distance?: number,
}

/**
 * The chat is a private or secret chat and the other user can be added to the contact
 * list using the method addContact
 */
export type chatActionBarAddContact = {
  _: 'chatActionBarAddContact',
}

/**
 * The chat is a private or secret chat and the other user can be added to the contact
 * list using the method addContact
 */
export type chatActionBarAddContact$Input = {
  readonly _: 'chatActionBarAddContact',
}

/**
 * The chat is a private or secret chat with a mutual contact and the user's phone number
 * can be shared with the other user using the method sharePhoneNumber
 */
export type chatActionBarSharePhoneNumber = {
  _: 'chatActionBarSharePhoneNumber',
}

/**
 * The chat is a private or secret chat with a mutual contact and the user's phone number
 * can be shared with the other user using the method sharePhoneNumber
 */
export type chatActionBarSharePhoneNumber$Input = {
  readonly _: 'chatActionBarSharePhoneNumber',
}

/**
 * The chat is a private chat with an administrator of a chat to which the user sent
 * join request
 */
export type chatActionBarJoinRequest = {
  _: 'chatActionBarJoinRequest',
  /** Title of the chat to which the join request was sent */
  title: string,
  /** True, if the join request was sent to a channel chat */
  is_channel: boolean,
  /** Point in time (Unix timestamp) when the join request was sent */
  request_date: number,
}

/**
 * The chat is a private chat with an administrator of a chat to which the user sent
 * join request
 */
export type chatActionBarJoinRequest$Input = {
  readonly _: 'chatActionBarJoinRequest',
  /** Title of the chat to which the join request was sent */
  readonly title?: string,
  /** True, if the join request was sent to a channel chat */
  readonly is_channel?: boolean,
  /** Point in time (Unix timestamp) when the join request was sent */
  readonly request_date?: number,
}

/** A simple button, with text that must be sent when the button is pressed */
export type keyboardButtonTypeText = {
  _: 'keyboardButtonTypeText',
}

/** A simple button, with text that must be sent when the button is pressed */
export type keyboardButtonTypeText$Input = {
  readonly _: 'keyboardButtonTypeText',
}

/**
 * A button that sends the user's phone number when pressed; available only in private
 * chats
 */
export type keyboardButtonTypeRequestPhoneNumber = {
  _: 'keyboardButtonTypeRequestPhoneNumber',
}

/**
 * A button that sends the user's phone number when pressed; available only in private
 * chats
 */
export type keyboardButtonTypeRequestPhoneNumber$Input = {
  readonly _: 'keyboardButtonTypeRequestPhoneNumber',
}

/** A button that sends the user's location when pressed; available only in private chats */
export type keyboardButtonTypeRequestLocation = {
  _: 'keyboardButtonTypeRequestLocation',
}

/** A button that sends the user's location when pressed; available only in private chats */
export type keyboardButtonTypeRequestLocation$Input = {
  readonly _: 'keyboardButtonTypeRequestLocation',
}

/**
 * A button that allows the user to create and send a poll when pressed; available only
 * in private chats
 */
export type keyboardButtonTypeRequestPoll = {
  _: 'keyboardButtonTypeRequestPoll',
  /** If true, only regular polls must be allowed to create */
  force_regular: boolean,
  /** If true, only polls in quiz mode must be allowed to create */
  force_quiz: boolean,
}

/**
 * A button that allows the user to create and send a poll when pressed; available only
 * in private chats
 */
export type keyboardButtonTypeRequestPoll$Input = {
  readonly _: 'keyboardButtonTypeRequestPoll',
  /** If true, only regular polls must be allowed to create */
  readonly force_regular?: boolean,
  /** If true, only polls in quiz mode must be allowed to create */
  readonly force_quiz?: boolean,
}

/** Represents a single button in a bot keyboard */
export type keyboardButton = {
  _: 'keyboardButton',
  /** Text of the button */
  text: string,
  /** Type of the button */
  type: KeyboardButtonType,
}

/** Represents a single button in a bot keyboard */
export type keyboardButton$Input = {
  readonly _: 'keyboardButton',
  /** Text of the button */
  readonly text?: string,
  /** Type of the button */
  readonly type?: KeyboardButtonType$Input,
}

/** A button that opens a specified URL */
export type inlineKeyboardButtonTypeUrl = {
  _: 'inlineKeyboardButtonTypeUrl',
  /** HTTP or tg:// URL to open */
  url: string,
}

/** A button that opens a specified URL */
export type inlineKeyboardButtonTypeUrl$Input = {
  readonly _: 'inlineKeyboardButtonTypeUrl',
  /** HTTP or tg:// URL to open */
  readonly url?: string,
}

/**
 * A button that opens a specified URL and automatically authorize the current user
 * if allowed to do so
 */
export type inlineKeyboardButtonTypeLoginUrl = {
  _: 'inlineKeyboardButtonTypeLoginUrl',
  /** An HTTP URL to open */
  url: string,
  /** Unique button identifier */
  id: number,
  /** If non-empty, new text of the button in forwarded messages */
  forward_text: string,
}

/**
 * A button that opens a specified URL and automatically authorize the current user
 * if allowed to do so
 */
export type inlineKeyboardButtonTypeLoginUrl$Input = {
  readonly _: 'inlineKeyboardButtonTypeLoginUrl',
  /** An HTTP URL to open */
  readonly url?: string,
  /** Unique button identifier */
  readonly id?: number,
  /** If non-empty, new text of the button in forwarded messages */
  readonly forward_text?: string,
}

/** A button that sends a callback query to a bot */
export type inlineKeyboardButtonTypeCallback = {
  _: 'inlineKeyboardButtonTypeCallback',
  /** Data to be sent to the bot via a callback query */
  data: string,
}

/** A button that sends a callback query to a bot */
export type inlineKeyboardButtonTypeCallback$Input = {
  readonly _: 'inlineKeyboardButtonTypeCallback',
  /** Data to be sent to the bot via a callback query */
  readonly data?: string,
}

/**
 * A button that asks for password of the current user and then sends a callback query
 * to a bot
 */
export type inlineKeyboardButtonTypeCallbackWithPassword = {
  _: 'inlineKeyboardButtonTypeCallbackWithPassword',
  /** Data to be sent to the bot via a callback query */
  data: string,
}

/**
 * A button that asks for password of the current user and then sends a callback query
 * to a bot
 */
export type inlineKeyboardButtonTypeCallbackWithPassword$Input = {
  readonly _: 'inlineKeyboardButtonTypeCallbackWithPassword',
  /** Data to be sent to the bot via a callback query */
  readonly data?: string,
}

/**
 * A button with a game that sends a callback query to a bot. This button must be in
 * the first column and row of the keyboard and can be attached only to a message with
 * content of the type messageGame
 */
export type inlineKeyboardButtonTypeCallbackGame = {
  _: 'inlineKeyboardButtonTypeCallbackGame',
}

/**
 * A button with a game that sends a callback query to a bot. This button must be in
 * the first column and row of the keyboard and can be attached only to a message with
 * content of the type messageGame
 */
export type inlineKeyboardButtonTypeCallbackGame$Input = {
  readonly _: 'inlineKeyboardButtonTypeCallbackGame',
}

/** A button that forces an inline query to the bot to be inserted in the input field */
export type inlineKeyboardButtonTypeSwitchInline = {
  _: 'inlineKeyboardButtonTypeSwitchInline',
  /** Inline query to be sent to the bot */
  query: string,
  /** True, if the inline query must be sent from the current chat */
  in_current_chat: boolean,
}

/** A button that forces an inline query to the bot to be inserted in the input field */
export type inlineKeyboardButtonTypeSwitchInline$Input = {
  readonly _: 'inlineKeyboardButtonTypeSwitchInline',
  /** Inline query to be sent to the bot */
  readonly query?: string,
  /** True, if the inline query must be sent from the current chat */
  readonly in_current_chat?: boolean,
}

/**
 * A button to buy something. This button must be in the first column and row of the
 * keyboard and can be attached only to a message with content of the type messageInvoice
 */
export type inlineKeyboardButtonTypeBuy = {
  _: 'inlineKeyboardButtonTypeBuy',
}

/**
 * A button to buy something. This button must be in the first column and row of the
 * keyboard and can be attached only to a message with content of the type messageInvoice
 */
export type inlineKeyboardButtonTypeBuy$Input = {
  readonly _: 'inlineKeyboardButtonTypeBuy',
}

/**
 * A button with a user reference to be handled in the same way as textEntityTypeMentionName
 * entities
 */
export type inlineKeyboardButtonTypeUser = {
  _: 'inlineKeyboardButtonTypeUser',
  /** User identifier */
  user_id: number,
}

/**
 * A button with a user reference to be handled in the same way as textEntityTypeMentionName
 * entities
 */
export type inlineKeyboardButtonTypeUser$Input = {
  readonly _: 'inlineKeyboardButtonTypeUser',
  /** User identifier */
  readonly user_id?: number,
}

/** Represents a single button in an inline keyboard */
export type inlineKeyboardButton = {
  _: 'inlineKeyboardButton',
  /** Text of the button */
  text: string,
  /** Type of the button */
  type: InlineKeyboardButtonType,
}

/** Represents a single button in an inline keyboard */
export type inlineKeyboardButton$Input = {
  readonly _: 'inlineKeyboardButton',
  /** Text of the button */
  readonly text?: string,
  /** Type of the button */
  readonly type?: InlineKeyboardButtonType$Input,
}

/**
 * Instructs application to remove the keyboard once this message has been received.
 * This kind of keyboard can't be received in an incoming message; instead, UpdateChatReplyMarkup
 * with message_id == 0 will be sent
 */
export type replyMarkupRemoveKeyboard = {
  _: 'replyMarkupRemoveKeyboard',
  /**
   * True, if the keyboard is removed only for the mentioned users or the target user
   * of a reply
   */
  is_personal: boolean,
}

/**
 * Instructs application to remove the keyboard once this message has been received.
 * This kind of keyboard can't be received in an incoming message; instead, UpdateChatReplyMarkup
 * with message_id == 0 will be sent
 */
export type replyMarkupRemoveKeyboard$Input = {
  readonly _: 'replyMarkupRemoveKeyboard',
  /**
   * True, if the keyboard is removed only for the mentioned users or the target user
   * of a reply
   */
  readonly is_personal?: boolean,
}

/** Instructs application to force a reply to this message */
export type replyMarkupForceReply = {
  _: 'replyMarkupForceReply',
  /**
   * True, if a forced reply must automatically be shown to the current user. For outgoing
   * messages, specify true to show the forced reply only for the mentioned users and
   * for the target user of a reply
   */
  is_personal: boolean,
  /**
   * If non-empty, the placeholder to be shown in the input field when the reply is active;
   * 0-64 characters
   */
  input_field_placeholder: string,
}

/** Instructs application to force a reply to this message */
export type replyMarkupForceReply$Input = {
  readonly _: 'replyMarkupForceReply',
  /**
   * True, if a forced reply must automatically be shown to the current user. For outgoing
   * messages, specify true to show the forced reply only for the mentioned users and
   * for the target user of a reply
   */
  readonly is_personal?: boolean,
  /**
   * If non-empty, the placeholder to be shown in the input field when the reply is active;
   * 0-64 characters
   */
  readonly input_field_placeholder?: string,
}

/** Contains a custom keyboard layout to quickly reply to bots */
export type replyMarkupShowKeyboard = {
  _: 'replyMarkupShowKeyboard',
  /** A list of rows of bot keyboard buttons */
  rows: Array<Array<keyboardButton>>,
  /** True, if the application needs to resize the keyboard vertically */
  resize_keyboard: boolean,
  /** True, if the application needs to hide the keyboard after use */
  one_time: boolean,
  /**
   * True, if the keyboard must automatically be shown to the current user. For outgoing
   * messages, specify true to show the keyboard only for the mentioned users and for
   * the target user of a reply
   */
  is_personal: boolean,
  /**
   * If non-empty, the placeholder to be shown in the input field when the keyboard is
   * active; 0-64 characters
   */
  input_field_placeholder: string,
}

/** Contains a custom keyboard layout to quickly reply to bots */
export type replyMarkupShowKeyboard$Input = {
  readonly _: 'replyMarkupShowKeyboard',
  /** A list of rows of bot keyboard buttons */
  readonly rows?: ReadonlyArray<ReadonlyArray<keyboardButton$Input>>,
  /** True, if the application needs to resize the keyboard vertically */
  readonly resize_keyboard?: boolean,
  /** True, if the application needs to hide the keyboard after use */
  readonly one_time?: boolean,
  /**
   * True, if the keyboard must automatically be shown to the current user. For outgoing
   * messages, specify true to show the keyboard only for the mentioned users and for
   * the target user of a reply
   */
  readonly is_personal?: boolean,
  /**
   * If non-empty, the placeholder to be shown in the input field when the keyboard is
   * active; 0-64 characters
   */
  readonly input_field_placeholder?: string,
}

/** Contains an inline keyboard layout */
export type replyMarkupInlineKeyboard = {
  _: 'replyMarkupInlineKeyboard',
  /** A list of rows of inline keyboard buttons */
  rows: Array<Array<inlineKeyboardButton>>,
}

/** Contains an inline keyboard layout */
export type replyMarkupInlineKeyboard$Input = {
  readonly _: 'replyMarkupInlineKeyboard',
  /** A list of rows of inline keyboard buttons */
  readonly rows?: ReadonlyArray<ReadonlyArray<inlineKeyboardButton$Input>>,
}

/** An HTTP url needs to be open */
export type loginUrlInfoOpen = {
  _: 'loginUrlInfoOpen',
  /** The URL to open */
  url: string,
  /** True, if there is no need to show an ordinary open URL confirm */
  skip_confirm: boolean,
}

/** An HTTP url needs to be open */
export type loginUrlInfoOpen$Input = {
  readonly _: 'loginUrlInfoOpen',
  /** The URL to open */
  readonly url?: string,
  /** True, if there is no need to show an ordinary open URL confirm */
  readonly skip_confirm?: boolean,
}

/** An authorization confirmation dialog needs to be shown to the user */
export type loginUrlInfoRequestConfirmation = {
  _: 'loginUrlInfoRequestConfirmation',
  /** An HTTP URL to be opened */
  url: string,
  /** A domain of the URL */
  domain: string,
  /** User identifier of a bot linked with the website */
  bot_user_id: number,
  /**
   * True, if the user needs to be requested to give the permission to the bot to send
   * them messages
   */
  request_write_access: boolean,
}

/** An authorization confirmation dialog needs to be shown to the user */
export type loginUrlInfoRequestConfirmation$Input = {
  readonly _: 'loginUrlInfoRequestConfirmation',
  /** An HTTP URL to be opened */
  readonly url?: string,
  /** A domain of the URL */
  readonly domain?: string,
  /** User identifier of a bot linked with the website */
  readonly bot_user_id?: number,
  /**
   * True, if the user needs to be requested to give the permission to the bot to send
   * them messages
   */
  readonly request_write_access?: boolean,
}

/** Contains information about a message thread */
export type messageThreadInfo = {
  _: 'messageThreadInfo',
  /** Identifier of the chat to which the message thread belongs */
  chat_id: number,
  /** Message thread identifier, unique within the chat */
  message_thread_id: number,
  /** Information about the message thread */
  reply_info: messageReplyInfo,
  /** Approximate number of unread messages in the message thread */
  unread_message_count: number,
  /**
   * The messages from which the thread starts. The messages are returned in a reverse
   * chronological order (i.e., in order of decreasing message_id)
   */
  messages: Array<message>,
  /** A draft of a message in the message thread; may be null */
  draft_message: draftMessage | undefined,
}

/** Contains information about a message thread */
export type messageThreadInfo$Input = {
  readonly _: 'messageThreadInfo',
  /** Identifier of the chat to which the message thread belongs */
  readonly chat_id?: number,
  /** Message thread identifier, unique within the chat */
  readonly message_thread_id?: number,
  /** Information about the message thread */
  readonly reply_info?: messageReplyInfo$Input,
  /** Approximate number of unread messages in the message thread */
  readonly unread_message_count?: number,
  /**
   * The messages from which the thread starts. The messages are returned in a reverse
   * chronological order (i.e., in order of decreasing message_id)
   */
  readonly messages?: ReadonlyArray<message$Input>,
  /** A draft of a message in the message thread; may be null */
  readonly draft_message?: draftMessage$Input | undefined,
}

/** A plain text */
export type richTextPlain = {
  _: 'richTextPlain',
  /** Text */
  text: string,
}

/** A plain text */
export type richTextPlain$Input = {
  readonly _: 'richTextPlain',
  /** Text */
  readonly text?: string,
}

/** A bold rich text */
export type richTextBold = {
  _: 'richTextBold',
  /** Text */
  text: RichText,
}

/** A bold rich text */
export type richTextBold$Input = {
  readonly _: 'richTextBold',
  /** Text */
  readonly text?: RichText$Input,
}

/** An italicized rich text */
export type richTextItalic = {
  _: 'richTextItalic',
  /** Text */
  text: RichText,
}

/** An italicized rich text */
export type richTextItalic$Input = {
  readonly _: 'richTextItalic',
  /** Text */
  readonly text?: RichText$Input,
}

/** An underlined rich text */
export type richTextUnderline = {
  _: 'richTextUnderline',
  /** Text */
  text: RichText,
}

/** An underlined rich text */
export type richTextUnderline$Input = {
  readonly _: 'richTextUnderline',
  /** Text */
  readonly text?: RichText$Input,
}

/** A strikethrough rich text */
export type richTextStrikethrough = {
  _: 'richTextStrikethrough',
  /** Text */
  text: RichText,
}

/** A strikethrough rich text */
export type richTextStrikethrough$Input = {
  readonly _: 'richTextStrikethrough',
  /** Text */
  readonly text?: RichText$Input,
}

/** A fixed-width rich text */
export type richTextFixed = {
  _: 'richTextFixed',
  /** Text */
  text: RichText,
}

/** A fixed-width rich text */
export type richTextFixed$Input = {
  readonly _: 'richTextFixed',
  /** Text */
  readonly text?: RichText$Input,
}

/** A rich text URL link */
export type richTextUrl = {
  _: 'richTextUrl',
  /** Text */
  text: RichText,
  /** URL */
  url: string,
  /** True, if the URL has cached instant view server-side */
  is_cached: boolean,
}

/** A rich text URL link */
export type richTextUrl$Input = {
  readonly _: 'richTextUrl',
  /** Text */
  readonly text?: RichText$Input,
  /** URL */
  readonly url?: string,
  /** True, if the URL has cached instant view server-side */
  readonly is_cached?: boolean,
}

/** A rich text email link */
export type richTextEmailAddress = {
  _: 'richTextEmailAddress',
  /** Text */
  text: RichText,
  /** Email address */
  email_address: string,
}

/** A rich text email link */
export type richTextEmailAddress$Input = {
  readonly _: 'richTextEmailAddress',
  /** Text */
  readonly text?: RichText$Input,
  /** Email address */
  readonly email_address?: string,
}

/** A subscript rich text */
export type richTextSubscript = {
  _: 'richTextSubscript',
  /** Text */
  text: RichText,
}

/** A subscript rich text */
export type richTextSubscript$Input = {
  readonly _: 'richTextSubscript',
  /** Text */
  readonly text?: RichText$Input,
}

/** A superscript rich text */
export type richTextSuperscript = {
  _: 'richTextSuperscript',
  /** Text */
  text: RichText,
}

/** A superscript rich text */
export type richTextSuperscript$Input = {
  readonly _: 'richTextSuperscript',
  /** Text */
  readonly text?: RichText$Input,
}

/** A marked rich text */
export type richTextMarked = {
  _: 'richTextMarked',
  /** Text */
  text: RichText,
}

/** A marked rich text */
export type richTextMarked$Input = {
  readonly _: 'richTextMarked',
  /** Text */
  readonly text?: RichText$Input,
}

/** A rich text phone number */
export type richTextPhoneNumber = {
  _: 'richTextPhoneNumber',
  /** Text */
  text: RichText,
  /** Phone number */
  phone_number: string,
}

/** A rich text phone number */
export type richTextPhoneNumber$Input = {
  readonly _: 'richTextPhoneNumber',
  /** Text */
  readonly text?: RichText$Input,
  /** Phone number */
  readonly phone_number?: string,
}

/** A small image inside the text */
export type richTextIcon = {
  _: 'richTextIcon',
  /** The image represented as a document. The image can be in GIF, JPEG or PNG format */
  document: document,
  /** Width of a bounding box in which the image must be shown; 0 if unknown */
  width: number,
  /** Height of a bounding box in which the image must be shown; 0 if unknown */
  height: number,
}

/** A small image inside the text */
export type richTextIcon$Input = {
  readonly _: 'richTextIcon',
  /** The image represented as a document. The image can be in GIF, JPEG or PNG format */
  readonly document?: document$Input,
  /** Width of a bounding box in which the image must be shown; 0 if unknown */
  readonly width?: number,
  /** Height of a bounding box in which the image must be shown; 0 if unknown */
  readonly height?: number,
}

/** A reference to a richTexts object on the same web page */
export type richTextReference = {
  _: 'richTextReference',
  /** The text */
  text: RichText,
  /**
   * The name of a richTextAnchor object, which is the first element of the target richTexts
   * object
   */
  anchor_name: string,
  /** An HTTP URL, opening the reference */
  url: string,
}

/** A reference to a richTexts object on the same web page */
export type richTextReference$Input = {
  readonly _: 'richTextReference',
  /** The text */
  readonly text?: RichText$Input,
  /**
   * The name of a richTextAnchor object, which is the first element of the target richTexts
   * object
   */
  readonly anchor_name?: string,
  /** An HTTP URL, opening the reference */
  readonly url?: string,
}

/** An anchor */
export type richTextAnchor = {
  _: 'richTextAnchor',
  /** Anchor name */
  name: string,
}

/** An anchor */
export type richTextAnchor$Input = {
  readonly _: 'richTextAnchor',
  /** Anchor name */
  readonly name?: string,
}

/** A link to an anchor on the same web page */
export type richTextAnchorLink = {
  _: 'richTextAnchorLink',
  /** The link text */
  text: RichText,
  /** The anchor name. If the name is empty, the link must bring back to top */
  anchor_name: string,
  /** An HTTP URL, opening the anchor */
  url: string,
}

/** A link to an anchor on the same web page */
export type richTextAnchorLink$Input = {
  readonly _: 'richTextAnchorLink',
  /** The link text */
  readonly text?: RichText$Input,
  /** The anchor name. If the name is empty, the link must bring back to top */
  readonly anchor_name?: string,
  /** An HTTP URL, opening the anchor */
  readonly url?: string,
}

/** A concatenation of rich texts */
export type richTexts = {
  _: 'richTexts',
  /** Texts */
  texts: Array<RichText>,
}

/** A concatenation of rich texts */
export type richTexts$Input = {
  readonly _: 'richTexts',
  /** Texts */
  readonly texts?: ReadonlyArray<RichText$Input>,
}

/**
 * Contains a caption of an instant view web page block, consisting of a text and a
 * trailing credit
 */
export type pageBlockCaption = {
  _: 'pageBlockCaption',
  /** Content of the caption */
  text: RichText,
  /** Block credit (like HTML tag <cite>) */
  credit: RichText,
}

/**
 * Contains a caption of an instant view web page block, consisting of a text and a
 * trailing credit
 */
export type pageBlockCaption$Input = {
  readonly _: 'pageBlockCaption',
  /** Content of the caption */
  readonly text?: RichText$Input,
  /** Block credit (like HTML tag <cite>) */
  readonly credit?: RichText$Input,
}

/** Describes an item of a list page block */
export type pageBlockListItem = {
  _: 'pageBlockListItem',
  /** Item label */
  label: string,
  /** Item blocks */
  page_blocks: Array<PageBlock>,
}

/** Describes an item of a list page block */
export type pageBlockListItem$Input = {
  readonly _: 'pageBlockListItem',
  /** Item label */
  readonly label?: string,
  /** Item blocks */
  readonly page_blocks?: ReadonlyArray<PageBlock$Input>,
}

/** The content must be left-aligned */
export type pageBlockHorizontalAlignmentLeft = {
  _: 'pageBlockHorizontalAlignmentLeft',
}

/** The content must be left-aligned */
export type pageBlockHorizontalAlignmentLeft$Input = {
  readonly _: 'pageBlockHorizontalAlignmentLeft',
}

/** The content must be center-aligned */
export type pageBlockHorizontalAlignmentCenter = {
  _: 'pageBlockHorizontalAlignmentCenter',
}

/** The content must be center-aligned */
export type pageBlockHorizontalAlignmentCenter$Input = {
  readonly _: 'pageBlockHorizontalAlignmentCenter',
}

/** The content must be right-aligned */
export type pageBlockHorizontalAlignmentRight = {
  _: 'pageBlockHorizontalAlignmentRight',
}

/** The content must be right-aligned */
export type pageBlockHorizontalAlignmentRight$Input = {
  readonly _: 'pageBlockHorizontalAlignmentRight',
}

/** The content must be top-aligned */
export type pageBlockVerticalAlignmentTop = {
  _: 'pageBlockVerticalAlignmentTop',
}

/** The content must be top-aligned */
export type pageBlockVerticalAlignmentTop$Input = {
  readonly _: 'pageBlockVerticalAlignmentTop',
}

/** The content must be middle-aligned */
export type pageBlockVerticalAlignmentMiddle = {
  _: 'pageBlockVerticalAlignmentMiddle',
}

/** The content must be middle-aligned */
export type pageBlockVerticalAlignmentMiddle$Input = {
  readonly _: 'pageBlockVerticalAlignmentMiddle',
}

/** The content must be bottom-aligned */
export type pageBlockVerticalAlignmentBottom = {
  _: 'pageBlockVerticalAlignmentBottom',
}

/** The content must be bottom-aligned */
export type pageBlockVerticalAlignmentBottom$Input = {
  readonly _: 'pageBlockVerticalAlignmentBottom',
}

/** Represents a cell of a table */
export type pageBlockTableCell = {
  _: 'pageBlockTableCell',
  /** Cell text; may be null. If the text is null, then the cell must be invisible */
  text: RichText | undefined,
  /** True, if it is a header cell */
  is_header: boolean,
  /** The number of columns the cell spans */
  colspan: number,
  /** The number of rows the cell spans */
  rowspan: number,
  /** Horizontal cell content alignment */
  align: PageBlockHorizontalAlignment,
  /** Vertical cell content alignment */
  valign: PageBlockVerticalAlignment,
}

/** Represents a cell of a table */
export type pageBlockTableCell$Input = {
  readonly _: 'pageBlockTableCell',
  /** Cell text; may be null. If the text is null, then the cell must be invisible */
  readonly text?: RichText$Input | undefined,
  /** True, if it is a header cell */
  readonly is_header?: boolean,
  /** The number of columns the cell spans */
  readonly colspan?: number,
  /** The number of rows the cell spans */
  readonly rowspan?: number,
  /** Horizontal cell content alignment */
  readonly align?: PageBlockHorizontalAlignment$Input,
  /** Vertical cell content alignment */
  readonly valign?: PageBlockVerticalAlignment$Input,
}

/** Contains information about a related article */
export type pageBlockRelatedArticle = {
  _: 'pageBlockRelatedArticle',
  /** Related article URL */
  url: string,
  /** Article title; may be empty */
  title: string,
  /** Article description; may be empty */
  description: string,
  /** Article photo; may be null */
  photo: photo | undefined,
  /** Article author; may be empty */
  author: string,
  /** Point in time (Unix timestamp) when the article was published; 0 if unknown */
  publish_date: number,
}

/** Contains information about a related article */
export type pageBlockRelatedArticle$Input = {
  readonly _: 'pageBlockRelatedArticle',
  /** Related article URL */
  readonly url?: string,
  /** Article title; may be empty */
  readonly title?: string,
  /** Article description; may be empty */
  readonly description?: string,
  /** Article photo; may be null */
  readonly photo?: photo$Input | undefined,
  /** Article author; may be empty */
  readonly author?: string,
  /** Point in time (Unix timestamp) when the article was published; 0 if unknown */
  readonly publish_date?: number,
}

/** The title of a page */
export type pageBlockTitle = {
  _: 'pageBlockTitle',
  /** Title */
  title: RichText,
}

/** The title of a page */
export type pageBlockTitle$Input = {
  readonly _: 'pageBlockTitle',
  /** Title */
  readonly title?: RichText$Input,
}

/** The subtitle of a page */
export type pageBlockSubtitle = {
  _: 'pageBlockSubtitle',
  /** Subtitle */
  subtitle: RichText,
}

/** The subtitle of a page */
export type pageBlockSubtitle$Input = {
  readonly _: 'pageBlockSubtitle',
  /** Subtitle */
  readonly subtitle?: RichText$Input,
}

/** The author and publishing date of a page */
export type pageBlockAuthorDate = {
  _: 'pageBlockAuthorDate',
  /** Author */
  author: RichText,
  /** Point in time (Unix timestamp) when the article was published; 0 if unknown */
  publish_date: number,
}

/** The author and publishing date of a page */
export type pageBlockAuthorDate$Input = {
  readonly _: 'pageBlockAuthorDate',
  /** Author */
  readonly author?: RichText$Input,
  /** Point in time (Unix timestamp) when the article was published; 0 if unknown */
  readonly publish_date?: number,
}

/** A header */
export type pageBlockHeader = {
  _: 'pageBlockHeader',
  /** Header */
  header: RichText,
}

/** A header */
export type pageBlockHeader$Input = {
  readonly _: 'pageBlockHeader',
  /** Header */
  readonly header?: RichText$Input,
}

/** A subheader */
export type pageBlockSubheader = {
  _: 'pageBlockSubheader',
  /** Subheader */
  subheader: RichText,
}

/** A subheader */
export type pageBlockSubheader$Input = {
  readonly _: 'pageBlockSubheader',
  /** Subheader */
  readonly subheader?: RichText$Input,
}

/** A kicker */
export type pageBlockKicker = {
  _: 'pageBlockKicker',
  /** Kicker */
  kicker: RichText,
}

/** A kicker */
export type pageBlockKicker$Input = {
  readonly _: 'pageBlockKicker',
  /** Kicker */
  readonly kicker?: RichText$Input,
}

/** A text paragraph */
export type pageBlockParagraph = {
  _: 'pageBlockParagraph',
  /** Paragraph text */
  text: RichText,
}

/** A text paragraph */
export type pageBlockParagraph$Input = {
  readonly _: 'pageBlockParagraph',
  /** Paragraph text */
  readonly text?: RichText$Input,
}

/** A preformatted text paragraph */
export type pageBlockPreformatted = {
  _: 'pageBlockPreformatted',
  /** Paragraph text */
  text: RichText,
  /** Programming language for which the text needs to be formatted */
  language: string,
}

/** A preformatted text paragraph */
export type pageBlockPreformatted$Input = {
  readonly _: 'pageBlockPreformatted',
  /** Paragraph text */
  readonly text?: RichText$Input,
  /** Programming language for which the text needs to be formatted */
  readonly language?: string,
}

/** The footer of a page */
export type pageBlockFooter = {
  _: 'pageBlockFooter',
  /** Footer */
  footer: RichText,
}

/** The footer of a page */
export type pageBlockFooter$Input = {
  readonly _: 'pageBlockFooter',
  /** Footer */
  readonly footer?: RichText$Input,
}

/** An empty block separating a page */
export type pageBlockDivider = {
  _: 'pageBlockDivider',
}

/** An empty block separating a page */
export type pageBlockDivider$Input = {
  readonly _: 'pageBlockDivider',
}

/**
 * An invisible anchor on a page, which can be used in a URL to open the page from the
 * specified anchor
 */
export type pageBlockAnchor = {
  _: 'pageBlockAnchor',
  /** Name of the anchor */
  name: string,
}

/**
 * An invisible anchor on a page, which can be used in a URL to open the page from the
 * specified anchor
 */
export type pageBlockAnchor$Input = {
  readonly _: 'pageBlockAnchor',
  /** Name of the anchor */
  readonly name?: string,
}

/** A list of data blocks */
export type pageBlockList = {
  _: 'pageBlockList',
  /** The items of the list */
  items: Array<pageBlockListItem>,
}

/** A list of data blocks */
export type pageBlockList$Input = {
  readonly _: 'pageBlockList',
  /** The items of the list */
  readonly items?: ReadonlyArray<pageBlockListItem$Input>,
}

/** A block quote */
export type pageBlockBlockQuote = {
  _: 'pageBlockBlockQuote',
  /** Quote text */
  text: RichText,
  /** Quote credit */
  credit: RichText,
}

/** A block quote */
export type pageBlockBlockQuote$Input = {
  readonly _: 'pageBlockBlockQuote',
  /** Quote text */
  readonly text?: RichText$Input,
  /** Quote credit */
  readonly credit?: RichText$Input,
}

/** A pull quote */
export type pageBlockPullQuote = {
  _: 'pageBlockPullQuote',
  /** Quote text */
  text: RichText,
  /** Quote credit */
  credit: RichText,
}

/** A pull quote */
export type pageBlockPullQuote$Input = {
  readonly _: 'pageBlockPullQuote',
  /** Quote text */
  readonly text?: RichText$Input,
  /** Quote credit */
  readonly credit?: RichText$Input,
}

/** An animation */
export type pageBlockAnimation = {
  _: 'pageBlockAnimation',
  /** Animation file; may be null */
  animation: animation | undefined,
  /** Animation caption */
  caption: pageBlockCaption,
  /** True, if the animation must be played automatically */
  need_autoplay: boolean,
}

/** An animation */
export type pageBlockAnimation$Input = {
  readonly _: 'pageBlockAnimation',
  /** Animation file; may be null */
  readonly animation?: animation$Input | undefined,
  /** Animation caption */
  readonly caption?: pageBlockCaption$Input,
  /** True, if the animation must be played automatically */
  readonly need_autoplay?: boolean,
}

/** An audio file */
export type pageBlockAudio = {
  _: 'pageBlockAudio',
  /** Audio file; may be null */
  audio: audio | undefined,
  /** Audio file caption */
  caption: pageBlockCaption,
}

/** An audio file */
export type pageBlockAudio$Input = {
  readonly _: 'pageBlockAudio',
  /** Audio file; may be null */
  readonly audio?: audio$Input | undefined,
  /** Audio file caption */
  readonly caption?: pageBlockCaption$Input,
}

/** A photo */
export type pageBlockPhoto = {
  _: 'pageBlockPhoto',
  /** Photo file; may be null */
  photo: photo | undefined,
  /** Photo caption */
  caption: pageBlockCaption,
  /** URL that needs to be opened when the photo is clicked */
  url: string,
}

/** A photo */
export type pageBlockPhoto$Input = {
  readonly _: 'pageBlockPhoto',
  /** Photo file; may be null */
  readonly photo?: photo$Input | undefined,
  /** Photo caption */
  readonly caption?: pageBlockCaption$Input,
  /** URL that needs to be opened when the photo is clicked */
  readonly url?: string,
}

/** A video */
export type pageBlockVideo = {
  _: 'pageBlockVideo',
  /** Video file; may be null */
  video: video | undefined,
  /** Video caption */
  caption: pageBlockCaption,
  /** True, if the video must be played automatically */
  need_autoplay: boolean,
  /** True, if the video must be looped */
  is_looped: boolean,
}

/** A video */
export type pageBlockVideo$Input = {
  readonly _: 'pageBlockVideo',
  /** Video file; may be null */
  readonly video?: video$Input | undefined,
  /** Video caption */
  readonly caption?: pageBlockCaption$Input,
  /** True, if the video must be played automatically */
  readonly need_autoplay?: boolean,
  /** True, if the video must be looped */
  readonly is_looped?: boolean,
}

/** A voice note */
export type pageBlockVoiceNote = {
  _: 'pageBlockVoiceNote',
  /** Voice note; may be null */
  voice_note: voiceNote | undefined,
  /** Voice note caption */
  caption: pageBlockCaption,
}

/** A voice note */
export type pageBlockVoiceNote$Input = {
  readonly _: 'pageBlockVoiceNote',
  /** Voice note; may be null */
  readonly voice_note?: voiceNote$Input | undefined,
  /** Voice note caption */
  readonly caption?: pageBlockCaption$Input,
}

/** A page cover */
export type pageBlockCover = {
  _: 'pageBlockCover',
  /** Cover */
  cover: PageBlock,
}

/** A page cover */
export type pageBlockCover$Input = {
  readonly _: 'pageBlockCover',
  /** Cover */
  readonly cover?: PageBlock$Input,
}

/** An embedded web page */
export type pageBlockEmbedded = {
  _: 'pageBlockEmbedded',
  /** Web page URL, if available */
  url: string,
  /** HTML-markup of the embedded page */
  html: string,
  /** Poster photo, if available; may be null */
  poster_photo: photo | undefined,
  /** Block width; 0 if unknown */
  width: number,
  /** Block height; 0 if unknown */
  height: number,
  /** Block caption */
  caption: pageBlockCaption,
  /** True, if the block must be full width */
  is_full_width: boolean,
  /** True, if scrolling needs to be allowed */
  allow_scrolling: boolean,
}

/** An embedded web page */
export type pageBlockEmbedded$Input = {
  readonly _: 'pageBlockEmbedded',
  /** Web page URL, if available */
  readonly url?: string,
  /** HTML-markup of the embedded page */
  readonly html?: string,
  /** Poster photo, if available; may be null */
  readonly poster_photo?: photo$Input | undefined,
  /** Block width; 0 if unknown */
  readonly width?: number,
  /** Block height; 0 if unknown */
  readonly height?: number,
  /** Block caption */
  readonly caption?: pageBlockCaption$Input,
  /** True, if the block must be full width */
  readonly is_full_width?: boolean,
  /** True, if scrolling needs to be allowed */
  readonly allow_scrolling?: boolean,
}

/** An embedded post */
export type pageBlockEmbeddedPost = {
  _: 'pageBlockEmbeddedPost',
  /** Web page URL */
  url: string,
  /** Post author */
  author: string,
  /** Post author photo; may be null */
  author_photo: photo | undefined,
  /** Point in time (Unix timestamp) when the post was created; 0 if unknown */
  date: number,
  /** Post content */
  page_blocks: Array<PageBlock>,
  /** Post caption */
  caption: pageBlockCaption,
}

/** An embedded post */
export type pageBlockEmbeddedPost$Input = {
  readonly _: 'pageBlockEmbeddedPost',
  /** Web page URL */
  readonly url?: string,
  /** Post author */
  readonly author?: string,
  /** Post author photo; may be null */
  readonly author_photo?: photo$Input | undefined,
  /** Point in time (Unix timestamp) when the post was created; 0 if unknown */
  readonly date?: number,
  /** Post content */
  readonly page_blocks?: ReadonlyArray<PageBlock$Input>,
  /** Post caption */
  readonly caption?: pageBlockCaption$Input,
}

/** A collage */
export type pageBlockCollage = {
  _: 'pageBlockCollage',
  /** Collage item contents */
  page_blocks: Array<PageBlock>,
  /** Block caption */
  caption: pageBlockCaption,
}

/** A collage */
export type pageBlockCollage$Input = {
  readonly _: 'pageBlockCollage',
  /** Collage item contents */
  readonly page_blocks?: ReadonlyArray<PageBlock$Input>,
  /** Block caption */
  readonly caption?: pageBlockCaption$Input,
}

/** A slideshow */
export type pageBlockSlideshow = {
  _: 'pageBlockSlideshow',
  /** Slideshow item contents */
  page_blocks: Array<PageBlock>,
  /** Block caption */
  caption: pageBlockCaption,
}

/** A slideshow */
export type pageBlockSlideshow$Input = {
  readonly _: 'pageBlockSlideshow',
  /** Slideshow item contents */
  readonly page_blocks?: ReadonlyArray<PageBlock$Input>,
  /** Block caption */
  readonly caption?: pageBlockCaption$Input,
}

/** A link to a chat */
export type pageBlockChatLink = {
  _: 'pageBlockChatLink',
  /** Chat title */
  title: string,
  /** Chat photo; may be null */
  photo: chatPhotoInfo | undefined,
  /** Chat username, by which all other information about the chat can be resolved */
  username: string,
}

/** A link to a chat */
export type pageBlockChatLink$Input = {
  readonly _: 'pageBlockChatLink',
  /** Chat title */
  readonly title?: string,
  /** Chat photo; may be null */
  readonly photo?: chatPhotoInfo$Input | undefined,
  /** Chat username, by which all other information about the chat can be resolved */
  readonly username?: string,
}

/** A table */
export type pageBlockTable = {
  _: 'pageBlockTable',
  /** Table caption */
  caption: RichText,
  /** Table cells */
  cells: Array<Array<pageBlockTableCell>>,
  /** True, if the table is bordered */
  is_bordered: boolean,
  /** True, if the table is striped */
  is_striped: boolean,
}

/** A table */
export type pageBlockTable$Input = {
  readonly _: 'pageBlockTable',
  /** Table caption */
  readonly caption?: RichText$Input,
  /** Table cells */
  readonly cells?: ReadonlyArray<ReadonlyArray<pageBlockTableCell$Input>>,
  /** True, if the table is bordered */
  readonly is_bordered?: boolean,
  /** True, if the table is striped */
  readonly is_striped?: boolean,
}

/** A collapsible block */
export type pageBlockDetails = {
  _: 'pageBlockDetails',
  /** Always visible heading for the block */
  header: RichText,
  /** Block contents */
  page_blocks: Array<PageBlock>,
  /** True, if the block is open by default */
  is_open: boolean,
}

/** A collapsible block */
export type pageBlockDetails$Input = {
  readonly _: 'pageBlockDetails',
  /** Always visible heading for the block */
  readonly header?: RichText$Input,
  /** Block contents */
  readonly page_blocks?: ReadonlyArray<PageBlock$Input>,
  /** True, if the block is open by default */
  readonly is_open?: boolean,
}

/** Related articles */
export type pageBlockRelatedArticles = {
  _: 'pageBlockRelatedArticles',
  /** Block header */
  header: RichText,
  /** List of related articles */
  articles: Array<pageBlockRelatedArticle>,
}

/** Related articles */
export type pageBlockRelatedArticles$Input = {
  readonly _: 'pageBlockRelatedArticles',
  /** Block header */
  readonly header?: RichText$Input,
  /** List of related articles */
  readonly articles?: ReadonlyArray<pageBlockRelatedArticle$Input>,
}

/** A map */
export type pageBlockMap = {
  _: 'pageBlockMap',
  /** Location of the map center */
  location: location,
  /** Map zoom level */
  zoom: number,
  /** Map width */
  width: number,
  /** Map height */
  height: number,
  /** Block caption */
  caption: pageBlockCaption,
}

/** A map */
export type pageBlockMap$Input = {
  readonly _: 'pageBlockMap',
  /** Location of the map center */
  readonly location?: location$Input,
  /** Map zoom level */
  readonly zoom?: number,
  /** Map width */
  readonly width?: number,
  /** Map height */
  readonly height?: number,
  /** Block caption */
  readonly caption?: pageBlockCaption$Input,
}

/** Describes an instant view page for a web page */
export type webPageInstantView = {
  _: 'webPageInstantView',
  /** Content of the web page */
  page_blocks: Array<PageBlock>,
  /** Number of the instant view views; 0 if unknown */
  view_count: number,
  /** Version of the instant view; currently, can be 1 or 2 */
  version: number,
  /** True, if the instant view must be shown from right to left */
  is_rtl: boolean,
  /**
   * True, if the instant view contains the full page. A network request might be needed
   * to get the full web page instant view
   */
  is_full: boolean,
  /** An internal link to be opened to leave feedback about the instant view */
  feedback_link: InternalLinkType,
}

/** Describes an instant view page for a web page */
export type webPageInstantView$Input = {
  readonly _: 'webPageInstantView',
  /** Content of the web page */
  readonly page_blocks?: ReadonlyArray<PageBlock$Input>,
  /** Number of the instant view views; 0 if unknown */
  readonly view_count?: number,
  /** Version of the instant view; currently, can be 1 or 2 */
  readonly version?: number,
  /** True, if the instant view must be shown from right to left */
  readonly is_rtl?: boolean,
  /**
   * True, if the instant view contains the full page. A network request might be needed
   * to get the full web page instant view
   */
  readonly is_full?: boolean,
  /** An internal link to be opened to leave feedback about the instant view */
  readonly feedback_link?: InternalLinkType$Input,
}

/** Describes a web page preview */
export type webPage = {
  _: 'webPage',
  /** Original URL of the link */
  url: string,
  /** URL to display */
  display_url: string,
  /**
   * Type of the web page. Can be: article, photo, audio, video, document, profile, app,
   * or something else
   */
  type: string,
  /** Short name of the site (e.g., Google Docs, App Store) */
  site_name: string,
  /** Title of the content */
  title: string,
  /** Description of the content */
  description: formattedText,
  /** Image representing the content; may be null */
  photo: photo | undefined,
  /** URL to show in the embedded preview */
  embed_url: string,
  /** MIME type of the embedded preview, (e.g., text/html or video/mp4) */
  embed_type: string,
  /** Width of the embedded preview */
  embed_width: number,
  /** Height of the embedded preview */
  embed_height: number,
  /** Duration of the content, in seconds */
  duration: number,
  /** Author of the content */
  author: string,
  /** Preview of the content as an animation, if available; may be null */
  animation: animation | undefined,
  /** Preview of the content as an audio file, if available; may be null */
  audio: audio | undefined,
  /** Preview of the content as a document, if available; may be null */
  document: document | undefined,
  /** Preview of the content as a sticker for small WEBP files, if available; may be null */
  sticker: sticker | undefined,
  /** Preview of the content as a video, if available; may be null */
  video: video | undefined,
  /** Preview of the content as a video note, if available; may be null */
  video_note: videoNote | undefined,
  /** Preview of the content as a voice note, if available; may be null */
  voice_note: voiceNote | undefined,
  /**
   * Version of instant view, available for the web page (currently, can be 1 or 2), 0
   * if none
   */
  instant_view_version: number,
}

/** Describes a web page preview */
export type webPage$Input = {
  readonly _: 'webPage',
  /** Original URL of the link */
  readonly url?: string,
  /** URL to display */
  readonly display_url?: string,
  /**
   * Type of the web page. Can be: article, photo, audio, video, document, profile, app,
   * or something else
   */
  readonly type?: string,
  /** Short name of the site (e.g., Google Docs, App Store) */
  readonly site_name?: string,
  /** Title of the content */
  readonly title?: string,
  /** Description of the content */
  readonly description?: formattedText$Input,
  /** Image representing the content; may be null */
  readonly photo?: photo$Input | undefined,
  /** URL to show in the embedded preview */
  readonly embed_url?: string,
  /** MIME type of the embedded preview, (e.g., text/html or video/mp4) */
  readonly embed_type?: string,
  /** Width of the embedded preview */
  readonly embed_width?: number,
  /** Height of the embedded preview */
  readonly embed_height?: number,
  /** Duration of the content, in seconds */
  readonly duration?: number,
  /** Author of the content */
  readonly author?: string,
  /** Preview of the content as an animation, if available; may be null */
  readonly animation?: animation$Input | undefined,
  /** Preview of the content as an audio file, if available; may be null */
  readonly audio?: audio$Input | undefined,
  /** Preview of the content as a document, if available; may be null */
  readonly document?: document$Input | undefined,
  /** Preview of the content as a sticker for small WEBP files, if available; may be null */
  readonly sticker?: sticker$Input | undefined,
  /** Preview of the content as a video, if available; may be null */
  readonly video?: video$Input | undefined,
  /** Preview of the content as a video note, if available; may be null */
  readonly video_note?: videoNote$Input | undefined,
  /** Preview of the content as a voice note, if available; may be null */
  readonly voice_note?: voiceNote$Input | undefined,
  /**
   * Version of instant view, available for the web page (currently, can be 1 or 2), 0
   * if none
   */
  readonly instant_view_version?: number,
}

/** Contains information about a country */
export type countryInfo = {
  _: 'countryInfo',
  /** A two-letter ISO 3166-1 alpha-2 country code */
  country_code: string,
  /** Native name of the country */
  name: string,
  /** English name of the country */
  english_name: string,
  /** True, if the country must be hidden from the list of all countries */
  is_hidden: boolean,
  /** List of country calling codes */
  calling_codes: Array<string>,
}

/** Contains information about a country */
export type countryInfo$Input = {
  readonly _: 'countryInfo',
  /** A two-letter ISO 3166-1 alpha-2 country code */
  readonly country_code?: string,
  /** Native name of the country */
  readonly name?: string,
  /** English name of the country */
  readonly english_name?: string,
  /** True, if the country must be hidden from the list of all countries */
  readonly is_hidden?: boolean,
  /** List of country calling codes */
  readonly calling_codes?: ReadonlyArray<string>,
}

/** Contains information about countries */
export type countries = {
  _: 'countries',
  /** The list of countries */
  countries: Array<countryInfo>,
}

/** Contains information about countries */
export type countries$Input = {
  readonly _: 'countries',
  /** The list of countries */
  readonly countries?: ReadonlyArray<countryInfo$Input>,
}

/** Contains information about a phone number */
export type phoneNumberInfo = {
  _: 'phoneNumberInfo',
  /** Information about the country to which the phone number belongs; may be null */
  country: countryInfo | undefined,
  /** The part of the phone number denoting country calling code or its part */
  country_calling_code: string,
  /**
   * The phone number without country calling code formatted accordingly to local rules.
   * Expected digits are returned as '-', but even more digits might be entered by the
   * user
   */
  formatted_phone_number: string,
}

/** Contains information about a phone number */
export type phoneNumberInfo$Input = {
  readonly _: 'phoneNumberInfo',
  /** Information about the country to which the phone number belongs; may be null */
  readonly country?: countryInfo$Input | undefined,
  /** The part of the phone number denoting country calling code or its part */
  readonly country_calling_code?: string,
  /**
   * The phone number without country calling code formatted accordingly to local rules.
   * Expected digits are returned as '-', but even more digits might be entered by the
   * user
   */
  readonly formatted_phone_number?: string,
}

/** Describes an action associated with a bank card number */
export type bankCardActionOpenUrl = {
  _: 'bankCardActionOpenUrl',
  /** Action text */
  text: string,
  /** The URL to be opened */
  url: string,
}

/** Describes an action associated with a bank card number */
export type bankCardActionOpenUrl$Input = {
  readonly _: 'bankCardActionOpenUrl',
  /** Action text */
  readonly text?: string,
  /** The URL to be opened */
  readonly url?: string,
}

/** Information about a bank card */
export type bankCardInfo = {
  _: 'bankCardInfo',
  /** Title of the bank card description */
  title: string,
  /** Actions that can be done with the bank card number */
  actions: Array<bankCardActionOpenUrl>,
}

/** Information about a bank card */
export type bankCardInfo$Input = {
  readonly _: 'bankCardInfo',
  /** Title of the bank card description */
  readonly title?: string,
  /** Actions that can be done with the bank card number */
  readonly actions?: ReadonlyArray<bankCardActionOpenUrl$Input>,
}

/** Describes an address */
export type address = {
  _: 'address',
  /** A two-letter ISO 3166-1 alpha-2 country code */
  country_code: string,
  /** State, if applicable */
  state: string,
  /** City */
  city: string,
  /** First line of the address */
  street_line1: string,
  /** Second line of the address */
  street_line2: string,
  /** Address postal code */
  postal_code: string,
}

/** Describes an address */
export type address$Input = {
  readonly _: 'address',
  /** A two-letter ISO 3166-1 alpha-2 country code */
  readonly country_code?: string,
  /** State, if applicable */
  readonly state?: string,
  /** City */
  readonly city?: string,
  /** First line of the address */
  readonly street_line1?: string,
  /** Second line of the address */
  readonly street_line2?: string,
  /** Address postal code */
  readonly postal_code?: string,
}

/** Portion of the price of a product (e.g., "delivery cost", "tax amount") */
export type labeledPricePart = {
  _: 'labeledPricePart',
  /** Label for this portion of the product price */
  label: string,
  /** Currency amount in the smallest units of the currency */
  amount: number,
}

/** Portion of the price of a product (e.g., "delivery cost", "tax amount") */
export type labeledPricePart$Input = {
  readonly _: 'labeledPricePart',
  /** Label for this portion of the product price */
  readonly label?: string,
  /** Currency amount in the smallest units of the currency */
  readonly amount?: number,
}

/** Product invoice */
export type invoice = {
  _: 'invoice',
  /** ISO 4217 currency code */
  currency: string,
  /** A list of objects used to calculate the total price of the product */
  price_parts: Array<labeledPricePart>,
  /** The maximum allowed amount of tip in the smallest units of the currency */
  max_tip_amount: number,
  /** Suggested amounts of tip in the smallest units of the currency */
  suggested_tip_amounts: Array<number>,
  /** True, if the payment is a test payment */
  is_test: boolean,
  /** True, if the user's name is needed for payment */
  need_name: boolean,
  /** True, if the user's phone number is needed for payment */
  need_phone_number: boolean,
  /** True, if the user's email address is needed for payment */
  need_email_address: boolean,
  /** True, if the user's shipping address is needed for payment */
  need_shipping_address: boolean,
  /** True, if the user's phone number will be sent to the provider */
  send_phone_number_to_provider: boolean,
  /** True, if the user's email address will be sent to the provider */
  send_email_address_to_provider: boolean,
  /** True, if the total price depends on the shipping method */
  is_flexible: boolean,
}

/** Product invoice */
export type invoice$Input = {
  readonly _: 'invoice',
  /** ISO 4217 currency code */
  readonly currency?: string,
  /** A list of objects used to calculate the total price of the product */
  readonly price_parts?: ReadonlyArray<labeledPricePart$Input>,
  /** The maximum allowed amount of tip in the smallest units of the currency */
  readonly max_tip_amount?: number,
  /** Suggested amounts of tip in the smallest units of the currency */
  readonly suggested_tip_amounts?: ReadonlyArray<number>,
  /** True, if the payment is a test payment */
  readonly is_test?: boolean,
  /** True, if the user's name is needed for payment */
  readonly need_name?: boolean,
  /** True, if the user's phone number is needed for payment */
  readonly need_phone_number?: boolean,
  /** True, if the user's email address is needed for payment */
  readonly need_email_address?: boolean,
  /** True, if the user's shipping address is needed for payment */
  readonly need_shipping_address?: boolean,
  /** True, if the user's phone number will be sent to the provider */
  readonly send_phone_number_to_provider?: boolean,
  /** True, if the user's email address will be sent to the provider */
  readonly send_email_address_to_provider?: boolean,
  /** True, if the total price depends on the shipping method */
  readonly is_flexible?: boolean,
}

/** Order information */
export type orderInfo = {
  _: 'orderInfo',
  /** Name of the user */
  name: string,
  /** Phone number of the user */
  phone_number: string,
  /** Email address of the user */
  email_address: string,
  /** Shipping address for this order; may be null */
  shipping_address: address | undefined,
}

/** Order information */
export type orderInfo$Input = {
  readonly _: 'orderInfo',
  /** Name of the user */
  readonly name?: string,
  /** Phone number of the user */
  readonly phone_number?: string,
  /** Email address of the user */
  readonly email_address?: string,
  /** Shipping address for this order; may be null */
  readonly shipping_address?: address$Input | undefined,
}

/** One shipping option */
export type shippingOption = {
  _: 'shippingOption',
  /** Shipping option identifier */
  id: string,
  /** Option title */
  title: string,
  /** A list of objects used to calculate the total shipping costs */
  price_parts: Array<labeledPricePart>,
}

/** One shipping option */
export type shippingOption$Input = {
  readonly _: 'shippingOption',
  /** Shipping option identifier */
  readonly id?: string,
  /** Option title */
  readonly title?: string,
  /** A list of objects used to calculate the total shipping costs */
  readonly price_parts?: ReadonlyArray<labeledPricePart$Input>,
}

/** Contains information about saved card credentials */
export type savedCredentials = {
  _: 'savedCredentials',
  /** Unique identifier of the saved credentials */
  id: string,
  /** Title of the saved credentials */
  title: string,
}

/** Contains information about saved card credentials */
export type savedCredentials$Input = {
  readonly _: 'savedCredentials',
  /** Unique identifier of the saved credentials */
  readonly id?: string,
  /** Title of the saved credentials */
  readonly title?: string,
}

/**
 * Applies if a user chooses some previously saved payment credentials. To use their
 * previously saved credentials, the user must have a valid temporary password
 */
export type inputCredentialsSaved = {
  _: 'inputCredentialsSaved',
  /** Identifier of the saved credentials */
  saved_credentials_id: string,
}

/**
 * Applies if a user chooses some previously saved payment credentials. To use their
 * previously saved credentials, the user must have a valid temporary password
 */
export type inputCredentialsSaved$Input = {
  readonly _: 'inputCredentialsSaved',
  /** Identifier of the saved credentials */
  readonly saved_credentials_id?: string,
}

/** Applies if a user enters new credentials on a payment provider website */
export type inputCredentialsNew = {
  _: 'inputCredentialsNew',
  /** JSON-encoded data with the credential identifier from the payment provider */
  data: string,
  /** True, if the credential identifier can be saved on the server side */
  allow_save: boolean,
}

/** Applies if a user enters new credentials on a payment provider website */
export type inputCredentialsNew$Input = {
  readonly _: 'inputCredentialsNew',
  /** JSON-encoded data with the credential identifier from the payment provider */
  readonly data?: string,
  /** True, if the credential identifier can be saved on the server side */
  readonly allow_save?: boolean,
}

/** Applies if a user enters new credentials using Apple Pay */
export type inputCredentialsApplePay = {
  _: 'inputCredentialsApplePay',
  /** JSON-encoded data with the credential identifier */
  data: string,
}

/** Applies if a user enters new credentials using Apple Pay */
export type inputCredentialsApplePay$Input = {
  readonly _: 'inputCredentialsApplePay',
  /** JSON-encoded data with the credential identifier */
  readonly data?: string,
}

/** Applies if a user enters new credentials using Google Pay */
export type inputCredentialsGooglePay = {
  _: 'inputCredentialsGooglePay',
  /** JSON-encoded data with the credential identifier */
  data: string,
}

/** Applies if a user enters new credentials using Google Pay */
export type inputCredentialsGooglePay$Input = {
  readonly _: 'inputCredentialsGooglePay',
  /** JSON-encoded data with the credential identifier */
  readonly data?: string,
}

/** Stripe payment provider */
export type paymentsProviderStripe = {
  _: 'paymentsProviderStripe',
  /** Stripe API publishable key */
  publishable_key: string,
  /** True, if the user country must be provided */
  need_country: boolean,
  /** True, if the user ZIP/postal code must be provided */
  need_postal_code: boolean,
  /** True, if the cardholder name must be provided */
  need_cardholder_name: boolean,
}

/** Stripe payment provider */
export type paymentsProviderStripe$Input = {
  readonly _: 'paymentsProviderStripe',
  /** Stripe API publishable key */
  readonly publishable_key?: string,
  /** True, if the user country must be provided */
  readonly need_country?: boolean,
  /** True, if the user ZIP/postal code must be provided */
  readonly need_postal_code?: boolean,
  /** True, if the cardholder name must be provided */
  readonly need_cardholder_name?: boolean,
}

/** Theme colors for a payment form */
export type paymentFormTheme = {
  _: 'paymentFormTheme',
  /** A color of the payment form background in the RGB24 format */
  background_color: number,
  /** A color of text in the RGB24 format */
  text_color: number,
  /** A color of hints in the RGB24 format */
  hint_color: number,
  /** A color of links in the RGB24 format */
  link_color: number,
  /** A color of the buttons in the RGB24 format */
  button_color: number,
  /** A color of text on the buttons in the RGB24 format */
  button_text_color: number,
}

/** Theme colors for a payment form */
export type paymentFormTheme$Input = {
  readonly _: 'paymentFormTheme',
  /** A color of the payment form background in the RGB24 format */
  readonly background_color?: number,
  /** A color of text in the RGB24 format */
  readonly text_color?: number,
  /** A color of hints in the RGB24 format */
  readonly hint_color?: number,
  /** A color of links in the RGB24 format */
  readonly link_color?: number,
  /** A color of the buttons in the RGB24 format */
  readonly button_color?: number,
  /** A color of text on the buttons in the RGB24 format */
  readonly button_text_color?: number,
}

/** Contains information about an invoice payment form */
export type paymentForm = {
  _: 'paymentForm',
  /** The payment form identifier */
  id: number | string,
  /** Full information of the invoice */
  invoice: invoice,
  /** Payment form URL */
  url: string,
  /** User identifier of the seller bot */
  seller_bot_user_id: number,
  /** User identifier of the payment provider bot */
  payments_provider_user_id: number,
  /**
   * Information about the payment provider, if available, to support it natively without
   * the need for opening the URL; may be null
   */
  payments_provider: paymentsProviderStripe | undefined,
  /** Saved server-side order information; may be null */
  saved_order_info: orderInfo | undefined,
  /** Information about saved card credentials; may be null */
  saved_credentials: savedCredentials | undefined,
  /** True, if the user can choose to save credentials */
  can_save_credentials: boolean,
  /**
   * True, if the user will be able to save credentials protected by a password they set
   * up
   */
  need_password: boolean,
}

/** Contains information about an invoice payment form */
export type paymentForm$Input = {
  readonly _: 'paymentForm',
  /** The payment form identifier */
  readonly id?: number | string,
  /** Full information of the invoice */
  readonly invoice?: invoice$Input,
  /** Payment form URL */
  readonly url?: string,
  /** User identifier of the seller bot */
  readonly seller_bot_user_id?: number,
  /** User identifier of the payment provider bot */
  readonly payments_provider_user_id?: number,
  /**
   * Information about the payment provider, if available, to support it natively without
   * the need for opening the URL; may be null
   */
  readonly payments_provider?: paymentsProviderStripe$Input | undefined,
  /** Saved server-side order information; may be null */
  readonly saved_order_info?: orderInfo$Input | undefined,
  /** Information about saved card credentials; may be null */
  readonly saved_credentials?: savedCredentials$Input | undefined,
  /** True, if the user can choose to save credentials */
  readonly can_save_credentials?: boolean,
  /**
   * True, if the user will be able to save credentials protected by a password they set
   * up
   */
  readonly need_password?: boolean,
}

/**
 * Contains a temporary identifier of validated order information, which is stored for
 * one hour. Also contains the available shipping options
 */
export type validatedOrderInfo = {
  _: 'validatedOrderInfo',
  /** Temporary identifier of the order information */
  order_info_id: string,
  /** Available shipping options */
  shipping_options: Array<shippingOption>,
}

/**
 * Contains a temporary identifier of validated order information, which is stored for
 * one hour. Also contains the available shipping options
 */
export type validatedOrderInfo$Input = {
  readonly _: 'validatedOrderInfo',
  /** Temporary identifier of the order information */
  readonly order_info_id?: string,
  /** Available shipping options */
  readonly shipping_options?: ReadonlyArray<shippingOption$Input>,
}

/** Contains the result of a payment request */
export type paymentResult = {
  _: 'paymentResult',
  /**
   * True, if the payment request was successful; otherwise the verification_url will
   * be non-empty
   */
  success: boolean,
  /** URL for additional payment credentials verification */
  verification_url: string,
}

/** Contains the result of a payment request */
export type paymentResult$Input = {
  readonly _: 'paymentResult',
  /**
   * True, if the payment request was successful; otherwise the verification_url will
   * be non-empty
   */
  readonly success?: boolean,
  /** URL for additional payment credentials verification */
  readonly verification_url?: string,
}

/** Contains information about a successful payment */
export type paymentReceipt = {
  _: 'paymentReceipt',
  /** Product title */
  title: string,
  /** Product description */
  description: string,
  /** Product photo; may be null */
  photo: photo | undefined,
  /** Point in time (Unix timestamp) when the payment was made */
  date: number,
  /** User identifier of the seller bot */
  seller_bot_user_id: number,
  /** User identifier of the payment provider bot */
  payments_provider_user_id: number,
  /** Information about the invoice */
  invoice: invoice,
  /** Order information; may be null */
  order_info: orderInfo | undefined,
  /** Chosen shipping option; may be null */
  shipping_option: shippingOption | undefined,
  /** Title of the saved credentials chosen by the buyer */
  credentials_title: string,
  /** The amount of tip chosen by the buyer in the smallest units of the currency */
  tip_amount: number,
}

/** Contains information about a successful payment */
export type paymentReceipt$Input = {
  readonly _: 'paymentReceipt',
  /** Product title */
  readonly title?: string,
  /** Product description */
  readonly description?: string,
  /** Product photo; may be null */
  readonly photo?: photo$Input | undefined,
  /** Point in time (Unix timestamp) when the payment was made */
  readonly date?: number,
  /** User identifier of the seller bot */
  readonly seller_bot_user_id?: number,
  /** User identifier of the payment provider bot */
  readonly payments_provider_user_id?: number,
  /** Information about the invoice */
  readonly invoice?: invoice$Input,
  /** Order information; may be null */
  readonly order_info?: orderInfo$Input | undefined,
  /** Chosen shipping option; may be null */
  readonly shipping_option?: shippingOption$Input | undefined,
  /** Title of the saved credentials chosen by the buyer */
  readonly credentials_title?: string,
  /** The amount of tip chosen by the buyer in the smallest units of the currency */
  readonly tip_amount?: number,
}

/** File with the date it was uploaded */
export type datedFile = {
  _: 'datedFile',
  /** The file */
  file: file,
  /** Point in time (Unix timestamp) when the file was uploaded */
  date: number,
}

/** File with the date it was uploaded */
export type datedFile$Input = {
  readonly _: 'datedFile',
  /** The file */
  readonly file?: file$Input,
  /** Point in time (Unix timestamp) when the file was uploaded */
  readonly date?: number,
}

/** A Telegram Passport element containing the user's personal details */
export type passportElementTypePersonalDetails = {
  _: 'passportElementTypePersonalDetails',
}

/** A Telegram Passport element containing the user's personal details */
export type passportElementTypePersonalDetails$Input = {
  readonly _: 'passportElementTypePersonalDetails',
}

/** A Telegram Passport element containing the user's passport */
export type passportElementTypePassport = {
  _: 'passportElementTypePassport',
}

/** A Telegram Passport element containing the user's passport */
export type passportElementTypePassport$Input = {
  readonly _: 'passportElementTypePassport',
}

/** A Telegram Passport element containing the user's driver license */
export type passportElementTypeDriverLicense = {
  _: 'passportElementTypeDriverLicense',
}

/** A Telegram Passport element containing the user's driver license */
export type passportElementTypeDriverLicense$Input = {
  readonly _: 'passportElementTypeDriverLicense',
}

/** A Telegram Passport element containing the user's identity card */
export type passportElementTypeIdentityCard = {
  _: 'passportElementTypeIdentityCard',
}

/** A Telegram Passport element containing the user's identity card */
export type passportElementTypeIdentityCard$Input = {
  readonly _: 'passportElementTypeIdentityCard',
}

/** A Telegram Passport element containing the user's internal passport */
export type passportElementTypeInternalPassport = {
  _: 'passportElementTypeInternalPassport',
}

/** A Telegram Passport element containing the user's internal passport */
export type passportElementTypeInternalPassport$Input = {
  readonly _: 'passportElementTypeInternalPassport',
}

/** A Telegram Passport element containing the user's address */
export type passportElementTypeAddress = {
  _: 'passportElementTypeAddress',
}

/** A Telegram Passport element containing the user's address */
export type passportElementTypeAddress$Input = {
  readonly _: 'passportElementTypeAddress',
}

/** A Telegram Passport element containing the user's utility bill */
export type passportElementTypeUtilityBill = {
  _: 'passportElementTypeUtilityBill',
}

/** A Telegram Passport element containing the user's utility bill */
export type passportElementTypeUtilityBill$Input = {
  readonly _: 'passportElementTypeUtilityBill',
}

/** A Telegram Passport element containing the user's bank statement */
export type passportElementTypeBankStatement = {
  _: 'passportElementTypeBankStatement',
}

/** A Telegram Passport element containing the user's bank statement */
export type passportElementTypeBankStatement$Input = {
  readonly _: 'passportElementTypeBankStatement',
}

/** A Telegram Passport element containing the user's rental agreement */
export type passportElementTypeRentalAgreement = {
  _: 'passportElementTypeRentalAgreement',
}

/** A Telegram Passport element containing the user's rental agreement */
export type passportElementTypeRentalAgreement$Input = {
  readonly _: 'passportElementTypeRentalAgreement',
}

/** A Telegram Passport element containing the registration page of the user's passport */
export type passportElementTypePassportRegistration = {
  _: 'passportElementTypePassportRegistration',
}

/** A Telegram Passport element containing the registration page of the user's passport */
export type passportElementTypePassportRegistration$Input = {
  readonly _: 'passportElementTypePassportRegistration',
}

/** A Telegram Passport element containing the user's temporary registration */
export type passportElementTypeTemporaryRegistration = {
  _: 'passportElementTypeTemporaryRegistration',
}

/** A Telegram Passport element containing the user's temporary registration */
export type passportElementTypeTemporaryRegistration$Input = {
  readonly _: 'passportElementTypeTemporaryRegistration',
}

/** A Telegram Passport element containing the user's phone number */
export type passportElementTypePhoneNumber = {
  _: 'passportElementTypePhoneNumber',
}

/** A Telegram Passport element containing the user's phone number */
export type passportElementTypePhoneNumber$Input = {
  readonly _: 'passportElementTypePhoneNumber',
}

/** A Telegram Passport element containing the user's email address */
export type passportElementTypeEmailAddress = {
  _: 'passportElementTypeEmailAddress',
}

/** A Telegram Passport element containing the user's email address */
export type passportElementTypeEmailAddress$Input = {
  readonly _: 'passportElementTypeEmailAddress',
}

/** Represents a date according to the Gregorian calendar */
export type date = {
  _: 'date',
  /** Day of the month; 1-31 */
  day: number,
  /** Month; 1-12 */
  month: number,
  /** Year; 1-9999 */
  year: number,
}

/** Represents a date according to the Gregorian calendar */
export type date$Input = {
  readonly _: 'date',
  /** Day of the month; 1-31 */
  readonly day?: number,
  /** Month; 1-12 */
  readonly month?: number,
  /** Year; 1-9999 */
  readonly year?: number,
}

/** Contains the user's personal details */
export type personalDetails = {
  _: 'personalDetails',
  /** First name of the user written in English; 1-255 characters */
  first_name: string,
  /** Middle name of the user written in English; 0-255 characters */
  middle_name: string,
  /** Last name of the user written in English; 1-255 characters */
  last_name: string,
  /** Native first name of the user; 1-255 characters */
  native_first_name: string,
  /** Native middle name of the user; 0-255 characters */
  native_middle_name: string,
  /** Native last name of the user; 1-255 characters */
  native_last_name: string,
  /** Birthdate of the user */
  birthdate: date,
  /** Gender of the user, "male" or "female" */
  gender: string,
  /** A two-letter ISO 3166-1 alpha-2 country code of the user's country */
  country_code: string,
  /** A two-letter ISO 3166-1 alpha-2 country code of the user's residence country */
  residence_country_code: string,
}

/** Contains the user's personal details */
export type personalDetails$Input = {
  readonly _: 'personalDetails',
  /** First name of the user written in English; 1-255 characters */
  readonly first_name?: string,
  /** Middle name of the user written in English; 0-255 characters */
  readonly middle_name?: string,
  /** Last name of the user written in English; 1-255 characters */
  readonly last_name?: string,
  /** Native first name of the user; 1-255 characters */
  readonly native_first_name?: string,
  /** Native middle name of the user; 0-255 characters */
  readonly native_middle_name?: string,
  /** Native last name of the user; 1-255 characters */
  readonly native_last_name?: string,
  /** Birthdate of the user */
  readonly birthdate?: date$Input,
  /** Gender of the user, "male" or "female" */
  readonly gender?: string,
  /** A two-letter ISO 3166-1 alpha-2 country code of the user's country */
  readonly country_code?: string,
  /** A two-letter ISO 3166-1 alpha-2 country code of the user's residence country */
  readonly residence_country_code?: string,
}

/** An identity document */
export type identityDocument = {
  _: 'identityDocument',
  /** Document number; 1-24 characters */
  number: string,
  /** Document expiry date; may be null if not applicable */
  expiry_date: date | undefined,
  /** Front side of the document */
  front_side: datedFile,
  /** Reverse side of the document; only for driver license and identity card; may be null */
  reverse_side: datedFile | undefined,
  /** Selfie with the document; may be null */
  selfie: datedFile | undefined,
  /** List of files containing a certified English translation of the document */
  translation: Array<datedFile>,
}

/** An identity document */
export type identityDocument$Input = {
  readonly _: 'identityDocument',
  /** Document number; 1-24 characters */
  readonly number?: string,
  /** Document expiry date; may be null if not applicable */
  readonly expiry_date?: date$Input | undefined,
  /** Front side of the document */
  readonly front_side?: datedFile$Input,
  /** Reverse side of the document; only for driver license and identity card; may be null */
  readonly reverse_side?: datedFile$Input | undefined,
  /** Selfie with the document; may be null */
  readonly selfie?: datedFile$Input | undefined,
  /** List of files containing a certified English translation of the document */
  readonly translation?: ReadonlyArray<datedFile$Input>,
}

/** An identity document to be saved to Telegram Passport */
export type inputIdentityDocument = {
  _: 'inputIdentityDocument',
  /** Document number; 1-24 characters */
  number: string,
  /** Document expiry date; pass null if not applicable */
  expiry_date: date,
  /** Front side of the document */
  front_side: InputFile,
  /**
   * Reverse side of the document; only for driver license and identity card; pass null
   * otherwise
   */
  reverse_side: InputFile,
  /** Selfie with the document; pass null if unavailable */
  selfie: InputFile,
  /** List of files containing a certified English translation of the document */
  translation: Array<InputFile>,
}

/** An identity document to be saved to Telegram Passport */
export type inputIdentityDocument$Input = {
  readonly _: 'inputIdentityDocument',
  /** Document number; 1-24 characters */
  readonly number?: string,
  /** Document expiry date; pass null if not applicable */
  readonly expiry_date?: date$Input,
  /** Front side of the document */
  readonly front_side?: InputFile$Input,
  /**
   * Reverse side of the document; only for driver license and identity card; pass null
   * otherwise
   */
  readonly reverse_side?: InputFile$Input,
  /** Selfie with the document; pass null if unavailable */
  readonly selfie?: InputFile$Input,
  /** List of files containing a certified English translation of the document */
  readonly translation?: ReadonlyArray<InputFile$Input>,
}

/** A personal document, containing some information about a user */
export type personalDocument = {
  _: 'personalDocument',
  /** List of files containing the pages of the document */
  files: Array<datedFile>,
  /** List of files containing a certified English translation of the document */
  translation: Array<datedFile>,
}

/** A personal document, containing some information about a user */
export type personalDocument$Input = {
  readonly _: 'personalDocument',
  /** List of files containing the pages of the document */
  readonly files?: ReadonlyArray<datedFile$Input>,
  /** List of files containing a certified English translation of the document */
  readonly translation?: ReadonlyArray<datedFile$Input>,
}

/** A personal document to be saved to Telegram Passport */
export type inputPersonalDocument = {
  _: 'inputPersonalDocument',
  /** List of files containing the pages of the document */
  files: Array<InputFile>,
  /** List of files containing a certified English translation of the document */
  translation: Array<InputFile>,
}

/** A personal document to be saved to Telegram Passport */
export type inputPersonalDocument$Input = {
  readonly _: 'inputPersonalDocument',
  /** List of files containing the pages of the document */
  readonly files?: ReadonlyArray<InputFile$Input>,
  /** List of files containing a certified English translation of the document */
  readonly translation?: ReadonlyArray<InputFile$Input>,
}

/** A Telegram Passport element containing the user's personal details */
export type passportElementPersonalDetails = {
  _: 'passportElementPersonalDetails',
  /** Personal details of the user */
  personal_details: personalDetails,
}

/** A Telegram Passport element containing the user's personal details */
export type passportElementPersonalDetails$Input = {
  readonly _: 'passportElementPersonalDetails',
  /** Personal details of the user */
  readonly personal_details?: personalDetails$Input,
}

/** A Telegram Passport element containing the user's passport */
export type passportElementPassport = {
  _: 'passportElementPassport',
  /** Passport */
  passport: identityDocument,
}

/** A Telegram Passport element containing the user's passport */
export type passportElementPassport$Input = {
  readonly _: 'passportElementPassport',
  /** Passport */
  readonly passport?: identityDocument$Input,
}

/** A Telegram Passport element containing the user's driver license */
export type passportElementDriverLicense = {
  _: 'passportElementDriverLicense',
  /** Driver license */
  driver_license: identityDocument,
}

/** A Telegram Passport element containing the user's driver license */
export type passportElementDriverLicense$Input = {
  readonly _: 'passportElementDriverLicense',
  /** Driver license */
  readonly driver_license?: identityDocument$Input,
}

/** A Telegram Passport element containing the user's identity card */
export type passportElementIdentityCard = {
  _: 'passportElementIdentityCard',
  /** Identity card */
  identity_card: identityDocument,
}

/** A Telegram Passport element containing the user's identity card */
export type passportElementIdentityCard$Input = {
  readonly _: 'passportElementIdentityCard',
  /** Identity card */
  readonly identity_card?: identityDocument$Input,
}

/** A Telegram Passport element containing the user's internal passport */
export type passportElementInternalPassport = {
  _: 'passportElementInternalPassport',
  /** Internal passport */
  internal_passport: identityDocument,
}

/** A Telegram Passport element containing the user's internal passport */
export type passportElementInternalPassport$Input = {
  readonly _: 'passportElementInternalPassport',
  /** Internal passport */
  readonly internal_passport?: identityDocument$Input,
}

/** A Telegram Passport element containing the user's address */
export type passportElementAddress = {
  _: 'passportElementAddress',
  /** Address */
  address: address,
}

/** A Telegram Passport element containing the user's address */
export type passportElementAddress$Input = {
  readonly _: 'passportElementAddress',
  /** Address */
  readonly address?: address$Input,
}

/** A Telegram Passport element containing the user's utility bill */
export type passportElementUtilityBill = {
  _: 'passportElementUtilityBill',
  /** Utility bill */
  utility_bill: personalDocument,
}

/** A Telegram Passport element containing the user's utility bill */
export type passportElementUtilityBill$Input = {
  readonly _: 'passportElementUtilityBill',
  /** Utility bill */
  readonly utility_bill?: personalDocument$Input,
}

/** A Telegram Passport element containing the user's bank statement */
export type passportElementBankStatement = {
  _: 'passportElementBankStatement',
  /** Bank statement */
  bank_statement: personalDocument,
}

/** A Telegram Passport element containing the user's bank statement */
export type passportElementBankStatement$Input = {
  readonly _: 'passportElementBankStatement',
  /** Bank statement */
  readonly bank_statement?: personalDocument$Input,
}

/** A Telegram Passport element containing the user's rental agreement */
export type passportElementRentalAgreement = {
  _: 'passportElementRentalAgreement',
  /** Rental agreement */
  rental_agreement: personalDocument,
}

/** A Telegram Passport element containing the user's rental agreement */
export type passportElementRentalAgreement$Input = {
  readonly _: 'passportElementRentalAgreement',
  /** Rental agreement */
  readonly rental_agreement?: personalDocument$Input,
}

/** A Telegram Passport element containing the user's passport registration pages */
export type passportElementPassportRegistration = {
  _: 'passportElementPassportRegistration',
  /** Passport registration pages */
  passport_registration: personalDocument,
}

/** A Telegram Passport element containing the user's passport registration pages */
export type passportElementPassportRegistration$Input = {
  readonly _: 'passportElementPassportRegistration',
  /** Passport registration pages */
  readonly passport_registration?: personalDocument$Input,
}

/** A Telegram Passport element containing the user's temporary registration */
export type passportElementTemporaryRegistration = {
  _: 'passportElementTemporaryRegistration',
  /** Temporary registration */
  temporary_registration: personalDocument,
}

/** A Telegram Passport element containing the user's temporary registration */
export type passportElementTemporaryRegistration$Input = {
  readonly _: 'passportElementTemporaryRegistration',
  /** Temporary registration */
  readonly temporary_registration?: personalDocument$Input,
}

/** A Telegram Passport element containing the user's phone number */
export type passportElementPhoneNumber = {
  _: 'passportElementPhoneNumber',
  /** Phone number */
  phone_number: string,
}

/** A Telegram Passport element containing the user's phone number */
export type passportElementPhoneNumber$Input = {
  readonly _: 'passportElementPhoneNumber',
  /** Phone number */
  readonly phone_number?: string,
}

/** A Telegram Passport element containing the user's email address */
export type passportElementEmailAddress = {
  _: 'passportElementEmailAddress',
  /** Email address */
  email_address: string,
}

/** A Telegram Passport element containing the user's email address */
export type passportElementEmailAddress$Input = {
  readonly _: 'passportElementEmailAddress',
  /** Email address */
  readonly email_address?: string,
}

/** A Telegram Passport element to be saved containing the user's personal details */
export type inputPassportElementPersonalDetails = {
  _: 'inputPassportElementPersonalDetails',
  /** Personal details of the user */
  personal_details: personalDetails,
}

/** A Telegram Passport element to be saved containing the user's personal details */
export type inputPassportElementPersonalDetails$Input = {
  readonly _: 'inputPassportElementPersonalDetails',
  /** Personal details of the user */
  readonly personal_details?: personalDetails$Input,
}

/** A Telegram Passport element to be saved containing the user's passport */
export type inputPassportElementPassport = {
  _: 'inputPassportElementPassport',
  /** The passport to be saved */
  passport: inputIdentityDocument,
}

/** A Telegram Passport element to be saved containing the user's passport */
export type inputPassportElementPassport$Input = {
  readonly _: 'inputPassportElementPassport',
  /** The passport to be saved */
  readonly passport?: inputIdentityDocument$Input,
}

/** A Telegram Passport element to be saved containing the user's driver license */
export type inputPassportElementDriverLicense = {
  _: 'inputPassportElementDriverLicense',
  /** The driver license to be saved */
  driver_license: inputIdentityDocument,
}

/** A Telegram Passport element to be saved containing the user's driver license */
export type inputPassportElementDriverLicense$Input = {
  readonly _: 'inputPassportElementDriverLicense',
  /** The driver license to be saved */
  readonly driver_license?: inputIdentityDocument$Input,
}

/** A Telegram Passport element to be saved containing the user's identity card */
export type inputPassportElementIdentityCard = {
  _: 'inputPassportElementIdentityCard',
  /** The identity card to be saved */
  identity_card: inputIdentityDocument,
}

/** A Telegram Passport element to be saved containing the user's identity card */
export type inputPassportElementIdentityCard$Input = {
  readonly _: 'inputPassportElementIdentityCard',
  /** The identity card to be saved */
  readonly identity_card?: inputIdentityDocument$Input,
}

/** A Telegram Passport element to be saved containing the user's internal passport */
export type inputPassportElementInternalPassport = {
  _: 'inputPassportElementInternalPassport',
  /** The internal passport to be saved */
  internal_passport: inputIdentityDocument,
}

/** A Telegram Passport element to be saved containing the user's internal passport */
export type inputPassportElementInternalPassport$Input = {
  readonly _: 'inputPassportElementInternalPassport',
  /** The internal passport to be saved */
  readonly internal_passport?: inputIdentityDocument$Input,
}

/** A Telegram Passport element to be saved containing the user's address */
export type inputPassportElementAddress = {
  _: 'inputPassportElementAddress',
  /** The address to be saved */
  address: address,
}

/** A Telegram Passport element to be saved containing the user's address */
export type inputPassportElementAddress$Input = {
  readonly _: 'inputPassportElementAddress',
  /** The address to be saved */
  readonly address?: address$Input,
}

/** A Telegram Passport element to be saved containing the user's utility bill */
export type inputPassportElementUtilityBill = {
  _: 'inputPassportElementUtilityBill',
  /** The utility bill to be saved */
  utility_bill: inputPersonalDocument,
}

/** A Telegram Passport element to be saved containing the user's utility bill */
export type inputPassportElementUtilityBill$Input = {
  readonly _: 'inputPassportElementUtilityBill',
  /** The utility bill to be saved */
  readonly utility_bill?: inputPersonalDocument$Input,
}

/** A Telegram Passport element to be saved containing the user's bank statement */
export type inputPassportElementBankStatement = {
  _: 'inputPassportElementBankStatement',
  /** The bank statement to be saved */
  bank_statement: inputPersonalDocument,
}

/** A Telegram Passport element to be saved containing the user's bank statement */
export type inputPassportElementBankStatement$Input = {
  readonly _: 'inputPassportElementBankStatement',
  /** The bank statement to be saved */
  readonly bank_statement?: inputPersonalDocument$Input,
}

/** A Telegram Passport element to be saved containing the user's rental agreement */
export type inputPassportElementRentalAgreement = {
  _: 'inputPassportElementRentalAgreement',
  /** The rental agreement to be saved */
  rental_agreement: inputPersonalDocument,
}

/** A Telegram Passport element to be saved containing the user's rental agreement */
export type inputPassportElementRentalAgreement$Input = {
  readonly _: 'inputPassportElementRentalAgreement',
  /** The rental agreement to be saved */
  readonly rental_agreement?: inputPersonalDocument$Input,
}

/** A Telegram Passport element to be saved containing the user's passport registration */
export type inputPassportElementPassportRegistration = {
  _: 'inputPassportElementPassportRegistration',
  /** The passport registration page to be saved */
  passport_registration: inputPersonalDocument,
}

/** A Telegram Passport element to be saved containing the user's passport registration */
export type inputPassportElementPassportRegistration$Input = {
  readonly _: 'inputPassportElementPassportRegistration',
  /** The passport registration page to be saved */
  readonly passport_registration?: inputPersonalDocument$Input,
}

/** A Telegram Passport element to be saved containing the user's temporary registration */
export type inputPassportElementTemporaryRegistration = {
  _: 'inputPassportElementTemporaryRegistration',
  /** The temporary registration document to be saved */
  temporary_registration: inputPersonalDocument,
}

/** A Telegram Passport element to be saved containing the user's temporary registration */
export type inputPassportElementTemporaryRegistration$Input = {
  readonly _: 'inputPassportElementTemporaryRegistration',
  /** The temporary registration document to be saved */
  readonly temporary_registration?: inputPersonalDocument$Input,
}

/** A Telegram Passport element to be saved containing the user's phone number */
export type inputPassportElementPhoneNumber = {
  _: 'inputPassportElementPhoneNumber',
  /** The phone number to be saved */
  phone_number: string,
}

/** A Telegram Passport element to be saved containing the user's phone number */
export type inputPassportElementPhoneNumber$Input = {
  readonly _: 'inputPassportElementPhoneNumber',
  /** The phone number to be saved */
  readonly phone_number?: string,
}

/** A Telegram Passport element to be saved containing the user's email address */
export type inputPassportElementEmailAddress = {
  _: 'inputPassportElementEmailAddress',
  /** The email address to be saved */
  email_address: string,
}

/** A Telegram Passport element to be saved containing the user's email address */
export type inputPassportElementEmailAddress$Input = {
  readonly _: 'inputPassportElementEmailAddress',
  /** The email address to be saved */
  readonly email_address?: string,
}

/** Contains information about saved Telegram Passport elements */
export type passportElements = {
  _: 'passportElements',
  /** Telegram Passport elements */
  elements: Array<PassportElement>,
}

/** Contains information about saved Telegram Passport elements */
export type passportElements$Input = {
  readonly _: 'passportElements',
  /** Telegram Passport elements */
  readonly elements?: ReadonlyArray<PassportElement$Input>,
}

/**
 * The element contains an error in an unspecified place. The error will be considered
 * resolved when new data is added
 */
export type passportElementErrorSourceUnspecified = {
  _: 'passportElementErrorSourceUnspecified',
}

/**
 * The element contains an error in an unspecified place. The error will be considered
 * resolved when new data is added
 */
export type passportElementErrorSourceUnspecified$Input = {
  readonly _: 'passportElementErrorSourceUnspecified',
}

/**
 * One of the data fields contains an error. The error will be considered resolved when
 * the value of the field changes
 */
export type passportElementErrorSourceDataField = {
  _: 'passportElementErrorSourceDataField',
  /** Field name */
  field_name: string,
}

/**
 * One of the data fields contains an error. The error will be considered resolved when
 * the value of the field changes
 */
export type passportElementErrorSourceDataField$Input = {
  readonly _: 'passportElementErrorSourceDataField',
  /** Field name */
  readonly field_name?: string,
}

/**
 * The front side of the document contains an error. The error will be considered resolved
 * when the file with the front side changes
 */
export type passportElementErrorSourceFrontSide = {
  _: 'passportElementErrorSourceFrontSide',
}

/**
 * The front side of the document contains an error. The error will be considered resolved
 * when the file with the front side changes
 */
export type passportElementErrorSourceFrontSide$Input = {
  readonly _: 'passportElementErrorSourceFrontSide',
}

/**
 * The reverse side of the document contains an error. The error will be considered
 * resolved when the file with the reverse side changes
 */
export type passportElementErrorSourceReverseSide = {
  _: 'passportElementErrorSourceReverseSide',
}

/**
 * The reverse side of the document contains an error. The error will be considered
 * resolved when the file with the reverse side changes
 */
export type passportElementErrorSourceReverseSide$Input = {
  readonly _: 'passportElementErrorSourceReverseSide',
}

/**
 * The selfie with the document contains an error. The error will be considered resolved
 * when the file with the selfie changes
 */
export type passportElementErrorSourceSelfie = {
  _: 'passportElementErrorSourceSelfie',
}

/**
 * The selfie with the document contains an error. The error will be considered resolved
 * when the file with the selfie changes
 */
export type passportElementErrorSourceSelfie$Input = {
  readonly _: 'passportElementErrorSourceSelfie',
}

/**
 * One of files with the translation of the document contains an error. The error will
 * be considered resolved when the file changes
 */
export type passportElementErrorSourceTranslationFile = {
  _: 'passportElementErrorSourceTranslationFile',
  /** Index of a file with the error */
  file_index: number,
}

/**
 * One of files with the translation of the document contains an error. The error will
 * be considered resolved when the file changes
 */
export type passportElementErrorSourceTranslationFile$Input = {
  readonly _: 'passportElementErrorSourceTranslationFile',
  /** Index of a file with the error */
  readonly file_index?: number,
}

/**
 * The translation of the document contains an error. The error will be considered resolved
 * when the list of translation files changes
 */
export type passportElementErrorSourceTranslationFiles = {
  _: 'passportElementErrorSourceTranslationFiles',
}

/**
 * The translation of the document contains an error. The error will be considered resolved
 * when the list of translation files changes
 */
export type passportElementErrorSourceTranslationFiles$Input = {
  readonly _: 'passportElementErrorSourceTranslationFiles',
}

/** The file contains an error. The error will be considered resolved when the file changes */
export type passportElementErrorSourceFile = {
  _: 'passportElementErrorSourceFile',
  /** Index of a file with the error */
  file_index: number,
}

/** The file contains an error. The error will be considered resolved when the file changes */
export type passportElementErrorSourceFile$Input = {
  readonly _: 'passportElementErrorSourceFile',
  /** Index of a file with the error */
  readonly file_index?: number,
}

/**
 * The list of attached files contains an error. The error will be considered resolved
 * when the list of files changes
 */
export type passportElementErrorSourceFiles = {
  _: 'passportElementErrorSourceFiles',
}

/**
 * The list of attached files contains an error. The error will be considered resolved
 * when the list of files changes
 */
export type passportElementErrorSourceFiles$Input = {
  readonly _: 'passportElementErrorSourceFiles',
}

/** Contains the description of an error in a Telegram Passport element */
export type passportElementError = {
  _: 'passportElementError',
  /** Type of the Telegram Passport element which has the error */
  type: PassportElementType,
  /** Error message */
  message: string,
  /** Error source */
  source: PassportElementErrorSource,
}

/** Contains the description of an error in a Telegram Passport element */
export type passportElementError$Input = {
  readonly _: 'passportElementError',
  /** Type of the Telegram Passport element which has the error */
  readonly type?: PassportElementType$Input,
  /** Error message */
  readonly message?: string,
  /** Error source */
  readonly source?: PassportElementErrorSource$Input,
}

/** Contains information about a Telegram Passport element that was requested by a service */
export type passportSuitableElement = {
  _: 'passportSuitableElement',
  /** Type of the element */
  type: PassportElementType,
  /** True, if a selfie is required with the identity document */
  is_selfie_required: boolean,
  /** True, if a certified English translation is required with the document */
  is_translation_required: boolean,
  /**
   * True, if personal details must include the user's name in the language of their country
   * of residence
   */
  is_native_name_required: boolean,
}

/** Contains information about a Telegram Passport element that was requested by a service */
export type passportSuitableElement$Input = {
  readonly _: 'passportSuitableElement',
  /** Type of the element */
  readonly type?: PassportElementType$Input,
  /** True, if a selfie is required with the identity document */
  readonly is_selfie_required?: boolean,
  /** True, if a certified English translation is required with the document */
  readonly is_translation_required?: boolean,
  /**
   * True, if personal details must include the user's name in the language of their country
   * of residence
   */
  readonly is_native_name_required?: boolean,
}

/**
 * Contains a description of the required Telegram Passport element that was requested
 * by a service
 */
export type passportRequiredElement = {
  _: 'passportRequiredElement',
  /** List of Telegram Passport elements any of which is enough to provide */
  suitable_elements: Array<passportSuitableElement>,
}

/**
 * Contains a description of the required Telegram Passport element that was requested
 * by a service
 */
export type passportRequiredElement$Input = {
  readonly _: 'passportRequiredElement',
  /** List of Telegram Passport elements any of which is enough to provide */
  readonly suitable_elements?: ReadonlyArray<passportSuitableElement$Input>,
}

/** Contains information about a Telegram Passport authorization form that was requested */
export type passportAuthorizationForm = {
  _: 'passportAuthorizationForm',
  /** Unique identifier of the authorization form */
  id: number,
  /** Telegram Passport elements that must be provided to complete the form */
  required_elements: Array<passportRequiredElement>,
  /** URL for the privacy policy of the service; may be empty */
  privacy_policy_url: string,
}

/** Contains information about a Telegram Passport authorization form that was requested */
export type passportAuthorizationForm$Input = {
  readonly _: 'passportAuthorizationForm',
  /** Unique identifier of the authorization form */
  readonly id?: number,
  /** Telegram Passport elements that must be provided to complete the form */
  readonly required_elements?: ReadonlyArray<passportRequiredElement$Input>,
  /** URL for the privacy policy of the service; may be empty */
  readonly privacy_policy_url?: string,
}

/** Contains information about a Telegram Passport elements and corresponding errors */
export type passportElementsWithErrors = {
  _: 'passportElementsWithErrors',
  /** Telegram Passport elements */
  elements: Array<PassportElement>,
  /** Errors in the elements that are already available */
  errors: Array<passportElementError>,
}

/** Contains information about a Telegram Passport elements and corresponding errors */
export type passportElementsWithErrors$Input = {
  readonly _: 'passportElementsWithErrors',
  /** Telegram Passport elements */
  readonly elements?: ReadonlyArray<PassportElement$Input>,
  /** Errors in the elements that are already available */
  readonly errors?: ReadonlyArray<passportElementError$Input>,
}

/** Contains encrypted Telegram Passport data credentials */
export type encryptedCredentials = {
  _: 'encryptedCredentials',
  /** The encrypted credentials */
  data: string,
  /** The decrypted data hash */
  hash: string,
  /** Secret for data decryption, encrypted with the service's public key */
  secret: string,
}

/** Contains encrypted Telegram Passport data credentials */
export type encryptedCredentials$Input = {
  readonly _: 'encryptedCredentials',
  /** The encrypted credentials */
  readonly data?: string,
  /** The decrypted data hash */
  readonly hash?: string,
  /** Secret for data decryption, encrypted with the service's public key */
  readonly secret?: string,
}

/** Contains information about an encrypted Telegram Passport element; for bots only */
export type encryptedPassportElement = {
  _: 'encryptedPassportElement',
  /** Type of Telegram Passport element */
  type: PassportElementType,
  /** Encrypted JSON-encoded data about the user */
  data: string,
  /** The front side of an identity document */
  front_side: datedFile,
  /** The reverse side of an identity document; may be null */
  reverse_side: datedFile | undefined,
  /** Selfie with the document; may be null */
  selfie: datedFile | undefined,
  /** List of files containing a certified English translation of the document */
  translation: Array<datedFile>,
  /** List of attached files */
  files: Array<datedFile>,
  /** Unencrypted data, phone number or email address */
  value: string,
  /** Hash of the entire element */
  hash: string,
}

/** Contains information about an encrypted Telegram Passport element; for bots only */
export type encryptedPassportElement$Input = {
  readonly _: 'encryptedPassportElement',
  /** Type of Telegram Passport element */
  readonly type?: PassportElementType$Input,
  /** Encrypted JSON-encoded data about the user */
  readonly data?: string,
  /** The front side of an identity document */
  readonly front_side?: datedFile$Input,
  /** The reverse side of an identity document; may be null */
  readonly reverse_side?: datedFile$Input | undefined,
  /** Selfie with the document; may be null */
  readonly selfie?: datedFile$Input | undefined,
  /** List of files containing a certified English translation of the document */
  readonly translation?: ReadonlyArray<datedFile$Input>,
  /** List of attached files */
  readonly files?: ReadonlyArray<datedFile$Input>,
  /** Unencrypted data, phone number or email address */
  readonly value?: string,
  /** Hash of the entire element */
  readonly hash?: string,
}

/**
 * The element contains an error in an unspecified place. The error will be considered
 * resolved when new data is added
 */
export type inputPassportElementErrorSourceUnspecified = {
  _: 'inputPassportElementErrorSourceUnspecified',
  /** Current hash of the entire element */
  element_hash: string,
}

/**
 * The element contains an error in an unspecified place. The error will be considered
 * resolved when new data is added
 */
export type inputPassportElementErrorSourceUnspecified$Input = {
  readonly _: 'inputPassportElementErrorSourceUnspecified',
  /** Current hash of the entire element */
  readonly element_hash?: string,
}

/**
 * A data field contains an error. The error is considered resolved when the field's
 * value changes
 */
export type inputPassportElementErrorSourceDataField = {
  _: 'inputPassportElementErrorSourceDataField',
  /** Field name */
  field_name: string,
  /** Current data hash */
  data_hash: string,
}

/**
 * A data field contains an error. The error is considered resolved when the field's
 * value changes
 */
export type inputPassportElementErrorSourceDataField$Input = {
  readonly _: 'inputPassportElementErrorSourceDataField',
  /** Field name */
  readonly field_name?: string,
  /** Current data hash */
  readonly data_hash?: string,
}

/**
 * The front side of the document contains an error. The error is considered resolved
 * when the file with the front side of the document changes
 */
export type inputPassportElementErrorSourceFrontSide = {
  _: 'inputPassportElementErrorSourceFrontSide',
  /** Current hash of the file containing the front side */
  file_hash: string,
}

/**
 * The front side of the document contains an error. The error is considered resolved
 * when the file with the front side of the document changes
 */
export type inputPassportElementErrorSourceFrontSide$Input = {
  readonly _: 'inputPassportElementErrorSourceFrontSide',
  /** Current hash of the file containing the front side */
  readonly file_hash?: string,
}

/**
 * The reverse side of the document contains an error. The error is considered resolved
 * when the file with the reverse side of the document changes
 */
export type inputPassportElementErrorSourceReverseSide = {
  _: 'inputPassportElementErrorSourceReverseSide',
  /** Current hash of the file containing the reverse side */
  file_hash: string,
}

/**
 * The reverse side of the document contains an error. The error is considered resolved
 * when the file with the reverse side of the document changes
 */
export type inputPassportElementErrorSourceReverseSide$Input = {
  readonly _: 'inputPassportElementErrorSourceReverseSide',
  /** Current hash of the file containing the reverse side */
  readonly file_hash?: string,
}

/**
 * The selfie contains an error. The error is considered resolved when the file with
 * the selfie changes
 */
export type inputPassportElementErrorSourceSelfie = {
  _: 'inputPassportElementErrorSourceSelfie',
  /** Current hash of the file containing the selfie */
  file_hash: string,
}

/**
 * The selfie contains an error. The error is considered resolved when the file with
 * the selfie changes
 */
export type inputPassportElementErrorSourceSelfie$Input = {
  readonly _: 'inputPassportElementErrorSourceSelfie',
  /** Current hash of the file containing the selfie */
  readonly file_hash?: string,
}

/**
 * One of the files containing the translation of the document contains an error. The
 * error is considered resolved when the file with the translation changes
 */
export type inputPassportElementErrorSourceTranslationFile = {
  _: 'inputPassportElementErrorSourceTranslationFile',
  /** Current hash of the file containing the translation */
  file_hash: string,
}

/**
 * One of the files containing the translation of the document contains an error. The
 * error is considered resolved when the file with the translation changes
 */
export type inputPassportElementErrorSourceTranslationFile$Input = {
  readonly _: 'inputPassportElementErrorSourceTranslationFile',
  /** Current hash of the file containing the translation */
  readonly file_hash?: string,
}

/**
 * The translation of the document contains an error. The error is considered resolved
 * when the list of files changes
 */
export type inputPassportElementErrorSourceTranslationFiles = {
  _: 'inputPassportElementErrorSourceTranslationFiles',
  /** Current hashes of all files with the translation */
  file_hashes: Array<string>,
}

/**
 * The translation of the document contains an error. The error is considered resolved
 * when the list of files changes
 */
export type inputPassportElementErrorSourceTranslationFiles$Input = {
  readonly _: 'inputPassportElementErrorSourceTranslationFiles',
  /** Current hashes of all files with the translation */
  readonly file_hashes?: ReadonlyArray<string>,
}

/** The file contains an error. The error is considered resolved when the file changes */
export type inputPassportElementErrorSourceFile = {
  _: 'inputPassportElementErrorSourceFile',
  /** Current hash of the file which has the error */
  file_hash: string,
}

/** The file contains an error. The error is considered resolved when the file changes */
export type inputPassportElementErrorSourceFile$Input = {
  readonly _: 'inputPassportElementErrorSourceFile',
  /** Current hash of the file which has the error */
  readonly file_hash?: string,
}

/**
 * The list of attached files contains an error. The error is considered resolved when
 * the file list changes
 */
export type inputPassportElementErrorSourceFiles = {
  _: 'inputPassportElementErrorSourceFiles',
  /** Current hashes of all attached files */
  file_hashes: Array<string>,
}

/**
 * The list of attached files contains an error. The error is considered resolved when
 * the file list changes
 */
export type inputPassportElementErrorSourceFiles$Input = {
  readonly _: 'inputPassportElementErrorSourceFiles',
  /** Current hashes of all attached files */
  readonly file_hashes?: ReadonlyArray<string>,
}

/** Contains the description of an error in a Telegram Passport element; for bots only */
export type inputPassportElementError = {
  _: 'inputPassportElementError',
  /** Type of Telegram Passport element that has the error */
  type: PassportElementType,
  /** Error message */
  message: string,
  /** Error source */
  source: InputPassportElementErrorSource,
}

/** Contains the description of an error in a Telegram Passport element; for bots only */
export type inputPassportElementError$Input = {
  readonly _: 'inputPassportElementError',
  /** Type of Telegram Passport element that has the error */
  readonly type?: PassportElementType$Input,
  /** Error message */
  readonly message?: string,
  /** Error source */
  readonly source?: InputPassportElementErrorSource$Input,
}

/** A text message */
export type messageText = {
  _: 'messageText',
  /** Text of the message */
  text: formattedText,
  /** A preview of the web page that's mentioned in the text; may be null */
  web_page: webPage | undefined,
}

/** A text message */
export type messageText$Input = {
  readonly _: 'messageText',
  /** Text of the message */
  readonly text?: formattedText$Input,
  /** A preview of the web page that's mentioned in the text; may be null */
  readonly web_page?: webPage$Input | undefined,
}

/** An animation message (GIF-style). */
export type messageAnimation = {
  _: 'messageAnimation',
  /** The animation description */
  animation: animation,
  /** Animation caption */
  caption: formattedText,
  /**
   * True, if the animation thumbnail must be blurred and the animation must be shown
   * only while tapped
   */
  is_secret: boolean,
}

/** An animation message (GIF-style). */
export type messageAnimation$Input = {
  readonly _: 'messageAnimation',
  /** The animation description */
  readonly animation?: animation$Input,
  /** Animation caption */
  readonly caption?: formattedText$Input,
  /**
   * True, if the animation thumbnail must be blurred and the animation must be shown
   * only while tapped
   */
  readonly is_secret?: boolean,
}

/** An audio message */
export type messageAudio = {
  _: 'messageAudio',
  /** The audio description */
  audio: audio,
  /** Audio caption */
  caption: formattedText,
}

/** An audio message */
export type messageAudio$Input = {
  readonly _: 'messageAudio',
  /** The audio description */
  readonly audio?: audio$Input,
  /** Audio caption */
  readonly caption?: formattedText$Input,
}

/** A document message (general file) */
export type messageDocument = {
  _: 'messageDocument',
  /** The document description */
  document: document,
  /** Document caption */
  caption: formattedText,
}

/** A document message (general file) */
export type messageDocument$Input = {
  readonly _: 'messageDocument',
  /** The document description */
  readonly document?: document$Input,
  /** Document caption */
  readonly caption?: formattedText$Input,
}

/** A photo message */
export type messagePhoto = {
  _: 'messagePhoto',
  /** The photo description */
  photo: photo,
  /** Photo caption */
  caption: formattedText,
  /** True, if the photo must be blurred and must be shown only while tapped */
  is_secret: boolean,
}

/** A photo message */
export type messagePhoto$Input = {
  readonly _: 'messagePhoto',
  /** The photo description */
  readonly photo?: photo$Input,
  /** Photo caption */
  readonly caption?: formattedText$Input,
  /** True, if the photo must be blurred and must be shown only while tapped */
  readonly is_secret?: boolean,
}

/** An expired photo message (self-destructed after TTL has elapsed) */
export type messageExpiredPhoto = {
  _: 'messageExpiredPhoto',
}

/** An expired photo message (self-destructed after TTL has elapsed) */
export type messageExpiredPhoto$Input = {
  readonly _: 'messageExpiredPhoto',
}

/** A sticker message */
export type messageSticker = {
  _: 'messageSticker',
  /** The sticker description */
  sticker: sticker,
}

/** A sticker message */
export type messageSticker$Input = {
  readonly _: 'messageSticker',
  /** The sticker description */
  readonly sticker?: sticker$Input,
}

/** A video message */
export type messageVideo = {
  _: 'messageVideo',
  /** The video description */
  video: video,
  /** Video caption */
  caption: formattedText,
  /**
   * True, if the video thumbnail must be blurred and the video must be shown only while
   * tapped
   */
  is_secret: boolean,
}

/** A video message */
export type messageVideo$Input = {
  readonly _: 'messageVideo',
  /** The video description */
  readonly video?: video$Input,
  /** Video caption */
  readonly caption?: formattedText$Input,
  /**
   * True, if the video thumbnail must be blurred and the video must be shown only while
   * tapped
   */
  readonly is_secret?: boolean,
}

/** An expired video message (self-destructed after TTL has elapsed) */
export type messageExpiredVideo = {
  _: 'messageExpiredVideo',
}

/** An expired video message (self-destructed after TTL has elapsed) */
export type messageExpiredVideo$Input = {
  readonly _: 'messageExpiredVideo',
}

/** A video note message */
export type messageVideoNote = {
  _: 'messageVideoNote',
  /** The video note description */
  video_note: videoNote,
  /** True, if at least one of the recipients has viewed the video note */
  is_viewed: boolean,
  /**
   * True, if the video note thumbnail must be blurred and the video note must be shown
   * only while tapped
   */
  is_secret: boolean,
}

/** A video note message */
export type messageVideoNote$Input = {
  readonly _: 'messageVideoNote',
  /** The video note description */
  readonly video_note?: videoNote$Input,
  /** True, if at least one of the recipients has viewed the video note */
  readonly is_viewed?: boolean,
  /**
   * True, if the video note thumbnail must be blurred and the video note must be shown
   * only while tapped
   */
  readonly is_secret?: boolean,
}

/** A voice note message */
export type messageVoiceNote = {
  _: 'messageVoiceNote',
  /** The voice note description */
  voice_note: voiceNote,
  /** Voice note caption */
  caption: formattedText,
  /** True, if at least one of the recipients has listened to the voice note */
  is_listened: boolean,
}

/** A voice note message */
export type messageVoiceNote$Input = {
  readonly _: 'messageVoiceNote',
  /** The voice note description */
  readonly voice_note?: voiceNote$Input,
  /** Voice note caption */
  readonly caption?: formattedText$Input,
  /** True, if at least one of the recipients has listened to the voice note */
  readonly is_listened?: boolean,
}

/** A message with a location */
export type messageLocation = {
  _: 'messageLocation',
  /** The location description */
  location: location,
  /**
   * Time relative to the message send date, for which the location can be updated, in
   * seconds
   */
  live_period: number,
  /**
   * Left time for which the location can be updated, in seconds. updateMessageContent
   * is not sent when this field changes
   */
  expires_in: number,
  /**
   * For live locations, a direction in which the location moves, in degrees; 1-360. If
   * 0 the direction is unknown
   */
  heading: number,
  /**
   * For live locations, a maximum distance to another chat member for proximity alerts,
   * in meters (0-100000). 0 if the notification is disabled. Available only for the message
   * sender
   */
  proximity_alert_radius: number,
}

/** A message with a location */
export type messageLocation$Input = {
  readonly _: 'messageLocation',
  /** The location description */
  readonly location?: location$Input,
  /**
   * Time relative to the message send date, for which the location can be updated, in
   * seconds
   */
  readonly live_period?: number,
  /**
   * Left time for which the location can be updated, in seconds. updateMessageContent
   * is not sent when this field changes
   */
  readonly expires_in?: number,
  /**
   * For live locations, a direction in which the location moves, in degrees; 1-360. If
   * 0 the direction is unknown
   */
  readonly heading?: number,
  /**
   * For live locations, a maximum distance to another chat member for proximity alerts,
   * in meters (0-100000). 0 if the notification is disabled. Available only for the message
   * sender
   */
  readonly proximity_alert_radius?: number,
}

/** A message with information about a venue */
export type messageVenue = {
  _: 'messageVenue',
  /** The venue description */
  venue: venue,
}

/** A message with information about a venue */
export type messageVenue$Input = {
  readonly _: 'messageVenue',
  /** The venue description */
  readonly venue?: venue$Input,
}

/** A message with a user contact */
export type messageContact = {
  _: 'messageContact',
  /** The contact description */
  contact: contact,
}

/** A message with a user contact */
export type messageContact$Input = {
  readonly _: 'messageContact',
  /** The contact description */
  readonly contact?: contact$Input,
}

/** A message with an animated emoji */
export type messageAnimatedEmoji = {
  _: 'messageAnimatedEmoji',
  /** The animated emoji */
  animated_emoji: animatedEmoji,
  /** The corresponding emoji */
  emoji: string,
}

/** A message with an animated emoji */
export type messageAnimatedEmoji$Input = {
  readonly _: 'messageAnimatedEmoji',
  /** The animated emoji */
  readonly animated_emoji?: animatedEmoji$Input,
  /** The corresponding emoji */
  readonly emoji?: string,
}

/** A dice message. The dice value is randomly generated by the server */
export type messageDice = {
  _: 'messageDice',
  /**
   * The animated stickers with the initial dice animation; may be null if unknown. updateMessageContent
   * will be sent when the sticker became known
   */
  initial_state: DiceStickers | undefined,
  /**
   * The animated stickers with the final dice animation; may be null if unknown. updateMessageContent
   * will be sent when the sticker became known
   */
  final_state: DiceStickers | undefined,
  /** Emoji on which the dice throw animation is based */
  emoji: string,
  /** The dice value. If the value is 0, the dice don't have final state yet */
  value: number,
  /**
   * Number of frame after which a success animation like a shower of confetti needs to
   * be shown on updateMessageSendSucceeded
   */
  success_animation_frame_number: number,
}

/** A dice message. The dice value is randomly generated by the server */
export type messageDice$Input = {
  readonly _: 'messageDice',
  /**
   * The animated stickers with the initial dice animation; may be null if unknown. updateMessageContent
   * will be sent when the sticker became known
   */
  readonly initial_state?: DiceStickers$Input | undefined,
  /**
   * The animated stickers with the final dice animation; may be null if unknown. updateMessageContent
   * will be sent when the sticker became known
   */
  readonly final_state?: DiceStickers$Input | undefined,
  /** Emoji on which the dice throw animation is based */
  readonly emoji?: string,
  /** The dice value. If the value is 0, the dice don't have final state yet */
  readonly value?: number,
  /**
   * Number of frame after which a success animation like a shower of confetti needs to
   * be shown on updateMessageSendSucceeded
   */
  readonly success_animation_frame_number?: number,
}

/** A message with a game */
export type messageGame = {
  _: 'messageGame',
  /** The game description */
  game: game,
}

/** A message with a game */
export type messageGame$Input = {
  readonly _: 'messageGame',
  /** The game description */
  readonly game?: game$Input,
}

/** A message with a poll */
export type messagePoll = {
  _: 'messagePoll',
  /** The poll description */
  poll: poll,
}

/** A message with a poll */
export type messagePoll$Input = {
  readonly _: 'messagePoll',
  /** The poll description */
  readonly poll?: poll$Input,
}

/** A message with an invoice from a bot */
export type messageInvoice = {
  _: 'messageInvoice',
  /** Product title */
  title: string,
  /** Product description */
  description: string,
  /** Product photo; may be null */
  photo: photo | undefined,
  /** Currency for the product price */
  currency: string,
  /** Product total price in the smallest units of the currency */
  total_amount: number,
  /** Unique invoice bot start_parameter. To share an invoice use the URL https://t.me/{bot_username}?start={start_parameter} */
  start_parameter: string,
  /** True, if the invoice is a test invoice */
  is_test: boolean,
  /** True, if the shipping address must be specified */
  need_shipping_address: boolean,
  /** The identifier of the message with the receipt, after the product has been purchased */
  receipt_message_id: number,
}

/** A message with an invoice from a bot */
export type messageInvoice$Input = {
  readonly _: 'messageInvoice',
  /** Product title */
  readonly title?: string,
  /** Product description */
  readonly description?: string,
  /** Product photo; may be null */
  readonly photo?: photo$Input | undefined,
  /** Currency for the product price */
  readonly currency?: string,
  /** Product total price in the smallest units of the currency */
  readonly total_amount?: number,
  /** Unique invoice bot start_parameter. To share an invoice use the URL https://t.me/{bot_username}?start={start_parameter} */
  readonly start_parameter?: string,
  /** True, if the invoice is a test invoice */
  readonly is_test?: boolean,
  /** True, if the shipping address must be specified */
  readonly need_shipping_address?: boolean,
  /** The identifier of the message with the receipt, after the product has been purchased */
  readonly receipt_message_id?: number,
}

/** A message with information about an ended call */
export type messageCall = {
  _: 'messageCall',
  /** True, if the call was a video call */
  is_video: boolean,
  /** Reason why the call was discarded */
  discard_reason: CallDiscardReason,
  /** Call duration, in seconds */
  duration: number,
}

/** A message with information about an ended call */
export type messageCall$Input = {
  readonly _: 'messageCall',
  /** True, if the call was a video call */
  readonly is_video?: boolean,
  /** Reason why the call was discarded */
  readonly discard_reason?: CallDiscardReason$Input,
  /** Call duration, in seconds */
  readonly duration?: number,
}

/** A new video chat was scheduled */
export type messageVideoChatScheduled = {
  _: 'messageVideoChatScheduled',
  /** Identifier of the video chat. The video chat can be received through the method getGroupCall */
  group_call_id: number,
  /**
   * Point in time (Unix timestamp) when the group call is supposed to be started by an
   * administrator
   */
  start_date: number,
}

/** A new video chat was scheduled */
export type messageVideoChatScheduled$Input = {
  readonly _: 'messageVideoChatScheduled',
  /** Identifier of the video chat. The video chat can be received through the method getGroupCall */
  readonly group_call_id?: number,
  /**
   * Point in time (Unix timestamp) when the group call is supposed to be started by an
   * administrator
   */
  readonly start_date?: number,
}

/** A newly created video chat */
export type messageVideoChatStarted = {
  _: 'messageVideoChatStarted',
  /** Identifier of the video chat. The video chat can be received through the method getGroupCall */
  group_call_id: number,
}

/** A newly created video chat */
export type messageVideoChatStarted$Input = {
  readonly _: 'messageVideoChatStarted',
  /** Identifier of the video chat. The video chat can be received through the method getGroupCall */
  readonly group_call_id?: number,
}

/** A message with information about an ended video chat */
export type messageVideoChatEnded = {
  _: 'messageVideoChatEnded',
  /** Call duration, in seconds */
  duration: number,
}

/** A message with information about an ended video chat */
export type messageVideoChatEnded$Input = {
  readonly _: 'messageVideoChatEnded',
  /** Call duration, in seconds */
  readonly duration?: number,
}

/** A message with information about an invite to a video chat */
export type messageInviteVideoChatParticipants = {
  _: 'messageInviteVideoChatParticipants',
  /** Identifier of the video chat. The video chat can be received through the method getGroupCall */
  group_call_id: number,
  /** Invited user identifiers */
  user_ids: Array<number>,
}

/** A message with information about an invite to a video chat */
export type messageInviteVideoChatParticipants$Input = {
  readonly _: 'messageInviteVideoChatParticipants',
  /** Identifier of the video chat. The video chat can be received through the method getGroupCall */
  readonly group_call_id?: number,
  /** Invited user identifiers */
  readonly user_ids?: ReadonlyArray<number>,
}

/** A newly created basic group */
export type messageBasicGroupChatCreate = {
  _: 'messageBasicGroupChatCreate',
  /** Title of the basic group */
  title: string,
  /** User identifiers of members in the basic group */
  member_user_ids: Array<number>,
}

/** A newly created basic group */
export type messageBasicGroupChatCreate$Input = {
  readonly _: 'messageBasicGroupChatCreate',
  /** Title of the basic group */
  readonly title?: string,
  /** User identifiers of members in the basic group */
  readonly member_user_ids?: ReadonlyArray<number>,
}

/** A newly created supergroup or channel */
export type messageSupergroupChatCreate = {
  _: 'messageSupergroupChatCreate',
  /** Title of the supergroup or channel */
  title: string,
}

/** A newly created supergroup or channel */
export type messageSupergroupChatCreate$Input = {
  readonly _: 'messageSupergroupChatCreate',
  /** Title of the supergroup or channel */
  readonly title?: string,
}

/** An updated chat title */
export type messageChatChangeTitle = {
  _: 'messageChatChangeTitle',
  /** New chat title */
  title: string,
}

/** An updated chat title */
export type messageChatChangeTitle$Input = {
  readonly _: 'messageChatChangeTitle',
  /** New chat title */
  readonly title?: string,
}

/** An updated chat photo */
export type messageChatChangePhoto = {
  _: 'messageChatChangePhoto',
  /** New chat photo */
  photo: chatPhoto,
}

/** An updated chat photo */
export type messageChatChangePhoto$Input = {
  readonly _: 'messageChatChangePhoto',
  /** New chat photo */
  readonly photo?: chatPhoto$Input,
}

/** A deleted chat photo */
export type messageChatDeletePhoto = {
  _: 'messageChatDeletePhoto',
}

/** A deleted chat photo */
export type messageChatDeletePhoto$Input = {
  readonly _: 'messageChatDeletePhoto',
}

/** New chat members were added */
export type messageChatAddMembers = {
  _: 'messageChatAddMembers',
  /** User identifiers of the new members */
  member_user_ids: Array<number>,
}

/** New chat members were added */
export type messageChatAddMembers$Input = {
  readonly _: 'messageChatAddMembers',
  /** User identifiers of the new members */
  readonly member_user_ids?: ReadonlyArray<number>,
}

/** A new member joined the chat via an invite link */
export type messageChatJoinByLink = {
  _: 'messageChatJoinByLink',
}

/** A new member joined the chat via an invite link */
export type messageChatJoinByLink$Input = {
  readonly _: 'messageChatJoinByLink',
}

/** A new member was accepted to the chat by an administrator */
export type messageChatJoinByRequest = {
  _: 'messageChatJoinByRequest',
}

/** A new member was accepted to the chat by an administrator */
export type messageChatJoinByRequest$Input = {
  readonly _: 'messageChatJoinByRequest',
}

/** A chat member was deleted */
export type messageChatDeleteMember = {
  _: 'messageChatDeleteMember',
  /** User identifier of the deleted chat member */
  user_id: number,
}

/** A chat member was deleted */
export type messageChatDeleteMember$Input = {
  readonly _: 'messageChatDeleteMember',
  /** User identifier of the deleted chat member */
  readonly user_id?: number,
}

/** A basic group was upgraded to a supergroup and was deactivated as the result */
export type messageChatUpgradeTo = {
  _: 'messageChatUpgradeTo',
  /** Identifier of the supergroup to which the basic group was upgraded */
  supergroup_id: number,
}

/** A basic group was upgraded to a supergroup and was deactivated as the result */
export type messageChatUpgradeTo$Input = {
  readonly _: 'messageChatUpgradeTo',
  /** Identifier of the supergroup to which the basic group was upgraded */
  readonly supergroup_id?: number,
}

/** A supergroup has been created from a basic group */
export type messageChatUpgradeFrom = {
  _: 'messageChatUpgradeFrom',
  /** Title of the newly created supergroup */
  title: string,
  /** The identifier of the original basic group */
  basic_group_id: number,
}

/** A supergroup has been created from a basic group */
export type messageChatUpgradeFrom$Input = {
  readonly _: 'messageChatUpgradeFrom',
  /** Title of the newly created supergroup */
  readonly title?: string,
  /** The identifier of the original basic group */
  readonly basic_group_id?: number,
}

/** A message has been pinned */
export type messagePinMessage = {
  _: 'messagePinMessage',
  /** Identifier of the pinned message, can be an identifier of a deleted message or 0 */
  message_id: number,
}

/** A message has been pinned */
export type messagePinMessage$Input = {
  readonly _: 'messagePinMessage',
  /** Identifier of the pinned message, can be an identifier of a deleted message or 0 */
  readonly message_id?: number,
}

/** A screenshot of a message in the chat has been taken */
export type messageScreenshotTaken = {
  _: 'messageScreenshotTaken',
}

/** A screenshot of a message in the chat has been taken */
export type messageScreenshotTaken$Input = {
  readonly _: 'messageScreenshotTaken',
}

/** A theme in the chat has been changed */
export type messageChatSetTheme = {
  _: 'messageChatSetTheme',
  /**
   * If non-empty, name of a new theme, set for the chat. Otherwise chat theme was reset
   * to the default one
   */
  theme_name: string,
}

/** A theme in the chat has been changed */
export type messageChatSetTheme$Input = {
  readonly _: 'messageChatSetTheme',
  /**
   * If non-empty, name of a new theme, set for the chat. Otherwise chat theme was reset
   * to the default one
   */
  readonly theme_name?: string,
}

/** The TTL (Time To Live) setting for messages in the chat has been changed */
export type messageChatSetTtl = {
  _: 'messageChatSetTtl',
  /** New message TTL */
  ttl: number,
}

/** The TTL (Time To Live) setting for messages in the chat has been changed */
export type messageChatSetTtl$Input = {
  readonly _: 'messageChatSetTtl',
  /** New message TTL */
  readonly ttl?: number,
}

/** A non-standard action has happened in the chat */
export type messageCustomServiceAction = {
  _: 'messageCustomServiceAction',
  /** Message text to be shown in the chat */
  text: string,
}

/** A non-standard action has happened in the chat */
export type messageCustomServiceAction$Input = {
  readonly _: 'messageCustomServiceAction',
  /** Message text to be shown in the chat */
  readonly text?: string,
}

/** A new high score was achieved in a game */
export type messageGameScore = {
  _: 'messageGameScore',
  /** Identifier of the message with the game, can be an identifier of a deleted message */
  game_message_id: number,
  /**
   * Identifier of the game; may be different from the games presented in the message
   * with the game
   */
  game_id: number | string,
  /** New score */
  score: number,
}

/** A new high score was achieved in a game */
export type messageGameScore$Input = {
  readonly _: 'messageGameScore',
  /** Identifier of the message with the game, can be an identifier of a deleted message */
  readonly game_message_id?: number,
  /**
   * Identifier of the game; may be different from the games presented in the message
   * with the game
   */
  readonly game_id?: number | string,
  /** New score */
  readonly score?: number,
}

/** A payment has been completed */
export type messagePaymentSuccessful = {
  _: 'messagePaymentSuccessful',
  /** Identifier of the chat, containing the corresponding invoice message; 0 if unknown */
  invoice_chat_id: number,
  /**
   * Identifier of the message with the corresponding invoice; can be an identifier of
   * a deleted message
   */
  invoice_message_id: number,
  /** Currency for the price of the product */
  currency: string,
  /** Total price for the product, in the smallest units of the currency */
  total_amount: number,
}

/** A payment has been completed */
export type messagePaymentSuccessful$Input = {
  readonly _: 'messagePaymentSuccessful',
  /** Identifier of the chat, containing the corresponding invoice message; 0 if unknown */
  readonly invoice_chat_id?: number,
  /**
   * Identifier of the message with the corresponding invoice; can be an identifier of
   * a deleted message
   */
  readonly invoice_message_id?: number,
  /** Currency for the price of the product */
  readonly currency?: string,
  /** Total price for the product, in the smallest units of the currency */
  readonly total_amount?: number,
}

/** A payment has been completed; for bots only */
export type messagePaymentSuccessfulBot = {
  _: 'messagePaymentSuccessfulBot',
  /** Currency for price of the product */
  currency: string,
  /** Total price for the product, in the smallest units of the currency */
  total_amount: number,
  /** Invoice payload */
  invoice_payload: string,
  /** Identifier of the shipping option chosen by the user; may be empty if not applicable */
  shipping_option_id: string,
  /** Information about the order; may be null */
  order_info: orderInfo | undefined,
  /** Telegram payment identifier */
  telegram_payment_charge_id: string,
  /** Provider payment identifier */
  provider_payment_charge_id: string,
}

/** A payment has been completed; for bots only */
export type messagePaymentSuccessfulBot$Input = {
  readonly _: 'messagePaymentSuccessfulBot',
  /** Currency for price of the product */
  readonly currency?: string,
  /** Total price for the product, in the smallest units of the currency */
  readonly total_amount?: number,
  /** Invoice payload */
  readonly invoice_payload?: string,
  /** Identifier of the shipping option chosen by the user; may be empty if not applicable */
  readonly shipping_option_id?: string,
  /** Information about the order; may be null */
  readonly order_info?: orderInfo$Input | undefined,
  /** Telegram payment identifier */
  readonly telegram_payment_charge_id?: string,
  /** Provider payment identifier */
  readonly provider_payment_charge_id?: string,
}

/** A contact has registered with Telegram */
export type messageContactRegistered = {
  _: 'messageContactRegistered',
}

/** A contact has registered with Telegram */
export type messageContactRegistered$Input = {
  readonly _: 'messageContactRegistered',
}

/**
 * The current user has connected a website by logging in using Telegram Login Widget
 * on it
 */
export type messageWebsiteConnected = {
  _: 'messageWebsiteConnected',
  /** Domain name of the connected website */
  domain_name: string,
}

/**
 * The current user has connected a website by logging in using Telegram Login Widget
 * on it
 */
export type messageWebsiteConnected$Input = {
  readonly _: 'messageWebsiteConnected',
  /** Domain name of the connected website */
  readonly domain_name?: string,
}

/** Telegram Passport data has been sent */
export type messagePassportDataSent = {
  _: 'messagePassportDataSent',
  /** List of Telegram Passport element types sent */
  types: Array<PassportElementType>,
}

/** Telegram Passport data has been sent */
export type messagePassportDataSent$Input = {
  readonly _: 'messagePassportDataSent',
  /** List of Telegram Passport element types sent */
  readonly types?: ReadonlyArray<PassportElementType$Input>,
}

/** Telegram Passport data has been received; for bots only */
export type messagePassportDataReceived = {
  _: 'messagePassportDataReceived',
  /** List of received Telegram Passport elements */
  elements: Array<encryptedPassportElement>,
  /** Encrypted data credentials */
  credentials: encryptedCredentials,
}

/** Telegram Passport data has been received; for bots only */
export type messagePassportDataReceived$Input = {
  readonly _: 'messagePassportDataReceived',
  /** List of received Telegram Passport elements */
  readonly elements?: ReadonlyArray<encryptedPassportElement$Input>,
  /** Encrypted data credentials */
  readonly credentials?: encryptedCredentials$Input,
}

/** A user in the chat came within proximity alert range */
export type messageProximityAlertTriggered = {
  _: 'messageProximityAlertTriggered',
  /** The identifier of a user or chat that triggered the proximity alert */
  traveler_id: MessageSender,
  /** The identifier of a user or chat that subscribed for the proximity alert */
  watcher_id: MessageSender,
  /** The distance between the users */
  distance: number,
}

/** A user in the chat came within proximity alert range */
export type messageProximityAlertTriggered$Input = {
  readonly _: 'messageProximityAlertTriggered',
  /** The identifier of a user or chat that triggered the proximity alert */
  readonly traveler_id?: MessageSender$Input,
  /** The identifier of a user or chat that subscribed for the proximity alert */
  readonly watcher_id?: MessageSender$Input,
  /** The distance between the users */
  readonly distance?: number,
}

/** Message content that is not supported in the current TDLib version */
export type messageUnsupported = {
  _: 'messageUnsupported',
}

/** Message content that is not supported in the current TDLib version */
export type messageUnsupported$Input = {
  readonly _: 'messageUnsupported',
}

/** A mention of a user by their username */
export type textEntityTypeMention = {
  _: 'textEntityTypeMention',
}

/** A mention of a user by their username */
export type textEntityTypeMention$Input = {
  readonly _: 'textEntityTypeMention',
}

/** A hashtag text, beginning with "#" */
export type textEntityTypeHashtag = {
  _: 'textEntityTypeHashtag',
}

/** A hashtag text, beginning with "#" */
export type textEntityTypeHashtag$Input = {
  readonly _: 'textEntityTypeHashtag',
}

/**
 * A cashtag text, beginning with "$" and consisting of capital English letters (e.g.,
 * "$USD")
 */
export type textEntityTypeCashtag = {
  _: 'textEntityTypeCashtag',
}

/**
 * A cashtag text, beginning with "$" and consisting of capital English letters (e.g.,
 * "$USD")
 */
export type textEntityTypeCashtag$Input = {
  readonly _: 'textEntityTypeCashtag',
}

/** A bot command, beginning with "/" */
export type textEntityTypeBotCommand = {
  _: 'textEntityTypeBotCommand',
}

/** A bot command, beginning with "/" */
export type textEntityTypeBotCommand$Input = {
  readonly _: 'textEntityTypeBotCommand',
}

/** An HTTP URL */
export type textEntityTypeUrl = {
  _: 'textEntityTypeUrl',
}

/** An HTTP URL */
export type textEntityTypeUrl$Input = {
  readonly _: 'textEntityTypeUrl',
}

/** An email address */
export type textEntityTypeEmailAddress = {
  _: 'textEntityTypeEmailAddress',
}

/** An email address */
export type textEntityTypeEmailAddress$Input = {
  readonly _: 'textEntityTypeEmailAddress',
}

/** A phone number */
export type textEntityTypePhoneNumber = {
  _: 'textEntityTypePhoneNumber',
}

/** A phone number */
export type textEntityTypePhoneNumber$Input = {
  readonly _: 'textEntityTypePhoneNumber',
}

/**
 * A bank card number. The getBankCardInfo method can be used to get information about
 * the bank card
 */
export type textEntityTypeBankCardNumber = {
  _: 'textEntityTypeBankCardNumber',
}

/**
 * A bank card number. The getBankCardInfo method can be used to get information about
 * the bank card
 */
export type textEntityTypeBankCardNumber$Input = {
  readonly _: 'textEntityTypeBankCardNumber',
}

/** A bold text */
export type textEntityTypeBold = {
  _: 'textEntityTypeBold',
}

/** A bold text */
export type textEntityTypeBold$Input = {
  readonly _: 'textEntityTypeBold',
}

/** An italic text */
export type textEntityTypeItalic = {
  _: 'textEntityTypeItalic',
}

/** An italic text */
export type textEntityTypeItalic$Input = {
  readonly _: 'textEntityTypeItalic',
}

/** An underlined text */
export type textEntityTypeUnderline = {
  _: 'textEntityTypeUnderline',
}

/** An underlined text */
export type textEntityTypeUnderline$Input = {
  readonly _: 'textEntityTypeUnderline',
}

/** A strikethrough text */
export type textEntityTypeStrikethrough = {
  _: 'textEntityTypeStrikethrough',
}

/** A strikethrough text */
export type textEntityTypeStrikethrough$Input = {
  readonly _: 'textEntityTypeStrikethrough',
}

/** Text that must be formatted as if inside a code HTML tag */
export type textEntityTypeCode = {
  _: 'textEntityTypeCode',
}

/** Text that must be formatted as if inside a code HTML tag */
export type textEntityTypeCode$Input = {
  readonly _: 'textEntityTypeCode',
}

/** Text that must be formatted as if inside a pre HTML tag */
export type textEntityTypePre = {
  _: 'textEntityTypePre',
}

/** Text that must be formatted as if inside a pre HTML tag */
export type textEntityTypePre$Input = {
  readonly _: 'textEntityTypePre',
}

/** Text that must be formatted as if inside pre, and code HTML tags */
export type textEntityTypePreCode = {
  _: 'textEntityTypePreCode',
  /** Programming language of the code; as defined by the sender */
  language: string,
}

/** Text that must be formatted as if inside pre, and code HTML tags */
export type textEntityTypePreCode$Input = {
  readonly _: 'textEntityTypePreCode',
  /** Programming language of the code; as defined by the sender */
  readonly language?: string,
}

/** A text description shown instead of a raw URL */
export type textEntityTypeTextUrl = {
  _: 'textEntityTypeTextUrl',
  /** HTTP or tg:// URL to be opened when the link is clicked */
  url: string,
}

/** A text description shown instead of a raw URL */
export type textEntityTypeTextUrl$Input = {
  readonly _: 'textEntityTypeTextUrl',
  /** HTTP or tg:// URL to be opened when the link is clicked */
  readonly url?: string,
}

/** A text shows instead of a raw mention of the user (e.g., when the user has no username) */
export type textEntityTypeMentionName = {
  _: 'textEntityTypeMentionName',
  /** Identifier of the mentioned user */
  user_id: number,
}

/** A text shows instead of a raw mention of the user (e.g., when the user has no username) */
export type textEntityTypeMentionName$Input = {
  readonly _: 'textEntityTypeMentionName',
  /** Identifier of the mentioned user */
  readonly user_id?: number,
}

/** A media timestamp */
export type textEntityTypeMediaTimestamp = {
  _: 'textEntityTypeMediaTimestamp',
  /**
   * Timestamp from which a video/audio/video note/voice note playing must start, in seconds.
   * The media can be in the content or the web page preview of the current message, or
   * in the same places in the replied message
   */
  media_timestamp: number,
}

/** A media timestamp */
export type textEntityTypeMediaTimestamp$Input = {
  readonly _: 'textEntityTypeMediaTimestamp',
  /**
   * Timestamp from which a video/audio/video note/voice note playing must start, in seconds.
   * The media can be in the content or the web page preview of the current message, or
   * in the same places in the replied message
   */
  readonly media_timestamp?: number,
}

/**
 * A thumbnail to be sent along with a file; must be in JPEG or WEBP format for stickers,
 * and less than 200 KB in size
 */
export type inputThumbnail = {
  _: 'inputThumbnail',
  /** Thumbnail file to send. Sending thumbnails by file_id is currently not supported */
  thumbnail: InputFile,
  /** Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown */
  width: number,
  /** Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown */
  height: number,
}

/**
 * A thumbnail to be sent along with a file; must be in JPEG or WEBP format for stickers,
 * and less than 200 KB in size
 */
export type inputThumbnail$Input = {
  readonly _: 'inputThumbnail',
  /** Thumbnail file to send. Sending thumbnails by file_id is currently not supported */
  readonly thumbnail?: InputFile$Input,
  /** Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown */
  readonly width?: number,
  /** Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown */
  readonly height?: number,
}

/** The message will be sent at the specified date */
export type messageSchedulingStateSendAtDate = {
  _: 'messageSchedulingStateSendAtDate',
  /** Date the message will be sent. The date must be within 367 days in the future */
  send_date: number,
}

/** The message will be sent at the specified date */
export type messageSchedulingStateSendAtDate$Input = {
  readonly _: 'messageSchedulingStateSendAtDate',
  /** Date the message will be sent. The date must be within 367 days in the future */
  readonly send_date?: number,
}

/**
 * The message will be sent when the peer will be online. Applicable to private chats
 * only and when the exact online status of the peer is known
 */
export type messageSchedulingStateSendWhenOnline = {
  _: 'messageSchedulingStateSendWhenOnline',
}

/**
 * The message will be sent when the peer will be online. Applicable to private chats
 * only and when the exact online status of the peer is known
 */
export type messageSchedulingStateSendWhenOnline$Input = {
  readonly _: 'messageSchedulingStateSendWhenOnline',
}

/** Options to be used when a message is sent */
export type messageSendOptions = {
  _: 'messageSendOptions',
  /** Pass true to disable notification for the message */
  disable_notification: boolean,
  /** Pass true if the message is sent from the background */
  from_background: boolean,
  /**
   * Message scheduling state; pass null to send message immediately. Messages sent to
   * a secret chat, live location messages and self-destructing messages can't be scheduled
   */
  scheduling_state: MessageSchedulingState,
}

/** Options to be used when a message is sent */
export type messageSendOptions$Input = {
  readonly _: 'messageSendOptions',
  /** Pass true to disable notification for the message */
  readonly disable_notification?: boolean,
  /** Pass true if the message is sent from the background */
  readonly from_background?: boolean,
  /**
   * Message scheduling state; pass null to send message immediately. Messages sent to
   * a secret chat, live location messages and self-destructing messages can't be scheduled
   */
  readonly scheduling_state?: MessageSchedulingState$Input,
}

/**
 * Options to be used when a message content is copied without reference to the original
 * sender. Service messages and messageInvoice can't be copied
 */
export type messageCopyOptions = {
  _: 'messageCopyOptions',
  /**
   * True, if content of the message needs to be copied without reference to the original
   * sender. Always true if the message is forwarded to a secret chat or is local
   */
  send_copy: boolean,
  /**
   * True, if media caption of the message copy needs to be replaced. Ignored if send_copy
   * is false
   */
  replace_caption: boolean,
  /**
   * New message caption; pass null to copy message without caption. Ignored if replace_caption
   * is false
   */
  new_caption: formattedText,
}

/**
 * Options to be used when a message content is copied without reference to the original
 * sender. Service messages and messageInvoice can't be copied
 */
export type messageCopyOptions$Input = {
  readonly _: 'messageCopyOptions',
  /**
   * True, if content of the message needs to be copied without reference to the original
   * sender. Always true if the message is forwarded to a secret chat or is local
   */
  readonly send_copy?: boolean,
  /**
   * True, if media caption of the message copy needs to be replaced. Ignored if send_copy
   * is false
   */
  readonly replace_caption?: boolean,
  /**
   * New message caption; pass null to copy message without caption. Ignored if replace_caption
   * is false
   */
  readonly new_caption?: formattedText$Input,
}

/** A text message */
export type inputMessageText = {
  _: 'inputMessageText',
  /**
   * Formatted text to be sent; 1-GetOption("message_text_length_max") characters. Only
   * Bold, Italic, Underline, Strikethrough, Code, Pre, PreCode, TextUrl and MentionName
   * entities are allowed to be specified manually
   */
  text: formattedText,
  /** True, if rich web page previews for URLs in the message text must be disabled */
  disable_web_page_preview: boolean,
  /** True, if a chat message draft must be deleted */
  clear_draft: boolean,
}

/** A text message */
export type inputMessageText$Input = {
  readonly _: 'inputMessageText',
  /**
   * Formatted text to be sent; 1-GetOption("message_text_length_max") characters. Only
   * Bold, Italic, Underline, Strikethrough, Code, Pre, PreCode, TextUrl and MentionName
   * entities are allowed to be specified manually
   */
  readonly text?: formattedText$Input,
  /** True, if rich web page previews for URLs in the message text must be disabled */
  readonly disable_web_page_preview?: boolean,
  /** True, if a chat message draft must be deleted */
  readonly clear_draft?: boolean,
}

/** An animation message (GIF-style). */
export type inputMessageAnimation = {
  _: 'inputMessageAnimation',
  /** Animation file to be sent */
  animation: InputFile,
  /** Animation thumbnail; pass null to skip thumbnail uploading */
  thumbnail: inputThumbnail,
  /** File identifiers of the stickers added to the animation, if applicable */
  added_sticker_file_ids: Array<number>,
  /** Duration of the animation, in seconds */
  duration: number,
  /** Width of the animation; may be replaced by the server */
  width: number,
  /** Height of the animation; may be replaced by the server */
  height: number,
  /**
   * Animation caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
   * characters
   */
  caption: formattedText,
}

/** An animation message (GIF-style). */
export type inputMessageAnimation$Input = {
  readonly _: 'inputMessageAnimation',
  /** Animation file to be sent */
  readonly animation?: InputFile$Input,
  /** Animation thumbnail; pass null to skip thumbnail uploading */
  readonly thumbnail?: inputThumbnail$Input,
  /** File identifiers of the stickers added to the animation, if applicable */
  readonly added_sticker_file_ids?: ReadonlyArray<number>,
  /** Duration of the animation, in seconds */
  readonly duration?: number,
  /** Width of the animation; may be replaced by the server */
  readonly width?: number,
  /** Height of the animation; may be replaced by the server */
  readonly height?: number,
  /**
   * Animation caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
   * characters
   */
  readonly caption?: formattedText$Input,
}

/** An audio message */
export type inputMessageAudio = {
  _: 'inputMessageAudio',
  /** Audio file to be sent */
  audio: InputFile,
  /** Thumbnail of the cover for the album; pass null to skip thumbnail uploading */
  album_cover_thumbnail: inputThumbnail,
  /** Duration of the audio, in seconds; may be replaced by the server */
  duration: number,
  /** Title of the audio; 0-64 characters; may be replaced by the server */
  title: string,
  /** Performer of the audio; 0-64 characters, may be replaced by the server */
  performer: string,
  /**
   * Audio caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
   * characters
   */
  caption: formattedText,
}

/** An audio message */
export type inputMessageAudio$Input = {
  readonly _: 'inputMessageAudio',
  /** Audio file to be sent */
  readonly audio?: InputFile$Input,
  /** Thumbnail of the cover for the album; pass null to skip thumbnail uploading */
  readonly album_cover_thumbnail?: inputThumbnail$Input,
  /** Duration of the audio, in seconds; may be replaced by the server */
  readonly duration?: number,
  /** Title of the audio; 0-64 characters; may be replaced by the server */
  readonly title?: string,
  /** Performer of the audio; 0-64 characters, may be replaced by the server */
  readonly performer?: string,
  /**
   * Audio caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
   * characters
   */
  readonly caption?: formattedText$Input,
}

/** A document message (general file) */
export type inputMessageDocument = {
  _: 'inputMessageDocument',
  /** Document to be sent */
  document: InputFile,
  /** Document thumbnail; pass null to skip thumbnail uploading */
  thumbnail: inputThumbnail,
  /**
   * If true, automatic file type detection will be disabled and the document will be
   * always sent as file. Always true for files sent to secret chats
   */
  disable_content_type_detection: boolean,
  /**
   * Document caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
   * characters
   */
  caption: formattedText,
}

/** A document message (general file) */
export type inputMessageDocument$Input = {
  readonly _: 'inputMessageDocument',
  /** Document to be sent */
  readonly document?: InputFile$Input,
  /** Document thumbnail; pass null to skip thumbnail uploading */
  readonly thumbnail?: inputThumbnail$Input,
  /**
   * If true, automatic file type detection will be disabled and the document will be
   * always sent as file. Always true for files sent to secret chats
   */
  readonly disable_content_type_detection?: boolean,
  /**
   * Document caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
   * characters
   */
  readonly caption?: formattedText$Input,
}

/** A photo message */
export type inputMessagePhoto = {
  _: 'inputMessagePhoto',
  /** Photo to send */
  photo: InputFile,
  /**
   * Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail
   * is sent to the other party only in secret chats
   */
  thumbnail: inputThumbnail,
  /** File identifiers of the stickers added to the photo, if applicable */
  added_sticker_file_ids: Array<number>,
  /** Photo width */
  width: number,
  /** Photo height */
  height: number,
  /**
   * Photo caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
   * characters
   */
  caption: formattedText,
  /**
   * Photo TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified only
   * in private chats
   */
  ttl: number,
}

/** A photo message */
export type inputMessagePhoto$Input = {
  readonly _: 'inputMessagePhoto',
  /** Photo to send */
  readonly photo?: InputFile$Input,
  /**
   * Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail
   * is sent to the other party only in secret chats
   */
  readonly thumbnail?: inputThumbnail$Input,
  /** File identifiers of the stickers added to the photo, if applicable */
  readonly added_sticker_file_ids?: ReadonlyArray<number>,
  /** Photo width */
  readonly width?: number,
  /** Photo height */
  readonly height?: number,
  /**
   * Photo caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
   * characters
   */
  readonly caption?: formattedText$Input,
  /**
   * Photo TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified only
   * in private chats
   */
  readonly ttl?: number,
}

/** A sticker message */
export type inputMessageSticker = {
  _: 'inputMessageSticker',
  /** Sticker to be sent */
  sticker: InputFile,
  /** Sticker thumbnail; pass null to skip thumbnail uploading */
  thumbnail: inputThumbnail,
  /** Sticker width */
  width: number,
  /** Sticker height */
  height: number,
  /** Emoji used to choose the sticker */
  emoji: string,
}

/** A sticker message */
export type inputMessageSticker$Input = {
  readonly _: 'inputMessageSticker',
  /** Sticker to be sent */
  readonly sticker?: InputFile$Input,
  /** Sticker thumbnail; pass null to skip thumbnail uploading */
  readonly thumbnail?: inputThumbnail$Input,
  /** Sticker width */
  readonly width?: number,
  /** Sticker height */
  readonly height?: number,
  /** Emoji used to choose the sticker */
  readonly emoji?: string,
}

/** A video message */
export type inputMessageVideo = {
  _: 'inputMessageVideo',
  /** Video to be sent */
  video: InputFile,
  /** Video thumbnail; pass null to skip thumbnail uploading */
  thumbnail: inputThumbnail,
  /** File identifiers of the stickers added to the video, if applicable */
  added_sticker_file_ids: Array<number>,
  /** Duration of the video, in seconds */
  duration: number,
  /** Video width */
  width: number,
  /** Video height */
  height: number,
  /** True, if the video is supposed to be streamed */
  supports_streaming: boolean,
  /**
   * Video caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
   * characters
   */
  caption: formattedText,
  /**
   * Video TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified only
   * in private chats
   */
  ttl: number,
}

/** A video message */
export type inputMessageVideo$Input = {
  readonly _: 'inputMessageVideo',
  /** Video to be sent */
  readonly video?: InputFile$Input,
  /** Video thumbnail; pass null to skip thumbnail uploading */
  readonly thumbnail?: inputThumbnail$Input,
  /** File identifiers of the stickers added to the video, if applicable */
  readonly added_sticker_file_ids?: ReadonlyArray<number>,
  /** Duration of the video, in seconds */
  readonly duration?: number,
  /** Video width */
  readonly width?: number,
  /** Video height */
  readonly height?: number,
  /** True, if the video is supposed to be streamed */
  readonly supports_streaming?: boolean,
  /**
   * Video caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
   * characters
   */
  readonly caption?: formattedText$Input,
  /**
   * Video TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified only
   * in private chats
   */
  readonly ttl?: number,
}

/** A video note message */
export type inputMessageVideoNote = {
  _: 'inputMessageVideoNote',
  /** Video note to be sent */
  video_note: InputFile,
  /** Video thumbnail; pass null to skip thumbnail uploading */
  thumbnail: inputThumbnail,
  /** Duration of the video, in seconds */
  duration: number,
  /** Video width and height; must be positive and not greater than 640 */
  length: number,
}

/** A video note message */
export type inputMessageVideoNote$Input = {
  readonly _: 'inputMessageVideoNote',
  /** Video note to be sent */
  readonly video_note?: InputFile$Input,
  /** Video thumbnail; pass null to skip thumbnail uploading */
  readonly thumbnail?: inputThumbnail$Input,
  /** Duration of the video, in seconds */
  readonly duration?: number,
  /** Video width and height; must be positive and not greater than 640 */
  readonly length?: number,
}

/** A voice note message */
export type inputMessageVoiceNote = {
  _: 'inputMessageVoiceNote',
  /** Voice note to be sent */
  voice_note: InputFile,
  /** Duration of the voice note, in seconds */
  duration: number,
  /** Waveform representation of the voice note, in 5-bit format */
  waveform: string,
  /**
   * Voice note caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
   * characters
   */
  caption: formattedText,
}

/** A voice note message */
export type inputMessageVoiceNote$Input = {
  readonly _: 'inputMessageVoiceNote',
  /** Voice note to be sent */
  readonly voice_note?: InputFile$Input,
  /** Duration of the voice note, in seconds */
  readonly duration?: number,
  /** Waveform representation of the voice note, in 5-bit format */
  readonly waveform?: string,
  /**
   * Voice note caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
   * characters
   */
  readonly caption?: formattedText$Input,
}

/** A message with a location */
export type inputMessageLocation = {
  _: 'inputMessageLocation',
  /** Location to be sent */
  location: location,
  /**
   * Period for which the location can be updated, in seconds; must be between 60 and
   * 86400 for a live location and 0 otherwise
   */
  live_period: number,
  /**
   * For live locations, a direction in which the location moves, in degrees; 1-360. Pass
   * 0 if unknown
   */
  heading: number,
  /**
   * For live locations, a maximum distance to another chat member for proximity alerts,
   * in meters (0-100000). Pass 0 if the notification is disabled. Can't be enabled in
   * channels and Saved Messages
   */
  proximity_alert_radius: number,
}

/** A message with a location */
export type inputMessageLocation$Input = {
  readonly _: 'inputMessageLocation',
  /** Location to be sent */
  readonly location?: location$Input,
  /**
   * Period for which the location can be updated, in seconds; must be between 60 and
   * 86400 for a live location and 0 otherwise
   */
  readonly live_period?: number,
  /**
   * For live locations, a direction in which the location moves, in degrees; 1-360. Pass
   * 0 if unknown
   */
  readonly heading?: number,
  /**
   * For live locations, a maximum distance to another chat member for proximity alerts,
   * in meters (0-100000). Pass 0 if the notification is disabled. Can't be enabled in
   * channels and Saved Messages
   */
  readonly proximity_alert_radius?: number,
}

/** A message with information about a venue */
export type inputMessageVenue = {
  _: 'inputMessageVenue',
  /** Venue to send */
  venue: venue,
}

/** A message with information about a venue */
export type inputMessageVenue$Input = {
  readonly _: 'inputMessageVenue',
  /** Venue to send */
  readonly venue?: venue$Input,
}

/** A message containing a user contact */
export type inputMessageContact = {
  _: 'inputMessageContact',
  /** Contact to send */
  contact: contact,
}

/** A message containing a user contact */
export type inputMessageContact$Input = {
  readonly _: 'inputMessageContact',
  /** Contact to send */
  readonly contact?: contact$Input,
}

/** A dice message */
export type inputMessageDice = {
  _: 'inputMessageDice',
  /** Emoji on which the dice throw animation is based */
  emoji: string,
  /** True, if the chat message draft must be deleted */
  clear_draft: boolean,
}

/** A dice message */
export type inputMessageDice$Input = {
  readonly _: 'inputMessageDice',
  /** Emoji on which the dice throw animation is based */
  readonly emoji?: string,
  /** True, if the chat message draft must be deleted */
  readonly clear_draft?: boolean,
}

/** A message with a game; not supported for channels or secret chats */
export type inputMessageGame = {
  _: 'inputMessageGame',
  /** User identifier of the bot that owns the game */
  bot_user_id: number,
  /** Short name of the game */
  game_short_name: string,
}

/** A message with a game; not supported for channels or secret chats */
export type inputMessageGame$Input = {
  readonly _: 'inputMessageGame',
  /** User identifier of the bot that owns the game */
  readonly bot_user_id?: number,
  /** Short name of the game */
  readonly game_short_name?: string,
}

/** A message with an invoice; can be used only by bots */
export type inputMessageInvoice = {
  _: 'inputMessageInvoice',
  /** Invoice */
  invoice: invoice,
  /** Product title; 1-32 characters */
  title: string,
  /** Product description; 0-255 characters */
  description: string,
  /** Product photo URL; optional */
  photo_url: string,
  /** Product photo size */
  photo_size: number,
  /** Product photo width */
  photo_width: number,
  /** Product photo height */
  photo_height: number,
  /** The invoice payload */
  payload: string,
  /** Payment provider token */
  provider_token: string,
  /** JSON-encoded data about the invoice, which will be shared with the payment provider */
  provider_data: string,
  /**
   * Unique invoice bot deep link parameter for the generation of this invoice. If empty,
   * it would be possible to pay directly from forwards of the invoice message
   */
  start_parameter: string,
}

/** A message with an invoice; can be used only by bots */
export type inputMessageInvoice$Input = {
  readonly _: 'inputMessageInvoice',
  /** Invoice */
  readonly invoice?: invoice$Input,
  /** Product title; 1-32 characters */
  readonly title?: string,
  /** Product description; 0-255 characters */
  readonly description?: string,
  /** Product photo URL; optional */
  readonly photo_url?: string,
  /** Product photo size */
  readonly photo_size?: number,
  /** Product photo width */
  readonly photo_width?: number,
  /** Product photo height */
  readonly photo_height?: number,
  /** The invoice payload */
  readonly payload?: string,
  /** Payment provider token */
  readonly provider_token?: string,
  /** JSON-encoded data about the invoice, which will be shared with the payment provider */
  readonly provider_data?: string,
  /**
   * Unique invoice bot deep link parameter for the generation of this invoice. If empty,
   * it would be possible to pay directly from forwards of the invoice message
   */
  readonly start_parameter?: string,
}

/**
 * A message with a poll. Polls can't be sent to secret chats. Polls can be sent only
 * to a private chat with a bot
 */
export type inputMessagePoll = {
  _: 'inputMessagePoll',
  /** Poll question; 1-255 characters (up to 300 characters for bots) */
  question: string,
  /** List of poll answer options, 2-10 strings 1-100 characters each */
  options: Array<string>,
  /**
   * True, if the poll voters are anonymous. Non-anonymous polls can't be sent or forwarded
   * to channels
   */
  is_anonymous: boolean,
  /** Type of the poll */
  type: PollType,
  /** Amount of time the poll will be active after creation, in seconds; for bots only */
  open_period: number,
  /**
   * Point in time (Unix timestamp) when the poll will automatically be closed; for bots
   * only
   */
  close_date: number,
  /** True, if the poll needs to be sent already closed; for bots only */
  is_closed: boolean,
}

/**
 * A message with a poll. Polls can't be sent to secret chats. Polls can be sent only
 * to a private chat with a bot
 */
export type inputMessagePoll$Input = {
  readonly _: 'inputMessagePoll',
  /** Poll question; 1-255 characters (up to 300 characters for bots) */
  readonly question?: string,
  /** List of poll answer options, 2-10 strings 1-100 characters each */
  readonly options?: ReadonlyArray<string>,
  /**
   * True, if the poll voters are anonymous. Non-anonymous polls can't be sent or forwarded
   * to channels
   */
  readonly is_anonymous?: boolean,
  /** Type of the poll */
  readonly type?: PollType$Input,
  /** Amount of time the poll will be active after creation, in seconds; for bots only */
  readonly open_period?: number,
  /**
   * Point in time (Unix timestamp) when the poll will automatically be closed; for bots
   * only
   */
  readonly close_date?: number,
  /** True, if the poll needs to be sent already closed; for bots only */
  readonly is_closed?: boolean,
}

/** A forwarded message */
export type inputMessageForwarded = {
  _: 'inputMessageForwarded',
  /** Identifier for the chat this forwarded message came from */
  from_chat_id: number,
  /** Identifier of the message to forward */
  message_id: number,
  /**
   * True, if a game message is being shared from a launched game; applies only to game
   * messages
   */
  in_game_share: boolean,
  /**
   * Options to be used to copy content of the message without reference to the original
   * sender; pass null to forward the message as usual
   */
  copy_options: messageCopyOptions,
}

/** A forwarded message */
export type inputMessageForwarded$Input = {
  readonly _: 'inputMessageForwarded',
  /** Identifier for the chat this forwarded message came from */
  readonly from_chat_id?: number,
  /** Identifier of the message to forward */
  readonly message_id?: number,
  /**
   * True, if a game message is being shared from a launched game; applies only to game
   * messages
   */
  readonly in_game_share?: boolean,
  /**
   * Options to be used to copy content of the message without reference to the original
   * sender; pass null to forward the message as usual
   */
  readonly copy_options?: messageCopyOptions$Input,
}

/** Returns all found messages, no filter is applied */
export type searchMessagesFilterEmpty = {
  _: 'searchMessagesFilterEmpty',
}

/** Returns all found messages, no filter is applied */
export type searchMessagesFilterEmpty$Input = {
  readonly _: 'searchMessagesFilterEmpty',
}

/** Returns only animation messages */
export type searchMessagesFilterAnimation = {
  _: 'searchMessagesFilterAnimation',
}

/** Returns only animation messages */
export type searchMessagesFilterAnimation$Input = {
  readonly _: 'searchMessagesFilterAnimation',
}

/** Returns only audio messages */
export type searchMessagesFilterAudio = {
  _: 'searchMessagesFilterAudio',
}

/** Returns only audio messages */
export type searchMessagesFilterAudio$Input = {
  readonly _: 'searchMessagesFilterAudio',
}

/** Returns only document messages */
export type searchMessagesFilterDocument = {
  _: 'searchMessagesFilterDocument',
}

/** Returns only document messages */
export type searchMessagesFilterDocument$Input = {
  readonly _: 'searchMessagesFilterDocument',
}

/** Returns only photo messages */
export type searchMessagesFilterPhoto = {
  _: 'searchMessagesFilterPhoto',
}

/** Returns only photo messages */
export type searchMessagesFilterPhoto$Input = {
  readonly _: 'searchMessagesFilterPhoto',
}

/** Returns only video messages */
export type searchMessagesFilterVideo = {
  _: 'searchMessagesFilterVideo',
}

/** Returns only video messages */
export type searchMessagesFilterVideo$Input = {
  readonly _: 'searchMessagesFilterVideo',
}

/** Returns only voice note messages */
export type searchMessagesFilterVoiceNote = {
  _: 'searchMessagesFilterVoiceNote',
}

/** Returns only voice note messages */
export type searchMessagesFilterVoiceNote$Input = {
  readonly _: 'searchMessagesFilterVoiceNote',
}

/** Returns only photo and video messages */
export type searchMessagesFilterPhotoAndVideo = {
  _: 'searchMessagesFilterPhotoAndVideo',
}

/** Returns only photo and video messages */
export type searchMessagesFilterPhotoAndVideo$Input = {
  readonly _: 'searchMessagesFilterPhotoAndVideo',
}

/** Returns only messages containing URLs */
export type searchMessagesFilterUrl = {
  _: 'searchMessagesFilterUrl',
}

/** Returns only messages containing URLs */
export type searchMessagesFilterUrl$Input = {
  readonly _: 'searchMessagesFilterUrl',
}

/** Returns only messages containing chat photos */
export type searchMessagesFilterChatPhoto = {
  _: 'searchMessagesFilterChatPhoto',
}

/** Returns only messages containing chat photos */
export type searchMessagesFilterChatPhoto$Input = {
  readonly _: 'searchMessagesFilterChatPhoto',
}

/** Returns only video note messages */
export type searchMessagesFilterVideoNote = {
  _: 'searchMessagesFilterVideoNote',
}

/** Returns only video note messages */
export type searchMessagesFilterVideoNote$Input = {
  readonly _: 'searchMessagesFilterVideoNote',
}

/** Returns only voice and video note messages */
export type searchMessagesFilterVoiceAndVideoNote = {
  _: 'searchMessagesFilterVoiceAndVideoNote',
}

/** Returns only voice and video note messages */
export type searchMessagesFilterVoiceAndVideoNote$Input = {
  readonly _: 'searchMessagesFilterVoiceAndVideoNote',
}

/**
 * Returns only messages with mentions of the current user, or messages that are replies
 * to their messages
 */
export type searchMessagesFilterMention = {
  _: 'searchMessagesFilterMention',
}

/**
 * Returns only messages with mentions of the current user, or messages that are replies
 * to their messages
 */
export type searchMessagesFilterMention$Input = {
  readonly _: 'searchMessagesFilterMention',
}

/**
 * Returns only messages with unread mentions of the current user, or messages that
 * are replies to their messages. When using this filter the results can't be additionally
 * filtered by a query, a message thread or by the sending user
 */
export type searchMessagesFilterUnreadMention = {
  _: 'searchMessagesFilterUnreadMention',
}

/**
 * Returns only messages with unread mentions of the current user, or messages that
 * are replies to their messages. When using this filter the results can't be additionally
 * filtered by a query, a message thread or by the sending user
 */
export type searchMessagesFilterUnreadMention$Input = {
  readonly _: 'searchMessagesFilterUnreadMention',
}

/**
 * Returns only failed to send messages. This filter can be used only if the message
 * database is used
 */
export type searchMessagesFilterFailedToSend = {
  _: 'searchMessagesFilterFailedToSend',
}

/**
 * Returns only failed to send messages. This filter can be used only if the message
 * database is used
 */
export type searchMessagesFilterFailedToSend$Input = {
  readonly _: 'searchMessagesFilterFailedToSend',
}

/** Returns only pinned messages */
export type searchMessagesFilterPinned = {
  _: 'searchMessagesFilterPinned',
}

/** Returns only pinned messages */
export type searchMessagesFilterPinned$Input = {
  readonly _: 'searchMessagesFilterPinned',
}

/** The user is typing a message */
export type chatActionTyping = {
  _: 'chatActionTyping',
}

/** The user is typing a message */
export type chatActionTyping$Input = {
  readonly _: 'chatActionTyping',
}

/** The user is recording a video */
export type chatActionRecordingVideo = {
  _: 'chatActionRecordingVideo',
}

/** The user is recording a video */
export type chatActionRecordingVideo$Input = {
  readonly _: 'chatActionRecordingVideo',
}

/** The user is uploading a video */
export type chatActionUploadingVideo = {
  _: 'chatActionUploadingVideo',
  /** Upload progress, as a percentage */
  progress: number,
}

/** The user is uploading a video */
export type chatActionUploadingVideo$Input = {
  readonly _: 'chatActionUploadingVideo',
  /** Upload progress, as a percentage */
  readonly progress?: number,
}

/** The user is recording a voice note */
export type chatActionRecordingVoiceNote = {
  _: 'chatActionRecordingVoiceNote',
}

/** The user is recording a voice note */
export type chatActionRecordingVoiceNote$Input = {
  readonly _: 'chatActionRecordingVoiceNote',
}

/** The user is uploading a voice note */
export type chatActionUploadingVoiceNote = {
  _: 'chatActionUploadingVoiceNote',
  /** Upload progress, as a percentage */
  progress: number,
}

/** The user is uploading a voice note */
export type chatActionUploadingVoiceNote$Input = {
  readonly _: 'chatActionUploadingVoiceNote',
  /** Upload progress, as a percentage */
  readonly progress?: number,
}

/** The user is uploading a photo */
export type chatActionUploadingPhoto = {
  _: 'chatActionUploadingPhoto',
  /** Upload progress, as a percentage */
  progress: number,
}

/** The user is uploading a photo */
export type chatActionUploadingPhoto$Input = {
  readonly _: 'chatActionUploadingPhoto',
  /** Upload progress, as a percentage */
  readonly progress?: number,
}

/** The user is uploading a document */
export type chatActionUploadingDocument = {
  _: 'chatActionUploadingDocument',
  /** Upload progress, as a percentage */
  progress: number,
}

/** The user is uploading a document */
export type chatActionUploadingDocument$Input = {
  readonly _: 'chatActionUploadingDocument',
  /** Upload progress, as a percentage */
  readonly progress?: number,
}

/** The user is picking a sticker to send */
export type chatActionChoosingSticker = {
  _: 'chatActionChoosingSticker',
}

/** The user is picking a sticker to send */
export type chatActionChoosingSticker$Input = {
  readonly _: 'chatActionChoosingSticker',
}

/** The user is picking a location or venue to send */
export type chatActionChoosingLocation = {
  _: 'chatActionChoosingLocation',
}

/** The user is picking a location or venue to send */
export type chatActionChoosingLocation$Input = {
  readonly _: 'chatActionChoosingLocation',
}

/** The user is picking a contact to send */
export type chatActionChoosingContact = {
  _: 'chatActionChoosingContact',
}

/** The user is picking a contact to send */
export type chatActionChoosingContact$Input = {
  readonly _: 'chatActionChoosingContact',
}

/** The user has started to play a game */
export type chatActionStartPlayingGame = {
  _: 'chatActionStartPlayingGame',
}

/** The user has started to play a game */
export type chatActionStartPlayingGame$Input = {
  readonly _: 'chatActionStartPlayingGame',
}

/** The user is recording a video note */
export type chatActionRecordingVideoNote = {
  _: 'chatActionRecordingVideoNote',
}

/** The user is recording a video note */
export type chatActionRecordingVideoNote$Input = {
  readonly _: 'chatActionRecordingVideoNote',
}

/** The user is uploading a video note */
export type chatActionUploadingVideoNote = {
  _: 'chatActionUploadingVideoNote',
  /** Upload progress, as a percentage */
  progress: number,
}

/** The user is uploading a video note */
export type chatActionUploadingVideoNote$Input = {
  readonly _: 'chatActionUploadingVideoNote',
  /** Upload progress, as a percentage */
  readonly progress?: number,
}

/**
 * The user is watching animations sent by the other party by clicking on an animated
 * emoji
 */
export type chatActionWatchingAnimations = {
  _: 'chatActionWatchingAnimations',
  /** The animated emoji */
  emoji: string,
}

/**
 * The user is watching animations sent by the other party by clicking on an animated
 * emoji
 */
export type chatActionWatchingAnimations$Input = {
  readonly _: 'chatActionWatchingAnimations',
  /** The animated emoji */
  readonly emoji?: string,
}

/** The user has canceled the previous action */
export type chatActionCancel = {
  _: 'chatActionCancel',
}

/** The user has canceled the previous action */
export type chatActionCancel$Input = {
  readonly _: 'chatActionCancel',
}

/** The user status was never changed */
export type userStatusEmpty = {
  _: 'userStatusEmpty',
}

/** The user status was never changed */
export type userStatusEmpty$Input = {
  readonly _: 'userStatusEmpty',
}

/** The user is online */
export type userStatusOnline = {
  _: 'userStatusOnline',
  /** Point in time (Unix timestamp) when the user's online status will expire */
  expires: number,
}

/** The user is online */
export type userStatusOnline$Input = {
  readonly _: 'userStatusOnline',
  /** Point in time (Unix timestamp) when the user's online status will expire */
  readonly expires?: number,
}

/** The user is offline */
export type userStatusOffline = {
  _: 'userStatusOffline',
  /** Point in time (Unix timestamp) when the user was last online */
  was_online: number,
}

/** The user is offline */
export type userStatusOffline$Input = {
  readonly _: 'userStatusOffline',
  /** Point in time (Unix timestamp) when the user was last online */
  readonly was_online?: number,
}

/** The user was online recently */
export type userStatusRecently = {
  _: 'userStatusRecently',
}

/** The user was online recently */
export type userStatusRecently$Input = {
  readonly _: 'userStatusRecently',
}

/** The user is offline, but was online last week */
export type userStatusLastWeek = {
  _: 'userStatusLastWeek',
}

/** The user is offline, but was online last week */
export type userStatusLastWeek$Input = {
  readonly _: 'userStatusLastWeek',
}

/** The user is offline, but was online last month */
export type userStatusLastMonth = {
  _: 'userStatusLastMonth',
}

/** The user is offline, but was online last month */
export type userStatusLastMonth$Input = {
  readonly _: 'userStatusLastMonth',
}

/** Represents a list of stickers */
export type stickers = {
  _: 'stickers',
  /** List of stickers */
  stickers: Array<sticker>,
}

/** Represents a list of stickers */
export type stickers$Input = {
  readonly _: 'stickers',
  /** List of stickers */
  readonly stickers?: ReadonlyArray<sticker$Input>,
}

/** Represents a list of emoji */
export type emojis = {
  _: 'emojis',
  /** List of emojis */
  emojis: Array<string>,
}

/** Represents a list of emoji */
export type emojis$Input = {
  readonly _: 'emojis',
  /** List of emojis */
  readonly emojis?: ReadonlyArray<string>,
}

/** Represents a sticker set */
export type stickerSet = {
  _: 'stickerSet',
  /** Identifier of the sticker set */
  id: number | string,
  /** Title of the sticker set */
  title: string,
  /** Name of the sticker set */
  name: string,
  /**
   * Sticker set thumbnail in WEBP or TGS format with width and height 100; may be null.
   * The file can be downloaded only before the thumbnail is changed
   */
  thumbnail: thumbnail | undefined,
  /**
   * Sticker set thumbnail's outline represented as a list of closed vector paths; may
   * be empty. The coordinate system origin is in the upper-left corner
   */
  thumbnail_outline: Array<closedVectorPath>,
  /** True, if the sticker set has been installed by the current user */
  is_installed: boolean,
  /**
   * True, if the sticker set has been archived. A sticker set can't be installed and
   * archived simultaneously
   */
  is_archived: boolean,
  /** True, if the sticker set is official */
  is_official: boolean,
  /** True, is the stickers in the set are animated */
  is_animated: boolean,
  /** True, if the stickers in the set are masks */
  is_masks: boolean,
  /** True for already viewed trending sticker sets */
  is_viewed: boolean,
  /** List of stickers in this set */
  stickers: Array<sticker>,
  /**
   * A list of emoji corresponding to the stickers in the same order. The list is only
   * for informational purposes, because a sticker is always sent with a fixed emoji from
   * the corresponding Sticker object
   */
  emojis: Array<emojis>,
}

/** Represents a sticker set */
export type stickerSet$Input = {
  readonly _: 'stickerSet',
  /** Identifier of the sticker set */
  readonly id?: number | string,
  /** Title of the sticker set */
  readonly title?: string,
  /** Name of the sticker set */
  readonly name?: string,
  /**
   * Sticker set thumbnail in WEBP or TGS format with width and height 100; may be null.
   * The file can be downloaded only before the thumbnail is changed
   */
  readonly thumbnail?: thumbnail$Input | undefined,
  /**
   * Sticker set thumbnail's outline represented as a list of closed vector paths; may
   * be empty. The coordinate system origin is in the upper-left corner
   */
  readonly thumbnail_outline?: ReadonlyArray<closedVectorPath$Input>,
  /** True, if the sticker set has been installed by the current user */
  readonly is_installed?: boolean,
  /**
   * True, if the sticker set has been archived. A sticker set can't be installed and
   * archived simultaneously
   */
  readonly is_archived?: boolean,
  /** True, if the sticker set is official */
  readonly is_official?: boolean,
  /** True, is the stickers in the set are animated */
  readonly is_animated?: boolean,
  /** True, if the stickers in the set are masks */
  readonly is_masks?: boolean,
  /** True for already viewed trending sticker sets */
  readonly is_viewed?: boolean,
  /** List of stickers in this set */
  readonly stickers?: ReadonlyArray<sticker$Input>,
  /**
   * A list of emoji corresponding to the stickers in the same order. The list is only
   * for informational purposes, because a sticker is always sent with a fixed emoji from
   * the corresponding Sticker object
   */
  readonly emojis?: ReadonlyArray<emojis$Input>,
}

/** Represents short information about a sticker set */
export type stickerSetInfo = {
  _: 'stickerSetInfo',
  /** Identifier of the sticker set */
  id: number | string,
  /** Title of the sticker set */
  title: string,
  /** Name of the sticker set */
  name: string,
  /** Sticker set thumbnail in WEBP or TGS format with width and height 100; may be null */
  thumbnail: thumbnail | undefined,
  /**
   * Sticker set thumbnail's outline represented as a list of closed vector paths; may
   * be empty. The coordinate system origin is in the upper-left corner
   */
  thumbnail_outline: Array<closedVectorPath>,
  /** True, if the sticker set has been installed by the current user */
  is_installed: boolean,
  /**
   * True, if the sticker set has been archived. A sticker set can't be installed and
   * archived simultaneously
   */
  is_archived: boolean,
  /** True, if the sticker set is official */
  is_official: boolean,
  /** True, is the stickers in the set are animated */
  is_animated: boolean,
  /** True, if the stickers in the set are masks */
  is_masks: boolean,
  /** True for already viewed trending sticker sets */
  is_viewed: boolean,
  /** Total number of stickers in the set */
  size: number,
  /**
   * Up to the first 5 stickers from the set, depending on the context. If the application
   * needs more stickers the full sticker set needs to be requested
   */
  covers: Array<sticker>,
}

/** Represents short information about a sticker set */
export type stickerSetInfo$Input = {
  readonly _: 'stickerSetInfo',
  /** Identifier of the sticker set */
  readonly id?: number | string,
  /** Title of the sticker set */
  readonly title?: string,
  /** Name of the sticker set */
  readonly name?: string,
  /** Sticker set thumbnail in WEBP or TGS format with width and height 100; may be null */
  readonly thumbnail?: thumbnail$Input | undefined,
  /**
   * Sticker set thumbnail's outline represented as a list of closed vector paths; may
   * be empty. The coordinate system origin is in the upper-left corner
   */
  readonly thumbnail_outline?: ReadonlyArray<closedVectorPath$Input>,
  /** True, if the sticker set has been installed by the current user */
  readonly is_installed?: boolean,
  /**
   * True, if the sticker set has been archived. A sticker set can't be installed and
   * archived simultaneously
   */
  readonly is_archived?: boolean,
  /** True, if the sticker set is official */
  readonly is_official?: boolean,
  /** True, is the stickers in the set are animated */
  readonly is_animated?: boolean,
  /** True, if the stickers in the set are masks */
  readonly is_masks?: boolean,
  /** True for already viewed trending sticker sets */
  readonly is_viewed?: boolean,
  /** Total number of stickers in the set */
  readonly size?: number,
  /**
   * Up to the first 5 stickers from the set, depending on the context. If the application
   * needs more stickers the full sticker set needs to be requested
   */
  readonly covers?: ReadonlyArray<sticker$Input>,
}

/** Represents a list of sticker sets */
export type stickerSets = {
  _: 'stickerSets',
  /** Approximate total number of sticker sets found */
  total_count: number,
  /** List of sticker sets */
  sets: Array<stickerSetInfo>,
}

/** Represents a list of sticker sets */
export type stickerSets$Input = {
  readonly _: 'stickerSets',
  /** Approximate total number of sticker sets found */
  readonly total_count?: number,
  /** List of sticker sets */
  readonly sets?: ReadonlyArray<stickerSetInfo$Input>,
}

/** The call wasn't discarded, or the reason is unknown */
export type callDiscardReasonEmpty = {
  _: 'callDiscardReasonEmpty',
}

/** The call wasn't discarded, or the reason is unknown */
export type callDiscardReasonEmpty$Input = {
  readonly _: 'callDiscardReasonEmpty',
}

/**
 * The call was ended before the conversation started. It was canceled by the caller
 * or missed by the other party
 */
export type callDiscardReasonMissed = {
  _: 'callDiscardReasonMissed',
}

/**
 * The call was ended before the conversation started. It was canceled by the caller
 * or missed by the other party
 */
export type callDiscardReasonMissed$Input = {
  readonly _: 'callDiscardReasonMissed',
}

/**
 * The call was ended before the conversation started. It was declined by the other
 * party
 */
export type callDiscardReasonDeclined = {
  _: 'callDiscardReasonDeclined',
}

/**
 * The call was ended before the conversation started. It was declined by the other
 * party
 */
export type callDiscardReasonDeclined$Input = {
  readonly _: 'callDiscardReasonDeclined',
}

/** The call was ended during the conversation because the users were disconnected */
export type callDiscardReasonDisconnected = {
  _: 'callDiscardReasonDisconnected',
}

/** The call was ended during the conversation because the users were disconnected */
export type callDiscardReasonDisconnected$Input = {
  readonly _: 'callDiscardReasonDisconnected',
}

/** The call was ended because one of the parties hung up */
export type callDiscardReasonHungUp = {
  _: 'callDiscardReasonHungUp',
}

/** The call was ended because one of the parties hung up */
export type callDiscardReasonHungUp$Input = {
  readonly _: 'callDiscardReasonHungUp',
}

/** Specifies the supported call protocols */
export type callProtocol = {
  _: 'callProtocol',
  /** True, if UDP peer-to-peer connections are supported */
  udp_p2p: boolean,
  /** True, if connection through UDP reflectors is supported */
  udp_reflector: boolean,
  /** The minimum supported API layer; use 65 */
  min_layer: number,
  /** The maximum supported API layer; use 65 */
  max_layer: number,
  /** List of supported tgcalls versions */
  library_versions: Array<string>,
}

/** Specifies the supported call protocols */
export type callProtocol$Input = {
  readonly _: 'callProtocol',
  /** True, if UDP peer-to-peer connections are supported */
  readonly udp_p2p?: boolean,
  /** True, if connection through UDP reflectors is supported */
  readonly udp_reflector?: boolean,
  /** The minimum supported API layer; use 65 */
  readonly min_layer?: number,
  /** The maximum supported API layer; use 65 */
  readonly max_layer?: number,
  /** List of supported tgcalls versions */
  readonly library_versions?: ReadonlyArray<string>,
}

/** A Telegram call reflector */
export type callServerTypeTelegramReflector = {
  _: 'callServerTypeTelegramReflector',
  /** A peer tag to be used with the reflector */
  peer_tag: string,
}

/** A Telegram call reflector */
export type callServerTypeTelegramReflector$Input = {
  readonly _: 'callServerTypeTelegramReflector',
  /** A peer tag to be used with the reflector */
  readonly peer_tag?: string,
}

/** A WebRTC server */
export type callServerTypeWebrtc = {
  _: 'callServerTypeWebrtc',
  /** Username to be used for authentication */
  username: string,
  /** Authentication password */
  password: string,
  /** True, if the server supports TURN */
  supports_turn: boolean,
  /** True, if the server supports STUN */
  supports_stun: boolean,
}

/** A WebRTC server */
export type callServerTypeWebrtc$Input = {
  readonly _: 'callServerTypeWebrtc',
  /** Username to be used for authentication */
  readonly username?: string,
  /** Authentication password */
  readonly password?: string,
  /** True, if the server supports TURN */
  readonly supports_turn?: boolean,
  /** True, if the server supports STUN */
  readonly supports_stun?: boolean,
}

/** Describes a server for relaying call data */
export type callServer = {
  _: 'callServer',
  /** Server identifier */
  id: number | string,
  /** Server IPv4 address */
  ip_address: string,
  /** Server IPv6 address */
  ipv6_address: string,
  /** Server port number */
  port: number,
  /** Server type */
  type: CallServerType,
}

/** Describes a server for relaying call data */
export type callServer$Input = {
  readonly _: 'callServer',
  /** Server identifier */
  readonly id?: number | string,
  /** Server IPv4 address */
  readonly ip_address?: string,
  /** Server IPv6 address */
  readonly ipv6_address?: string,
  /** Server port number */
  readonly port?: number,
  /** Server type */
  readonly type?: CallServerType$Input,
}

/** Contains the call identifier */
export type callId = {
  _: 'callId',
  /** Call identifier */
  id: number,
}

/** Contains the call identifier */
export type callId$Input = {
  readonly _: 'callId',
  /** Call identifier */
  readonly id?: number,
}

/** Contains the group call identifier */
export type groupCallId = {
  _: 'groupCallId',
  /** Group call identifier */
  id: number,
}

/** Contains the group call identifier */
export type groupCallId$Input = {
  readonly _: 'groupCallId',
  /** Group call identifier */
  readonly id?: number,
}

/** The call is pending, waiting to be accepted by a user */
export type callStatePending = {
  _: 'callStatePending',
  /** True, if the call has already been created by the server */
  is_created: boolean,
  /** True, if the call has already been received by the other party */
  is_received: boolean,
}

/** The call is pending, waiting to be accepted by a user */
export type callStatePending$Input = {
  readonly _: 'callStatePending',
  /** True, if the call has already been created by the server */
  readonly is_created?: boolean,
  /** True, if the call has already been received by the other party */
  readonly is_received?: boolean,
}

/** The call has been answered and encryption keys are being exchanged */
export type callStateExchangingKeys = {
  _: 'callStateExchangingKeys',
}

/** The call has been answered and encryption keys are being exchanged */
export type callStateExchangingKeys$Input = {
  readonly _: 'callStateExchangingKeys',
}

/** The call is ready to use */
export type callStateReady = {
  _: 'callStateReady',
  /** Call protocols supported by the peer */
  protocol: callProtocol,
  /** List of available call servers */
  servers: Array<callServer>,
  /** A JSON-encoded call config */
  config: string,
  /** Call encryption key */
  encryption_key: string,
  /** Encryption key emojis fingerprint */
  emojis: Array<string>,
  /** True, if peer-to-peer connection is allowed by users privacy settings */
  allow_p2p: boolean,
}

/** The call is ready to use */
export type callStateReady$Input = {
  readonly _: 'callStateReady',
  /** Call protocols supported by the peer */
  readonly protocol?: callProtocol$Input,
  /** List of available call servers */
  readonly servers?: ReadonlyArray<callServer$Input>,
  /** A JSON-encoded call config */
  readonly config?: string,
  /** Call encryption key */
  readonly encryption_key?: string,
  /** Encryption key emojis fingerprint */
  readonly emojis?: ReadonlyArray<string>,
  /** True, if peer-to-peer connection is allowed by users privacy settings */
  readonly allow_p2p?: boolean,
}

/** The call is hanging up after discardCall has been called */
export type callStateHangingUp = {
  _: 'callStateHangingUp',
}

/** The call is hanging up after discardCall has been called */
export type callStateHangingUp$Input = {
  readonly _: 'callStateHangingUp',
}

/** The call has ended successfully */
export type callStateDiscarded = {
  _: 'callStateDiscarded',
  /** The reason, why the call has ended */
  reason: CallDiscardReason,
  /** True, if the call rating must be sent to the server */
  need_rating: boolean,
  /** True, if the call debug information must be sent to the server */
  need_debug_information: boolean,
}

/** The call has ended successfully */
export type callStateDiscarded$Input = {
  readonly _: 'callStateDiscarded',
  /** The reason, why the call has ended */
  readonly reason?: CallDiscardReason$Input,
  /** True, if the call rating must be sent to the server */
  readonly need_rating?: boolean,
  /** True, if the call debug information must be sent to the server */
  readonly need_debug_information?: boolean,
}

/** The call has ended with an error */
export type callStateError = {
  _: 'callStateError',
  /**
   * Error. An error with the code 4005000 will be returned if an outgoing call is missed
   * because of an expired timeout
   */
  error: error,
}

/** The call has ended with an error */
export type callStateError$Input = {
  readonly _: 'callStateError',
  /**
   * Error. An error with the code 4005000 will be returned if an outgoing call is missed
   * because of an expired timeout
   */
  readonly error?: error$Input,
}

/** The worst available video quality */
export type groupCallVideoQualityThumbnail = {
  _: 'groupCallVideoQualityThumbnail',
}

/** The worst available video quality */
export type groupCallVideoQualityThumbnail$Input = {
  readonly _: 'groupCallVideoQualityThumbnail',
}

/** The medium video quality */
export type groupCallVideoQualityMedium = {
  _: 'groupCallVideoQualityMedium',
}

/** The medium video quality */
export type groupCallVideoQualityMedium$Input = {
  readonly _: 'groupCallVideoQualityMedium',
}

/** The best available video quality */
export type groupCallVideoQualityFull = {
  _: 'groupCallVideoQualityFull',
}

/** The best available video quality */
export type groupCallVideoQualityFull$Input = {
  readonly _: 'groupCallVideoQualityFull',
}

/** Describes a recently speaking participant in a group call */
export type groupCallRecentSpeaker = {
  _: 'groupCallRecentSpeaker',
  /** Group call participant identifier */
  participant_id: MessageSender,
  /** True, is the user has spoken recently */
  is_speaking: boolean,
}

/** Describes a recently speaking participant in a group call */
export type groupCallRecentSpeaker$Input = {
  readonly _: 'groupCallRecentSpeaker',
  /** Group call participant identifier */
  readonly participant_id?: MessageSender$Input,
  /** True, is the user has spoken recently */
  readonly is_speaking?: boolean,
}

/** Describes a group call */
export type groupCall = {
  _: 'groupCall',
  /** Group call identifier */
  id: number,
  /** Group call title */
  title: string,
  /**
   * Point in time (Unix timestamp) when the group call is supposed to be started by an
   * administrator; 0 if it is already active or was ended
   */
  scheduled_start_date: number,
  /**
   * True, if the group call is scheduled and the current user will receive a notification
   * when the group call will start
   */
  enabled_start_notification: boolean,
  /** True, if the call is active */
  is_active: boolean,
  /** True, if the call is joined */
  is_joined: boolean,
  /**
   * True, if user was kicked from the call because of network loss and the call needs
   * to be rejoined
   */
  need_rejoin: boolean,
  /** True, if the current user can manage the group call */
  can_be_managed: boolean,
  /** Number of participants in the group call */
  participant_count: number,
  /** True, if all group call participants are loaded */
  loaded_all_participants: boolean,
  /** At most 3 recently speaking users in the group call */
  recent_speakers: Array<groupCallRecentSpeaker>,
  /** True, if the current user's video is enabled */
  is_my_video_enabled: boolean,
  /** True, if the current user's video is paused */
  is_my_video_paused: boolean,
  /** True, if the current user can broadcast video or share screen */
  can_enable_video: boolean,
  /** True, if only group call administrators can unmute new participants */
  mute_new_participants: boolean,
  /** True, if the current user can enable or disable mute_new_participants setting */
  can_toggle_mute_new_participants: boolean,
  /**
   * Duration of the ongoing group call recording, in seconds; 0 if none. An updateGroupCall
   * update is not triggered when value of this field changes, but the same recording
   * goes on
   */
  record_duration: number,
  /** True, if a video file is being recorded for the call */
  is_video_recorded: boolean,
  /** Call duration, in seconds; for ended calls only */
  duration: number,
}

/** Describes a group call */
export type groupCall$Input = {
  readonly _: 'groupCall',
  /** Group call identifier */
  readonly id?: number,
  /** Group call title */
  readonly title?: string,
  /**
   * Point in time (Unix timestamp) when the group call is supposed to be started by an
   * administrator; 0 if it is already active or was ended
   */
  readonly scheduled_start_date?: number,
  /**
   * True, if the group call is scheduled and the current user will receive a notification
   * when the group call will start
   */
  readonly enabled_start_notification?: boolean,
  /** True, if the call is active */
  readonly is_active?: boolean,
  /** True, if the call is joined */
  readonly is_joined?: boolean,
  /**
   * True, if user was kicked from the call because of network loss and the call needs
   * to be rejoined
   */
  readonly need_rejoin?: boolean,
  /** True, if the current user can manage the group call */
  readonly can_be_managed?: boolean,
  /** Number of participants in the group call */
  readonly participant_count?: number,
  /** True, if all group call participants are loaded */
  readonly loaded_all_participants?: boolean,
  /** At most 3 recently speaking users in the group call */
  readonly recent_speakers?: ReadonlyArray<groupCallRecentSpeaker$Input>,
  /** True, if the current user's video is enabled */
  readonly is_my_video_enabled?: boolean,
  /** True, if the current user's video is paused */
  readonly is_my_video_paused?: boolean,
  /** True, if the current user can broadcast video or share screen */
  readonly can_enable_video?: boolean,
  /** True, if only group call administrators can unmute new participants */
  readonly mute_new_participants?: boolean,
  /** True, if the current user can enable or disable mute_new_participants setting */
  readonly can_toggle_mute_new_participants?: boolean,
  /**
   * Duration of the ongoing group call recording, in seconds; 0 if none. An updateGroupCall
   * update is not triggered when value of this field changes, but the same recording
   * goes on
   */
  readonly record_duration?: number,
  /** True, if a video file is being recorded for the call */
  readonly is_video_recorded?: boolean,
  /** Call duration, in seconds; for ended calls only */
  readonly duration?: number,
}

/** Describes a group of video synchronization source identifiers */
export type groupCallVideoSourceGroup = {
  _: 'groupCallVideoSourceGroup',
  /** The semantics of sources, one of "SIM" or "FID" */
  semantics: string,
  /** The list of synchronization source identifiers */
  source_ids: Array<number>,
}

/** Describes a group of video synchronization source identifiers */
export type groupCallVideoSourceGroup$Input = {
  readonly _: 'groupCallVideoSourceGroup',
  /** The semantics of sources, one of "SIM" or "FID" */
  readonly semantics?: string,
  /** The list of synchronization source identifiers */
  readonly source_ids?: ReadonlyArray<number>,
}

/** Contains information about a group call participant's video channel */
export type groupCallParticipantVideoInfo = {
  _: 'groupCallParticipantVideoInfo',
  /** List of synchronization source groups of the video */
  source_groups: Array<groupCallVideoSourceGroup>,
  /** Video channel endpoint identifier */
  endpoint_id: string,
  /**
   * True if the video is paused. This flag needs to be ignored, if new video frames are
   * received
   */
  is_paused: boolean,
}

/** Contains information about a group call participant's video channel */
export type groupCallParticipantVideoInfo$Input = {
  readonly _: 'groupCallParticipantVideoInfo',
  /** List of synchronization source groups of the video */
  readonly source_groups?: ReadonlyArray<groupCallVideoSourceGroup$Input>,
  /** Video channel endpoint identifier */
  readonly endpoint_id?: string,
  /**
   * True if the video is paused. This flag needs to be ignored, if new video frames are
   * received
   */
  readonly is_paused?: boolean,
}

/** Represents a group call participant */
export type groupCallParticipant = {
  _: 'groupCallParticipant',
  /** Identifier of the group call participant */
  participant_id: MessageSender,
  /** User's audio channel synchronization source identifier */
  audio_source_id: number,
  /** User's screen sharing audio channel synchronization source identifier */
  screen_sharing_audio_source_id: number,
  /** Information about user's video channel; may be null if there is no active video */
  video_info: groupCallParticipantVideoInfo | undefined,
  /**
   * Information about user's screen sharing video channel; may be null if there is no
   * active screen sharing video
   */
  screen_sharing_video_info: groupCallParticipantVideoInfo | undefined,
  /** The participant user's bio or the participant chat's description */
  bio: string,
  /** True, if the participant is the current user */
  is_current_user: boolean,
  /** True, if the participant is speaking as set by setGroupCallParticipantIsSpeaking */
  is_speaking: boolean,
  /** True, if the participant hand is raised */
  is_hand_raised: boolean,
  /** True, if the current user can mute the participant for all other group call participants */
  can_be_muted_for_all_users: boolean,
  /**
   * True, if the current user can allow the participant to unmute themselves or unmute
   * the participant (if the participant is the current user)
   */
  can_be_unmuted_for_all_users: boolean,
  /** True, if the current user can mute the participant only for self */
  can_be_muted_for_current_user: boolean,
  /** True, if the current user can unmute the participant for self */
  can_be_unmuted_for_current_user: boolean,
  /** True, if the participant is muted for all users */
  is_muted_for_all_users: boolean,
  /** True, if the participant is muted for the current user */
  is_muted_for_current_user: boolean,
  /** True, if the participant is muted for all users, but can unmute themselves */
  can_unmute_self: boolean,
  /** Participant's volume level; 1-20000 in hundreds of percents */
  volume_level: number,
  /**
   * User's order in the group call participant list. Orders must be compared lexicographically.
   * The bigger is order, the higher is user in the list. If order is empty, the user
   * must be removed from the participant list
   */
  order: string,
}

/** Represents a group call participant */
export type groupCallParticipant$Input = {
  readonly _: 'groupCallParticipant',
  /** Identifier of the group call participant */
  readonly participant_id?: MessageSender$Input,
  /** User's audio channel synchronization source identifier */
  readonly audio_source_id?: number,
  /** User's screen sharing audio channel synchronization source identifier */
  readonly screen_sharing_audio_source_id?: number,
  /** Information about user's video channel; may be null if there is no active video */
  readonly video_info?: groupCallParticipantVideoInfo$Input | undefined,
  /**
   * Information about user's screen sharing video channel; may be null if there is no
   * active screen sharing video
   */
  readonly screen_sharing_video_info?: groupCallParticipantVideoInfo$Input | undefined,
  /** The participant user's bio or the participant chat's description */
  readonly bio?: string,
  /** True, if the participant is the current user */
  readonly is_current_user?: boolean,
  /** True, if the participant is speaking as set by setGroupCallParticipantIsSpeaking */
  readonly is_speaking?: boolean,
  /** True, if the participant hand is raised */
  readonly is_hand_raised?: boolean,
  /** True, if the current user can mute the participant for all other group call participants */
  readonly can_be_muted_for_all_users?: boolean,
  /**
   * True, if the current user can allow the participant to unmute themselves or unmute
   * the participant (if the participant is the current user)
   */
  readonly can_be_unmuted_for_all_users?: boolean,
  /** True, if the current user can mute the participant only for self */
  readonly can_be_muted_for_current_user?: boolean,
  /** True, if the current user can unmute the participant for self */
  readonly can_be_unmuted_for_current_user?: boolean,
  /** True, if the participant is muted for all users */
  readonly is_muted_for_all_users?: boolean,
  /** True, if the participant is muted for the current user */
  readonly is_muted_for_current_user?: boolean,
  /** True, if the participant is muted for all users, but can unmute themselves */
  readonly can_unmute_self?: boolean,
  /** Participant's volume level; 1-20000 in hundreds of percents */
  readonly volume_level?: number,
  /**
   * User's order in the group call participant list. Orders must be compared lexicographically.
   * The bigger is order, the higher is user in the list. If order is empty, the user
   * must be removed from the participant list
   */
  readonly order?: string,
}

/** The user heard their own voice */
export type callProblemEcho = {
  _: 'callProblemEcho',
}

/** The user heard their own voice */
export type callProblemEcho$Input = {
  readonly _: 'callProblemEcho',
}

/** The user heard background noise */
export type callProblemNoise = {
  _: 'callProblemNoise',
}

/** The user heard background noise */
export type callProblemNoise$Input = {
  readonly _: 'callProblemNoise',
}

/** The other side kept disappearing */
export type callProblemInterruptions = {
  _: 'callProblemInterruptions',
}

/** The other side kept disappearing */
export type callProblemInterruptions$Input = {
  readonly _: 'callProblemInterruptions',
}

/** The speech was distorted */
export type callProblemDistortedSpeech = {
  _: 'callProblemDistortedSpeech',
}

/** The speech was distorted */
export type callProblemDistortedSpeech$Input = {
  readonly _: 'callProblemDistortedSpeech',
}

/** The user couldn't hear the other side */
export type callProblemSilentLocal = {
  _: 'callProblemSilentLocal',
}

/** The user couldn't hear the other side */
export type callProblemSilentLocal$Input = {
  readonly _: 'callProblemSilentLocal',
}

/** The other side couldn't hear the user */
export type callProblemSilentRemote = {
  _: 'callProblemSilentRemote',
}

/** The other side couldn't hear the user */
export type callProblemSilentRemote$Input = {
  readonly _: 'callProblemSilentRemote',
}

/** The call ended unexpectedly */
export type callProblemDropped = {
  _: 'callProblemDropped',
}

/** The call ended unexpectedly */
export type callProblemDropped$Input = {
  readonly _: 'callProblemDropped',
}

/** The video was distorted */
export type callProblemDistortedVideo = {
  _: 'callProblemDistortedVideo',
}

/** The video was distorted */
export type callProblemDistortedVideo$Input = {
  readonly _: 'callProblemDistortedVideo',
}

/** The video was pixelated */
export type callProblemPixelatedVideo = {
  _: 'callProblemPixelatedVideo',
}

/** The video was pixelated */
export type callProblemPixelatedVideo$Input = {
  readonly _: 'callProblemPixelatedVideo',
}

/** Describes a call */
export type call = {
  _: 'call',
  /** Call identifier, not persistent */
  id: number,
  /** Peer user identifier */
  user_id: number,
  /** True, if the call is outgoing */
  is_outgoing: boolean,
  /** True, if the call is a video call */
  is_video: boolean,
  /** Call state */
  state: CallState,
}

/** Describes a call */
export type call$Input = {
  readonly _: 'call',
  /** Call identifier, not persistent */
  readonly id?: number,
  /** Peer user identifier */
  readonly user_id?: number,
  /** True, if the call is outgoing */
  readonly is_outgoing?: boolean,
  /** True, if the call is a video call */
  readonly is_video?: boolean,
  /** Call state */
  readonly state?: CallState$Input,
}

/** Contains settings for the authentication of the user's phone number */
export type phoneNumberAuthenticationSettings = {
  _: 'phoneNumberAuthenticationSettings',
  /**
   * Pass true if the authentication code may be sent via a flash call to the specified
   * phone number
   */
  allow_flash_call: boolean,
  /**
   * Pass true if the authentication code may be sent via a missed call to the specified
   * phone number
   */
  allow_missed_call: boolean,
  /** Pass true if the authenticated phone number is used on the current device */
  is_current_phone_number: boolean,
  /**
   * For official applications only. True, if the application can use Android SMS Retriever
   * API (requires Google Play Services >= 10.2) to automatically receive the authentication
   * code from the SMS. See https://developers.google.com/identity/sms-retriever/ for
   * more details
   */
  allow_sms_retriever_api: boolean,
  /**
   * List of up to 20 authentication tokens, recently received in updateOption("authentication_token")
   * in previously logged out sessions
   */
  authentication_tokens: Array<string>,
}

/** Contains settings for the authentication of the user's phone number */
export type phoneNumberAuthenticationSettings$Input = {
  readonly _: 'phoneNumberAuthenticationSettings',
  /**
   * Pass true if the authentication code may be sent via a flash call to the specified
   * phone number
   */
  readonly allow_flash_call?: boolean,
  /**
   * Pass true if the authentication code may be sent via a missed call to the specified
   * phone number
   */
  readonly allow_missed_call?: boolean,
  /** Pass true if the authenticated phone number is used on the current device */
  readonly is_current_phone_number?: boolean,
  /**
   * For official applications only. True, if the application can use Android SMS Retriever
   * API (requires Google Play Services >= 10.2) to automatically receive the authentication
   * code from the SMS. See https://developers.google.com/identity/sms-retriever/ for
   * more details
   */
  readonly allow_sms_retriever_api?: boolean,
  /**
   * List of up to 20 authentication tokens, recently received in updateOption("authentication_token")
   * in previously logged out sessions
   */
  readonly authentication_tokens?: ReadonlyArray<string>,
}

/** Represents a list of animations */
export type animations = {
  _: 'animations',
  /** List of animations */
  animations: Array<animation>,
}

/** Represents a list of animations */
export type animations$Input = {
  readonly _: 'animations',
  /** List of animations */
  readonly animations?: ReadonlyArray<animation$Input>,
}

/** A regular animated sticker */
export type diceStickersRegular = {
  _: 'diceStickersRegular',
  /** The animated sticker with the dice animation */
  sticker: sticker,
}

/** A regular animated sticker */
export type diceStickersRegular$Input = {
  readonly _: 'diceStickersRegular',
  /** The animated sticker with the dice animation */
  readonly sticker?: sticker$Input,
}

/** Animated stickers to be combined into a slot machine */
export type diceStickersSlotMachine = {
  _: 'diceStickersSlotMachine',
  /**
   * The animated sticker with the slot machine background. The background animation must
   * start playing after all reel animations finish
   */
  background: sticker,
  /**
   * The animated sticker with the lever animation. The lever animation must play once
   * in the initial dice state
   */
  lever: sticker,
  /** The animated sticker with the left reel */
  left_reel: sticker,
  /** The animated sticker with the center reel */
  center_reel: sticker,
  /** The animated sticker with the right reel */
  right_reel: sticker,
}

/** Animated stickers to be combined into a slot machine */
export type diceStickersSlotMachine$Input = {
  readonly _: 'diceStickersSlotMachine',
  /**
   * The animated sticker with the slot machine background. The background animation must
   * start playing after all reel animations finish
   */
  readonly background?: sticker$Input,
  /**
   * The animated sticker with the lever animation. The lever animation must play once
   * in the initial dice state
   */
  readonly lever?: sticker$Input,
  /** The animated sticker with the left reel */
  readonly left_reel?: sticker$Input,
  /** The animated sticker with the center reel */
  readonly center_reel?: sticker$Input,
  /** The animated sticker with the right reel */
  readonly right_reel?: sticker$Input,
}

/** Represents the result of an ImportContacts request */
export type importedContacts = {
  _: 'importedContacts',
  /**
   * User identifiers of the imported contacts in the same order as they were specified
   * in the request; 0 if the contact is not yet a registered user
   */
  user_ids: Array<number>,
  /**
   * The number of users that imported the corresponding contact; 0 for already registered
   * users or if unavailable
   */
  importer_count: Array<number>,
}

/** Represents the result of an ImportContacts request */
export type importedContacts$Input = {
  readonly _: 'importedContacts',
  /**
   * User identifiers of the imported contacts in the same order as they were specified
   * in the request; 0 if the contact is not yet a registered user
   */
  readonly user_ids?: ReadonlyArray<number>,
  /**
   * The number of users that imported the corresponding contact; 0 for already registered
   * users or if unavailable
   */
  readonly importer_count?: ReadonlyArray<number>,
}

/** Contains an HTTP URL */
export type httpUrl = {
  _: 'httpUrl',
  /** The URL */
  url: string,
}

/** Contains an HTTP URL */
export type httpUrl$Input = {
  readonly _: 'httpUrl',
  /** The URL */
  readonly url?: string,
}

/**
 * Represents a link to an animated GIF or an animated (i.e., without sound) H.264/MPEG-4
 * AVC video
 */
export type inputInlineQueryResultAnimation = {
  _: 'inputInlineQueryResultAnimation',
  /** Unique identifier of the query result */
  id: string,
  /** Title of the query result */
  title: string,
  /** URL of the result thumbnail (JPEG, GIF, or MPEG4), if it exists */
  thumbnail_url: string,
  /**
   * MIME type of the video thumbnail. If non-empty, must be one of "image/jpeg", "image/gif"
   * and "video/mp4"
   */
  thumbnail_mime_type: string,
  /** The URL of the video file (file size must not exceed 1MB) */
  video_url: string,
  /** MIME type of the video file. Must be one of "image/gif" and "video/mp4" */
  video_mime_type: string,
  /** Duration of the video, in seconds */
  video_duration: number,
  /** Width of the video */
  video_width: number,
  /** Height of the video */
  video_height: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  reply_markup: ReplyMarkup,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessageAnimation, inputMessageInvoice, inputMessageLocation, inputMessageVenue
   * or inputMessageContact
   */
  input_message_content: InputMessageContent,
}

/**
 * Represents a link to an animated GIF or an animated (i.e., without sound) H.264/MPEG-4
 * AVC video
 */
export type inputInlineQueryResultAnimation$Input = {
  readonly _: 'inputInlineQueryResultAnimation',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** Title of the query result */
  readonly title?: string,
  /** URL of the result thumbnail (JPEG, GIF, or MPEG4), if it exists */
  readonly thumbnail_url?: string,
  /**
   * MIME type of the video thumbnail. If non-empty, must be one of "image/jpeg", "image/gif"
   * and "video/mp4"
   */
  readonly thumbnail_mime_type?: string,
  /** The URL of the video file (file size must not exceed 1MB) */
  readonly video_url?: string,
  /** MIME type of the video file. Must be one of "image/gif" and "video/mp4" */
  readonly video_mime_type?: string,
  /** Duration of the video, in seconds */
  readonly video_duration?: number,
  /** Width of the video */
  readonly video_width?: number,
  /** Height of the video */
  readonly video_height?: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  readonly reply_markup?: ReplyMarkup$Input,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessageAnimation, inputMessageInvoice, inputMessageLocation, inputMessageVenue
   * or inputMessageContact
   */
  readonly input_message_content?: InputMessageContent$Input,
}

/** Represents a link to an article or web page */
export type inputInlineQueryResultArticle = {
  _: 'inputInlineQueryResultArticle',
  /** Unique identifier of the query result */
  id: string,
  /** URL of the result, if it exists */
  url: string,
  /** True, if the URL must be not shown */
  hide_url: boolean,
  /** Title of the result */
  title: string,
  /** A short description of the result */
  description: string,
  /** URL of the result thumbnail, if it exists */
  thumbnail_url: string,
  /** Thumbnail width, if known */
  thumbnail_width: number,
  /** Thumbnail height, if known */
  thumbnail_height: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  reply_markup: ReplyMarkup,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   */
  input_message_content: InputMessageContent,
}

/** Represents a link to an article or web page */
export type inputInlineQueryResultArticle$Input = {
  readonly _: 'inputInlineQueryResultArticle',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** URL of the result, if it exists */
  readonly url?: string,
  /** True, if the URL must be not shown */
  readonly hide_url?: boolean,
  /** Title of the result */
  readonly title?: string,
  /** A short description of the result */
  readonly description?: string,
  /** URL of the result thumbnail, if it exists */
  readonly thumbnail_url?: string,
  /** Thumbnail width, if known */
  readonly thumbnail_width?: number,
  /** Thumbnail height, if known */
  readonly thumbnail_height?: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  readonly reply_markup?: ReplyMarkup$Input,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   */
  readonly input_message_content?: InputMessageContent$Input,
}

/** Represents a link to an MP3 audio file */
export type inputInlineQueryResultAudio = {
  _: 'inputInlineQueryResultAudio',
  /** Unique identifier of the query result */
  id: string,
  /** Title of the audio file */
  title: string,
  /** Performer of the audio file */
  performer: string,
  /** The URL of the audio file */
  audio_url: string,
  /** Audio file duration, in seconds */
  audio_duration: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  reply_markup: ReplyMarkup,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessageAudio, inputMessageInvoice, inputMessageLocation, inputMessageVenue or
   * inputMessageContact
   */
  input_message_content: InputMessageContent,
}

/** Represents a link to an MP3 audio file */
export type inputInlineQueryResultAudio$Input = {
  readonly _: 'inputInlineQueryResultAudio',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** Title of the audio file */
  readonly title?: string,
  /** Performer of the audio file */
  readonly performer?: string,
  /** The URL of the audio file */
  readonly audio_url?: string,
  /** Audio file duration, in seconds */
  readonly audio_duration?: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  readonly reply_markup?: ReplyMarkup$Input,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessageAudio, inputMessageInvoice, inputMessageLocation, inputMessageVenue or
   * inputMessageContact
   */
  readonly input_message_content?: InputMessageContent$Input,
}

/** Represents a user contact */
export type inputInlineQueryResultContact = {
  _: 'inputInlineQueryResultContact',
  /** Unique identifier of the query result */
  id: string,
  /** User contact */
  contact: contact,
  /** URL of the result thumbnail, if it exists */
  thumbnail_url: string,
  /** Thumbnail width, if known */
  thumbnail_width: number,
  /** Thumbnail height, if known */
  thumbnail_height: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  reply_markup: ReplyMarkup,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   */
  input_message_content: InputMessageContent,
}

/** Represents a user contact */
export type inputInlineQueryResultContact$Input = {
  readonly _: 'inputInlineQueryResultContact',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** User contact */
  readonly contact?: contact$Input,
  /** URL of the result thumbnail, if it exists */
  readonly thumbnail_url?: string,
  /** Thumbnail width, if known */
  readonly thumbnail_width?: number,
  /** Thumbnail height, if known */
  readonly thumbnail_height?: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  readonly reply_markup?: ReplyMarkup$Input,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   */
  readonly input_message_content?: InputMessageContent$Input,
}

/** Represents a link to a file */
export type inputInlineQueryResultDocument = {
  _: 'inputInlineQueryResultDocument',
  /** Unique identifier of the query result */
  id: string,
  /** Title of the resulting file */
  title: string,
  /** Short description of the result, if known */
  description: string,
  /** URL of the file */
  document_url: string,
  /**
   * MIME type of the file content; only "application/pdf" and "application/zip" are currently
   * allowed
   */
  mime_type: string,
  /** The URL of the file thumbnail, if it exists */
  thumbnail_url: string,
  /** Width of the thumbnail */
  thumbnail_width: number,
  /** Height of the thumbnail */
  thumbnail_height: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  reply_markup: ReplyMarkup,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessageDocument, inputMessageInvoice, inputMessageLocation, inputMessageVenue
   * or inputMessageContact
   */
  input_message_content: InputMessageContent,
}

/** Represents a link to a file */
export type inputInlineQueryResultDocument$Input = {
  readonly _: 'inputInlineQueryResultDocument',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** Title of the resulting file */
  readonly title?: string,
  /** Short description of the result, if known */
  readonly description?: string,
  /** URL of the file */
  readonly document_url?: string,
  /**
   * MIME type of the file content; only "application/pdf" and "application/zip" are currently
   * allowed
   */
  readonly mime_type?: string,
  /** The URL of the file thumbnail, if it exists */
  readonly thumbnail_url?: string,
  /** Width of the thumbnail */
  readonly thumbnail_width?: number,
  /** Height of the thumbnail */
  readonly thumbnail_height?: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  readonly reply_markup?: ReplyMarkup$Input,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessageDocument, inputMessageInvoice, inputMessageLocation, inputMessageVenue
   * or inputMessageContact
   */
  readonly input_message_content?: InputMessageContent$Input,
}

/** Represents a game */
export type inputInlineQueryResultGame = {
  _: 'inputInlineQueryResultGame',
  /** Unique identifier of the query result */
  id: string,
  /** Short name of the game */
  game_short_name: string,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  reply_markup: ReplyMarkup,
}

/** Represents a game */
export type inputInlineQueryResultGame$Input = {
  readonly _: 'inputInlineQueryResultGame',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** Short name of the game */
  readonly game_short_name?: string,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  readonly reply_markup?: ReplyMarkup$Input,
}

/** Represents a point on the map */
export type inputInlineQueryResultLocation = {
  _: 'inputInlineQueryResultLocation',
  /** Unique identifier of the query result */
  id: string,
  /** Location result */
  location: location,
  /**
   * Amount of time relative to the message sent time until the location can be updated,
   * in seconds
   */
  live_period: number,
  /** Title of the result */
  title: string,
  /** URL of the result thumbnail, if it exists */
  thumbnail_url: string,
  /** Thumbnail width, if known */
  thumbnail_width: number,
  /** Thumbnail height, if known */
  thumbnail_height: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  reply_markup: ReplyMarkup,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   */
  input_message_content: InputMessageContent,
}

/** Represents a point on the map */
export type inputInlineQueryResultLocation$Input = {
  readonly _: 'inputInlineQueryResultLocation',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** Location result */
  readonly location?: location$Input,
  /**
   * Amount of time relative to the message sent time until the location can be updated,
   * in seconds
   */
  readonly live_period?: number,
  /** Title of the result */
  readonly title?: string,
  /** URL of the result thumbnail, if it exists */
  readonly thumbnail_url?: string,
  /** Thumbnail width, if known */
  readonly thumbnail_width?: number,
  /** Thumbnail height, if known */
  readonly thumbnail_height?: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  readonly reply_markup?: ReplyMarkup$Input,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   */
  readonly input_message_content?: InputMessageContent$Input,
}

/** Represents link to a JPEG image */
export type inputInlineQueryResultPhoto = {
  _: 'inputInlineQueryResultPhoto',
  /** Unique identifier of the query result */
  id: string,
  /** Title of the result, if known */
  title: string,
  /** A short description of the result, if known */
  description: string,
  /** URL of the photo thumbnail, if it exists */
  thumbnail_url: string,
  /** The URL of the JPEG photo (photo size must not exceed 5MB) */
  photo_url: string,
  /** Width of the photo */
  photo_width: number,
  /** Height of the photo */
  photo_height: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  reply_markup: ReplyMarkup,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessagePhoto, inputMessageInvoice, inputMessageLocation, inputMessageVenue or
   * inputMessageContact
   */
  input_message_content: InputMessageContent,
}

/** Represents link to a JPEG image */
export type inputInlineQueryResultPhoto$Input = {
  readonly _: 'inputInlineQueryResultPhoto',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** Title of the result, if known */
  readonly title?: string,
  /** A short description of the result, if known */
  readonly description?: string,
  /** URL of the photo thumbnail, if it exists */
  readonly thumbnail_url?: string,
  /** The URL of the JPEG photo (photo size must not exceed 5MB) */
  readonly photo_url?: string,
  /** Width of the photo */
  readonly photo_width?: number,
  /** Height of the photo */
  readonly photo_height?: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  readonly reply_markup?: ReplyMarkup$Input,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessagePhoto, inputMessageInvoice, inputMessageLocation, inputMessageVenue or
   * inputMessageContact
   */
  readonly input_message_content?: InputMessageContent$Input,
}

/** Represents a link to a WEBP or TGS sticker */
export type inputInlineQueryResultSticker = {
  _: 'inputInlineQueryResultSticker',
  /** Unique identifier of the query result */
  id: string,
  /** URL of the sticker thumbnail, if it exists */
  thumbnail_url: string,
  /** The URL of the WEBP or TGS sticker (sticker file size must not exceed 5MB) */
  sticker_url: string,
  /** Width of the sticker */
  sticker_width: number,
  /** Height of the sticker */
  sticker_height: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  reply_markup: ReplyMarkup,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessageSticker, inputMessageInvoice, inputMessageLocation, inputMessageVenue
   * or inputMessageContact
   */
  input_message_content: InputMessageContent,
}

/** Represents a link to a WEBP or TGS sticker */
export type inputInlineQueryResultSticker$Input = {
  readonly _: 'inputInlineQueryResultSticker',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** URL of the sticker thumbnail, if it exists */
  readonly thumbnail_url?: string,
  /** The URL of the WEBP or TGS sticker (sticker file size must not exceed 5MB) */
  readonly sticker_url?: string,
  /** Width of the sticker */
  readonly sticker_width?: number,
  /** Height of the sticker */
  readonly sticker_height?: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  readonly reply_markup?: ReplyMarkup$Input,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessageSticker, inputMessageInvoice, inputMessageLocation, inputMessageVenue
   * or inputMessageContact
   */
  readonly input_message_content?: InputMessageContent$Input,
}

/** Represents information about a venue */
export type inputInlineQueryResultVenue = {
  _: 'inputInlineQueryResultVenue',
  /** Unique identifier of the query result */
  id: string,
  /** Venue result */
  venue: venue,
  /** URL of the result thumbnail, if it exists */
  thumbnail_url: string,
  /** Thumbnail width, if known */
  thumbnail_width: number,
  /** Thumbnail height, if known */
  thumbnail_height: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  reply_markup: ReplyMarkup,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   */
  input_message_content: InputMessageContent,
}

/** Represents information about a venue */
export type inputInlineQueryResultVenue$Input = {
  readonly _: 'inputInlineQueryResultVenue',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** Venue result */
  readonly venue?: venue$Input,
  /** URL of the result thumbnail, if it exists */
  readonly thumbnail_url?: string,
  /** Thumbnail width, if known */
  readonly thumbnail_width?: number,
  /** Thumbnail height, if known */
  readonly thumbnail_height?: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  readonly reply_markup?: ReplyMarkup$Input,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   */
  readonly input_message_content?: InputMessageContent$Input,
}

/** Represents a link to a page containing an embedded video player or a video file */
export type inputInlineQueryResultVideo = {
  _: 'inputInlineQueryResultVideo',
  /** Unique identifier of the query result */
  id: string,
  /** Title of the result */
  title: string,
  /** A short description of the result, if known */
  description: string,
  /** The URL of the video thumbnail (JPEG), if it exists */
  thumbnail_url: string,
  /** URL of the embedded video player or video file */
  video_url: string,
  /**
   * MIME type of the content of the video URL, only "text/html" or "video/mp4" are currently
   * supported
   */
  mime_type: string,
  /** Width of the video */
  video_width: number,
  /** Height of the video */
  video_height: number,
  /** Video duration, in seconds */
  video_duration: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  reply_markup: ReplyMarkup,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessageVideo, inputMessageInvoice, inputMessageLocation, inputMessageVenue or
   * inputMessageContact
   */
  input_message_content: InputMessageContent,
}

/** Represents a link to a page containing an embedded video player or a video file */
export type inputInlineQueryResultVideo$Input = {
  readonly _: 'inputInlineQueryResultVideo',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** Title of the result */
  readonly title?: string,
  /** A short description of the result, if known */
  readonly description?: string,
  /** The URL of the video thumbnail (JPEG), if it exists */
  readonly thumbnail_url?: string,
  /** URL of the embedded video player or video file */
  readonly video_url?: string,
  /**
   * MIME type of the content of the video URL, only "text/html" or "video/mp4" are currently
   * supported
   */
  readonly mime_type?: string,
  /** Width of the video */
  readonly video_width?: number,
  /** Height of the video */
  readonly video_height?: number,
  /** Video duration, in seconds */
  readonly video_duration?: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  readonly reply_markup?: ReplyMarkup$Input,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessageVideo, inputMessageInvoice, inputMessageLocation, inputMessageVenue or
   * inputMessageContact
   */
  readonly input_message_content?: InputMessageContent$Input,
}

/**
 * Represents a link to an opus-encoded audio file within an OGG container, single channel
 * audio
 */
export type inputInlineQueryResultVoiceNote = {
  _: 'inputInlineQueryResultVoiceNote',
  /** Unique identifier of the query result */
  id: string,
  /** Title of the voice note */
  title: string,
  /** The URL of the voice note file */
  voice_note_url: string,
  /** Duration of the voice note, in seconds */
  voice_note_duration: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  reply_markup: ReplyMarkup,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessageVoiceNote, inputMessageInvoice, inputMessageLocation, inputMessageVenue
   * or inputMessageContact
   */
  input_message_content: InputMessageContent,
}

/**
 * Represents a link to an opus-encoded audio file within an OGG container, single channel
 * audio
 */
export type inputInlineQueryResultVoiceNote$Input = {
  readonly _: 'inputInlineQueryResultVoiceNote',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** Title of the voice note */
  readonly title?: string,
  /** The URL of the voice note file */
  readonly voice_note_url?: string,
  /** Duration of the voice note, in seconds */
  readonly voice_note_duration?: number,
  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
   * or null
   */
  readonly reply_markup?: ReplyMarkup$Input,
  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText,
   * inputMessageVoiceNote, inputMessageInvoice, inputMessageLocation, inputMessageVenue
   * or inputMessageContact
   */
  readonly input_message_content?: InputMessageContent$Input,
}

/** Represents a link to an article or web page */
export type inlineQueryResultArticle = {
  _: 'inlineQueryResultArticle',
  /** Unique identifier of the query result */
  id: string,
  /** URL of the result, if it exists */
  url: string,
  /** True, if the URL must be not shown */
  hide_url: boolean,
  /** Title of the result */
  title: string,
  /** A short description of the result */
  description: string,
  /** Result thumbnail in JPEG format; may be null */
  thumbnail: thumbnail | undefined,
}

/** Represents a link to an article or web page */
export type inlineQueryResultArticle$Input = {
  readonly _: 'inlineQueryResultArticle',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** URL of the result, if it exists */
  readonly url?: string,
  /** True, if the URL must be not shown */
  readonly hide_url?: boolean,
  /** Title of the result */
  readonly title?: string,
  /** A short description of the result */
  readonly description?: string,
  /** Result thumbnail in JPEG format; may be null */
  readonly thumbnail?: thumbnail$Input | undefined,
}

/** Represents a user contact */
export type inlineQueryResultContact = {
  _: 'inlineQueryResultContact',
  /** Unique identifier of the query result */
  id: string,
  /** A user contact */
  contact: contact,
  /** Result thumbnail in JPEG format; may be null */
  thumbnail: thumbnail | undefined,
}

/** Represents a user contact */
export type inlineQueryResultContact$Input = {
  readonly _: 'inlineQueryResultContact',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** A user contact */
  readonly contact?: contact$Input,
  /** Result thumbnail in JPEG format; may be null */
  readonly thumbnail?: thumbnail$Input | undefined,
}

/** Represents a point on the map */
export type inlineQueryResultLocation = {
  _: 'inlineQueryResultLocation',
  /** Unique identifier of the query result */
  id: string,
  /** Location result */
  location: location,
  /** Title of the result */
  title: string,
  /** Result thumbnail in JPEG format; may be null */
  thumbnail: thumbnail | undefined,
}

/** Represents a point on the map */
export type inlineQueryResultLocation$Input = {
  readonly _: 'inlineQueryResultLocation',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** Location result */
  readonly location?: location$Input,
  /** Title of the result */
  readonly title?: string,
  /** Result thumbnail in JPEG format; may be null */
  readonly thumbnail?: thumbnail$Input | undefined,
}

/** Represents information about a venue */
export type inlineQueryResultVenue = {
  _: 'inlineQueryResultVenue',
  /** Unique identifier of the query result */
  id: string,
  /** Venue result */
  venue: venue,
  /** Result thumbnail in JPEG format; may be null */
  thumbnail: thumbnail | undefined,
}

/** Represents information about a venue */
export type inlineQueryResultVenue$Input = {
  readonly _: 'inlineQueryResultVenue',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** Venue result */
  readonly venue?: venue$Input,
  /** Result thumbnail in JPEG format; may be null */
  readonly thumbnail?: thumbnail$Input | undefined,
}

/** Represents information about a game */
export type inlineQueryResultGame = {
  _: 'inlineQueryResultGame',
  /** Unique identifier of the query result */
  id: string,
  /** Game result */
  game: game,
}

/** Represents information about a game */
export type inlineQueryResultGame$Input = {
  readonly _: 'inlineQueryResultGame',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** Game result */
  readonly game?: game$Input,
}

/** Represents an animation file */
export type inlineQueryResultAnimation = {
  _: 'inlineQueryResultAnimation',
  /** Unique identifier of the query result */
  id: string,
  /** Animation file */
  animation: animation,
  /** Animation title */
  title: string,
}

/** Represents an animation file */
export type inlineQueryResultAnimation$Input = {
  readonly _: 'inlineQueryResultAnimation',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** Animation file */
  readonly animation?: animation$Input,
  /** Animation title */
  readonly title?: string,
}

/** Represents an audio file */
export type inlineQueryResultAudio = {
  _: 'inlineQueryResultAudio',
  /** Unique identifier of the query result */
  id: string,
  /** Audio file */
  audio: audio,
}

/** Represents an audio file */
export type inlineQueryResultAudio$Input = {
  readonly _: 'inlineQueryResultAudio',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** Audio file */
  readonly audio?: audio$Input,
}

/** Represents a document */
export type inlineQueryResultDocument = {
  _: 'inlineQueryResultDocument',
  /** Unique identifier of the query result */
  id: string,
  /** Document */
  document: document,
  /** Document title */
  title: string,
  /** Document description */
  description: string,
}

/** Represents a document */
export type inlineQueryResultDocument$Input = {
  readonly _: 'inlineQueryResultDocument',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** Document */
  readonly document?: document$Input,
  /** Document title */
  readonly title?: string,
  /** Document description */
  readonly description?: string,
}

/** Represents a photo */
export type inlineQueryResultPhoto = {
  _: 'inlineQueryResultPhoto',
  /** Unique identifier of the query result */
  id: string,
  /** Photo */
  photo: photo,
  /** Title of the result, if known */
  title: string,
  /** A short description of the result, if known */
  description: string,
}

/** Represents a photo */
export type inlineQueryResultPhoto$Input = {
  readonly _: 'inlineQueryResultPhoto',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** Photo */
  readonly photo?: photo$Input,
  /** Title of the result, if known */
  readonly title?: string,
  /** A short description of the result, if known */
  readonly description?: string,
}

/** Represents a sticker */
export type inlineQueryResultSticker = {
  _: 'inlineQueryResultSticker',
  /** Unique identifier of the query result */
  id: string,
  /** Sticker */
  sticker: sticker,
}

/** Represents a sticker */
export type inlineQueryResultSticker$Input = {
  readonly _: 'inlineQueryResultSticker',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** Sticker */
  readonly sticker?: sticker$Input,
}

/** Represents a video */
export type inlineQueryResultVideo = {
  _: 'inlineQueryResultVideo',
  /** Unique identifier of the query result */
  id: string,
  /** Video */
  video: video,
  /** Title of the video */
  title: string,
  /** Description of the video */
  description: string,
}

/** Represents a video */
export type inlineQueryResultVideo$Input = {
  readonly _: 'inlineQueryResultVideo',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** Video */
  readonly video?: video$Input,
  /** Title of the video */
  readonly title?: string,
  /** Description of the video */
  readonly description?: string,
}

/** Represents a voice note */
export type inlineQueryResultVoiceNote = {
  _: 'inlineQueryResultVoiceNote',
  /** Unique identifier of the query result */
  id: string,
  /** Voice note */
  voice_note: voiceNote,
  /** Title of the voice note */
  title: string,
}

/** Represents a voice note */
export type inlineQueryResultVoiceNote$Input = {
  readonly _: 'inlineQueryResultVoiceNote',
  /** Unique identifier of the query result */
  readonly id?: string,
  /** Voice note */
  readonly voice_note?: voiceNote$Input,
  /** Title of the voice note */
  readonly title?: string,
}

/**
 * Represents the results of the inline query. Use sendInlineQueryResultMessage to send
 * the result of the query
 */
export type inlineQueryResults = {
  _: 'inlineQueryResults',
  /** Unique identifier of the inline query */
  inline_query_id: number | string,
  /** The offset for the next request. If empty, there are no more results */
  next_offset: string,
  /** Results of the query */
  results: Array<InlineQueryResult>,
  /**
   * If non-empty, this text must be shown on the button, which opens a private chat with
   * the bot and sends the bot a start message with the switch_pm_parameter
   */
  switch_pm_text: string,
  /** Parameter for the bot start message */
  switch_pm_parameter: string,
}

/**
 * Represents the results of the inline query. Use sendInlineQueryResultMessage to send
 * the result of the query
 */
export type inlineQueryResults$Input = {
  readonly _: 'inlineQueryResults',
  /** Unique identifier of the inline query */
  readonly inline_query_id?: number | string,
  /** The offset for the next request. If empty, there are no more results */
  readonly next_offset?: string,
  /** Results of the query */
  readonly results?: ReadonlyArray<InlineQueryResult$Input>,
  /**
   * If non-empty, this text must be shown on the button, which opens a private chat with
   * the bot and sends the bot a start message with the switch_pm_parameter
   */
  readonly switch_pm_text?: string,
  /** Parameter for the bot start message */
  readonly switch_pm_parameter?: string,
}

/** The payload for a general callback button */
export type callbackQueryPayloadData = {
  _: 'callbackQueryPayloadData',
  /** Data that was attached to the callback button */
  data: string,
}

/** The payload for a general callback button */
export type callbackQueryPayloadData$Input = {
  readonly _: 'callbackQueryPayloadData',
  /** Data that was attached to the callback button */
  readonly data?: string,
}

/** The payload for a callback button requiring password */
export type callbackQueryPayloadDataWithPassword = {
  _: 'callbackQueryPayloadDataWithPassword',
  /** The password for the current user */
  password: string,
  /** Data that was attached to the callback button */
  data: string,
}

/** The payload for a callback button requiring password */
export type callbackQueryPayloadDataWithPassword$Input = {
  readonly _: 'callbackQueryPayloadDataWithPassword',
  /** The password for the current user */
  readonly password?: string,
  /** Data that was attached to the callback button */
  readonly data?: string,
}

/** The payload for a game callback button */
export type callbackQueryPayloadGame = {
  _: 'callbackQueryPayloadGame',
  /** A short name of the game that was attached to the callback button */
  game_short_name: string,
}

/** The payload for a game callback button */
export type callbackQueryPayloadGame$Input = {
  readonly _: 'callbackQueryPayloadGame',
  /** A short name of the game that was attached to the callback button */
  readonly game_short_name?: string,
}

/** Contains a bot's answer to a callback query */
export type callbackQueryAnswer = {
  _: 'callbackQueryAnswer',
  /** Text of the answer */
  text: string,
  /** True, if an alert must be shown to the user instead of a toast notification */
  show_alert: boolean,
  /** URL to be opened */
  url: string,
}

/** Contains a bot's answer to a callback query */
export type callbackQueryAnswer$Input = {
  readonly _: 'callbackQueryAnswer',
  /** Text of the answer */
  readonly text?: string,
  /** True, if an alert must be shown to the user instead of a toast notification */
  readonly show_alert?: boolean,
  /** URL to be opened */
  readonly url?: string,
}

/** Contains the result of a custom request */
export type customRequestResult = {
  _: 'customRequestResult',
  /** A JSON-serialized result */
  result: string,
}

/** Contains the result of a custom request */
export type customRequestResult$Input = {
  readonly _: 'customRequestResult',
  /** A JSON-serialized result */
  readonly result?: string,
}

/** Contains one row of the game high score table */
export type gameHighScore = {
  _: 'gameHighScore',
  /** Position in the high score table */
  position: number,
  /** User identifier */
  user_id: number,
  /** User score */
  score: number,
}

/** Contains one row of the game high score table */
export type gameHighScore$Input = {
  readonly _: 'gameHighScore',
  /** Position in the high score table */
  readonly position?: number,
  /** User identifier */
  readonly user_id?: number,
  /** User score */
  readonly score?: number,
}

/** Contains a list of game high scores */
export type gameHighScores = {
  _: 'gameHighScores',
  /** A list of game high scores */
  scores: Array<gameHighScore>,
}

/** Contains a list of game high scores */
export type gameHighScores$Input = {
  readonly _: 'gameHighScores',
  /** A list of game high scores */
  readonly scores?: ReadonlyArray<gameHighScore$Input>,
}

/** A message was edited */
export type chatEventMessageEdited = {
  _: 'chatEventMessageEdited',
  /** The original message before the edit */
  old_message: message,
  /** The message after it was edited */
  new_message: message,
}

/** A message was edited */
export type chatEventMessageEdited$Input = {
  readonly _: 'chatEventMessageEdited',
  /** The original message before the edit */
  readonly old_message?: message$Input,
  /** The message after it was edited */
  readonly new_message?: message$Input,
}

/** A message was deleted */
export type chatEventMessageDeleted = {
  _: 'chatEventMessageDeleted',
  /** Deleted message */
  message: message,
}

/** A message was deleted */
export type chatEventMessageDeleted$Input = {
  readonly _: 'chatEventMessageDeleted',
  /** Deleted message */
  readonly message?: message$Input,
}

/** A poll in a message was stopped */
export type chatEventPollStopped = {
  _: 'chatEventPollStopped',
  /** The message with the poll */
  message: message,
}

/** A poll in a message was stopped */
export type chatEventPollStopped$Input = {
  readonly _: 'chatEventPollStopped',
  /** The message with the poll */
  readonly message?: message$Input,
}

/** A message was pinned */
export type chatEventMessagePinned = {
  _: 'chatEventMessagePinned',
  /** Pinned message */
  message: message,
}

/** A message was pinned */
export type chatEventMessagePinned$Input = {
  readonly _: 'chatEventMessagePinned',
  /** Pinned message */
  readonly message?: message$Input,
}

/** A message was unpinned */
export type chatEventMessageUnpinned = {
  _: 'chatEventMessageUnpinned',
  /** Unpinned message */
  message: message,
}

/** A message was unpinned */
export type chatEventMessageUnpinned$Input = {
  readonly _: 'chatEventMessageUnpinned',
  /** Unpinned message */
  readonly message?: message$Input,
}

/** A new member joined the chat */
export type chatEventMemberJoined = {
  _: 'chatEventMemberJoined',
}

/** A new member joined the chat */
export type chatEventMemberJoined$Input = {
  readonly _: 'chatEventMemberJoined',
}

/** A new member joined the chat via an invite link */
export type chatEventMemberJoinedByInviteLink = {
  _: 'chatEventMemberJoinedByInviteLink',
  /** Invite link used to join the chat */
  invite_link: chatInviteLink,
}

/** A new member joined the chat via an invite link */
export type chatEventMemberJoinedByInviteLink$Input = {
  readonly _: 'chatEventMemberJoinedByInviteLink',
  /** Invite link used to join the chat */
  readonly invite_link?: chatInviteLink$Input,
}

/** A new member was accepted to the chat by an administrator */
export type chatEventMemberJoinedByRequest = {
  _: 'chatEventMemberJoinedByRequest',
  /** User identifier of the chat administrator, approved user join request */
  approver_user_id: number,
  /** Invite link used to join the chat; may be null */
  invite_link: chatInviteLink | undefined,
}

/** A new member was accepted to the chat by an administrator */
export type chatEventMemberJoinedByRequest$Input = {
  readonly _: 'chatEventMemberJoinedByRequest',
  /** User identifier of the chat administrator, approved user join request */
  readonly approver_user_id?: number,
  /** Invite link used to join the chat; may be null */
  readonly invite_link?: chatInviteLink$Input | undefined,
}

/** A member left the chat */
export type chatEventMemberLeft = {
  _: 'chatEventMemberLeft',
}

/** A member left the chat */
export type chatEventMemberLeft$Input = {
  readonly _: 'chatEventMemberLeft',
}

/** A new chat member was invited */
export type chatEventMemberInvited = {
  _: 'chatEventMemberInvited',
  /** New member user identifier */
  user_id: number,
  /** New member status */
  status: ChatMemberStatus,
}

/** A new chat member was invited */
export type chatEventMemberInvited$Input = {
  readonly _: 'chatEventMemberInvited',
  /** New member user identifier */
  readonly user_id?: number,
  /** New member status */
  readonly status?: ChatMemberStatus$Input,
}

/**
 * A chat member has gained/lost administrator status, or the list of their administrator
 * privileges has changed
 */
export type chatEventMemberPromoted = {
  _: 'chatEventMemberPromoted',
  /** Affected chat member user identifier */
  user_id: number,
  /** Previous status of the chat member */
  old_status: ChatMemberStatus,
  /** New status of the chat member */
  new_status: ChatMemberStatus,
}

/**
 * A chat member has gained/lost administrator status, or the list of their administrator
 * privileges has changed
 */
export type chatEventMemberPromoted$Input = {
  readonly _: 'chatEventMemberPromoted',
  /** Affected chat member user identifier */
  readonly user_id?: number,
  /** Previous status of the chat member */
  readonly old_status?: ChatMemberStatus$Input,
  /** New status of the chat member */
  readonly new_status?: ChatMemberStatus$Input,
}

/**
 * A chat member was restricted/unrestricted or banned/unbanned, or the list of their
 * restrictions has changed
 */
export type chatEventMemberRestricted = {
  _: 'chatEventMemberRestricted',
  /** Affected chat member identifier */
  member_id: MessageSender,
  /** Previous status of the chat member */
  old_status: ChatMemberStatus,
  /** New status of the chat member */
  new_status: ChatMemberStatus,
}

/**
 * A chat member was restricted/unrestricted or banned/unbanned, or the list of their
 * restrictions has changed
 */
export type chatEventMemberRestricted$Input = {
  readonly _: 'chatEventMemberRestricted',
  /** Affected chat member identifier */
  readonly member_id?: MessageSender$Input,
  /** Previous status of the chat member */
  readonly old_status?: ChatMemberStatus$Input,
  /** New status of the chat member */
  readonly new_status?: ChatMemberStatus$Input,
}

/** The chat title was changed */
export type chatEventTitleChanged = {
  _: 'chatEventTitleChanged',
  /** Previous chat title */
  old_title: string,
  /** New chat title */
  new_title: string,
}

/** The chat title was changed */
export type chatEventTitleChanged$Input = {
  readonly _: 'chatEventTitleChanged',
  /** Previous chat title */
  readonly old_title?: string,
  /** New chat title */
  readonly new_title?: string,
}

/** The chat permissions was changed */
export type chatEventPermissionsChanged = {
  _: 'chatEventPermissionsChanged',
  /** Previous chat permissions */
  old_permissions: chatPermissions,
  /** New chat permissions */
  new_permissions: chatPermissions,
}

/** The chat permissions was changed */
export type chatEventPermissionsChanged$Input = {
  readonly _: 'chatEventPermissionsChanged',
  /** Previous chat permissions */
  readonly old_permissions?: chatPermissions$Input,
  /** New chat permissions */
  readonly new_permissions?: chatPermissions$Input,
}

/** The chat description was changed */
export type chatEventDescriptionChanged = {
  _: 'chatEventDescriptionChanged',
  /** Previous chat description */
  old_description: string,
  /** New chat description */
  new_description: string,
}

/** The chat description was changed */
export type chatEventDescriptionChanged$Input = {
  readonly _: 'chatEventDescriptionChanged',
  /** Previous chat description */
  readonly old_description?: string,
  /** New chat description */
  readonly new_description?: string,
}

/** The chat username was changed */
export type chatEventUsernameChanged = {
  _: 'chatEventUsernameChanged',
  /** Previous chat username */
  old_username: string,
  /** New chat username */
  new_username: string,
}

/** The chat username was changed */
export type chatEventUsernameChanged$Input = {
  readonly _: 'chatEventUsernameChanged',
  /** Previous chat username */
  readonly old_username?: string,
  /** New chat username */
  readonly new_username?: string,
}

/** The chat photo was changed */
export type chatEventPhotoChanged = {
  _: 'chatEventPhotoChanged',
  /** Previous chat photo value; may be null */
  old_photo: chatPhoto | undefined,
  /** New chat photo value; may be null */
  new_photo: chatPhoto | undefined,
}

/** The chat photo was changed */
export type chatEventPhotoChanged$Input = {
  readonly _: 'chatEventPhotoChanged',
  /** Previous chat photo value; may be null */
  readonly old_photo?: chatPhoto$Input | undefined,
  /** New chat photo value; may be null */
  readonly new_photo?: chatPhoto$Input | undefined,
}

/** The can_invite_users permission of a supergroup chat was toggled */
export type chatEventInvitesToggled = {
  _: 'chatEventInvitesToggled',
  /** New value of can_invite_users permission */
  can_invite_users: boolean,
}

/** The can_invite_users permission of a supergroup chat was toggled */
export type chatEventInvitesToggled$Input = {
  readonly _: 'chatEventInvitesToggled',
  /** New value of can_invite_users permission */
  readonly can_invite_users?: boolean,
}

/** The linked chat of a supergroup was changed */
export type chatEventLinkedChatChanged = {
  _: 'chatEventLinkedChatChanged',
  /** Previous supergroup linked chat identifier */
  old_linked_chat_id: number,
  /** New supergroup linked chat identifier */
  new_linked_chat_id: number,
}

/** The linked chat of a supergroup was changed */
export type chatEventLinkedChatChanged$Input = {
  readonly _: 'chatEventLinkedChatChanged',
  /** Previous supergroup linked chat identifier */
  readonly old_linked_chat_id?: number,
  /** New supergroup linked chat identifier */
  readonly new_linked_chat_id?: number,
}

/** The slow_mode_delay setting of a supergroup was changed */
export type chatEventSlowModeDelayChanged = {
  _: 'chatEventSlowModeDelayChanged',
  /** Previous value of slow_mode_delay, in seconds */
  old_slow_mode_delay: number,
  /** New value of slow_mode_delay, in seconds */
  new_slow_mode_delay: number,
}

/** The slow_mode_delay setting of a supergroup was changed */
export type chatEventSlowModeDelayChanged$Input = {
  readonly _: 'chatEventSlowModeDelayChanged',
  /** Previous value of slow_mode_delay, in seconds */
  readonly old_slow_mode_delay?: number,
  /** New value of slow_mode_delay, in seconds */
  readonly new_slow_mode_delay?: number,
}

/** The message TTL was changed */
export type chatEventMessageTtlChanged = {
  _: 'chatEventMessageTtlChanged',
  /** Previous value of message_ttl */
  old_message_ttl: number,
  /** New value of message_ttl */
  new_message_ttl: number,
}

/** The message TTL was changed */
export type chatEventMessageTtlChanged$Input = {
  readonly _: 'chatEventMessageTtlChanged',
  /** Previous value of message_ttl */
  readonly old_message_ttl?: number,
  /** New value of message_ttl */
  readonly new_message_ttl?: number,
}

/** The sign_messages setting of a channel was toggled */
export type chatEventSignMessagesToggled = {
  _: 'chatEventSignMessagesToggled',
  /** New value of sign_messages */
  sign_messages: boolean,
}

/** The sign_messages setting of a channel was toggled */
export type chatEventSignMessagesToggled$Input = {
  readonly _: 'chatEventSignMessagesToggled',
  /** New value of sign_messages */
  readonly sign_messages?: boolean,
}

/** The has_protected_content setting of a channel was toggled */
export type chatEventHasProtectedContentToggled = {
  _: 'chatEventHasProtectedContentToggled',
  /** New value of has_protected_content */
  has_protected_content: boolean,
}

/** The has_protected_content setting of a channel was toggled */
export type chatEventHasProtectedContentToggled$Input = {
  readonly _: 'chatEventHasProtectedContentToggled',
  /** New value of has_protected_content */
  readonly has_protected_content?: boolean,
}

/** The supergroup sticker set was changed */
export type chatEventStickerSetChanged = {
  _: 'chatEventStickerSetChanged',
  /** Previous identifier of the chat sticker set; 0 if none */
  old_sticker_set_id: number | string,
  /** New identifier of the chat sticker set; 0 if none */
  new_sticker_set_id: number | string,
}

/** The supergroup sticker set was changed */
export type chatEventStickerSetChanged$Input = {
  readonly _: 'chatEventStickerSetChanged',
  /** Previous identifier of the chat sticker set; 0 if none */
  readonly old_sticker_set_id?: number | string,
  /** New identifier of the chat sticker set; 0 if none */
  readonly new_sticker_set_id?: number | string,
}

/** The supergroup location was changed */
export type chatEventLocationChanged = {
  _: 'chatEventLocationChanged',
  /** Previous location; may be null */
  old_location: chatLocation | undefined,
  /** New location; may be null */
  new_location: chatLocation | undefined,
}

/** The supergroup location was changed */
export type chatEventLocationChanged$Input = {
  readonly _: 'chatEventLocationChanged',
  /** Previous location; may be null */
  readonly old_location?: chatLocation$Input | undefined,
  /** New location; may be null */
  readonly new_location?: chatLocation$Input | undefined,
}

/** The is_all_history_available setting of a supergroup was toggled */
export type chatEventIsAllHistoryAvailableToggled = {
  _: 'chatEventIsAllHistoryAvailableToggled',
  /** New value of is_all_history_available */
  is_all_history_available: boolean,
}

/** The is_all_history_available setting of a supergroup was toggled */
export type chatEventIsAllHistoryAvailableToggled$Input = {
  readonly _: 'chatEventIsAllHistoryAvailableToggled',
  /** New value of is_all_history_available */
  readonly is_all_history_available?: boolean,
}

/** A chat invite link was edited */
export type chatEventInviteLinkEdited = {
  _: 'chatEventInviteLinkEdited',
  /** Previous information about the invite link */
  old_invite_link: chatInviteLink,
  /** New information about the invite link */
  new_invite_link: chatInviteLink,
}

/** A chat invite link was edited */
export type chatEventInviteLinkEdited$Input = {
  readonly _: 'chatEventInviteLinkEdited',
  /** Previous information about the invite link */
  readonly old_invite_link?: chatInviteLink$Input,
  /** New information about the invite link */
  readonly new_invite_link?: chatInviteLink$Input,
}

/** A chat invite link was revoked */
export type chatEventInviteLinkRevoked = {
  _: 'chatEventInviteLinkRevoked',
  /** The invite link */
  invite_link: chatInviteLink,
}

/** A chat invite link was revoked */
export type chatEventInviteLinkRevoked$Input = {
  readonly _: 'chatEventInviteLinkRevoked',
  /** The invite link */
  readonly invite_link?: chatInviteLink$Input,
}

/** A revoked chat invite link was deleted */
export type chatEventInviteLinkDeleted = {
  _: 'chatEventInviteLinkDeleted',
  /** The invite link */
  invite_link: chatInviteLink,
}

/** A revoked chat invite link was deleted */
export type chatEventInviteLinkDeleted$Input = {
  readonly _: 'chatEventInviteLinkDeleted',
  /** The invite link */
  readonly invite_link?: chatInviteLink$Input,
}

/** A video chat was created */
export type chatEventVideoChatCreated = {
  _: 'chatEventVideoChatCreated',
  /** Identifier of the video chat. The video chat can be received through the method getGroupCall */
  group_call_id: number,
}

/** A video chat was created */
export type chatEventVideoChatCreated$Input = {
  readonly _: 'chatEventVideoChatCreated',
  /** Identifier of the video chat. The video chat can be received through the method getGroupCall */
  readonly group_call_id?: number,
}

/** A video chat was ended */
export type chatEventVideoChatEnded = {
  _: 'chatEventVideoChatEnded',
  /** Identifier of the video chat. The video chat can be received through the method getGroupCall */
  group_call_id: number,
}

/** A video chat was ended */
export type chatEventVideoChatEnded$Input = {
  readonly _: 'chatEventVideoChatEnded',
  /** Identifier of the video chat. The video chat can be received through the method getGroupCall */
  readonly group_call_id?: number,
}

/** A video chat participant was muted or unmuted */
export type chatEventVideoChatParticipantIsMutedToggled = {
  _: 'chatEventVideoChatParticipantIsMutedToggled',
  /** Identifier of the affected group call participant */
  participant_id: MessageSender,
  /** New value of is_muted */
  is_muted: boolean,
}

/** A video chat participant was muted or unmuted */
export type chatEventVideoChatParticipantIsMutedToggled$Input = {
  readonly _: 'chatEventVideoChatParticipantIsMutedToggled',
  /** Identifier of the affected group call participant */
  readonly participant_id?: MessageSender$Input,
  /** New value of is_muted */
  readonly is_muted?: boolean,
}

/** A video chat participant volume level was changed */
export type chatEventVideoChatParticipantVolumeLevelChanged = {
  _: 'chatEventVideoChatParticipantVolumeLevelChanged',
  /** Identifier of the affected group call participant */
  participant_id: MessageSender,
  /** New value of volume_level; 1-20000 in hundreds of percents */
  volume_level: number,
}

/** A video chat participant volume level was changed */
export type chatEventVideoChatParticipantVolumeLevelChanged$Input = {
  readonly _: 'chatEventVideoChatParticipantVolumeLevelChanged',
  /** Identifier of the affected group call participant */
  readonly participant_id?: MessageSender$Input,
  /** New value of volume_level; 1-20000 in hundreds of percents */
  readonly volume_level?: number,
}

/** The mute_new_participants setting of a video chat was toggled */
export type chatEventVideoChatMuteNewParticipantsToggled = {
  _: 'chatEventVideoChatMuteNewParticipantsToggled',
  /** New value of the mute_new_participants setting */
  mute_new_participants: boolean,
}

/** The mute_new_participants setting of a video chat was toggled */
export type chatEventVideoChatMuteNewParticipantsToggled$Input = {
  readonly _: 'chatEventVideoChatMuteNewParticipantsToggled',
  /** New value of the mute_new_participants setting */
  readonly mute_new_participants?: boolean,
}

/** Represents a chat event */
export type chatEvent = {
  _: 'chatEvent',
  /** Chat event identifier */
  id: number | string,
  /** Point in time (Unix timestamp) when the event happened */
  date: number,
  /** Identifier of the user or chat who performed the action */
  member_id: MessageSender,
  /** The action */
  action: ChatEventAction,
}

/** Represents a chat event */
export type chatEvent$Input = {
  readonly _: 'chatEvent',
  /** Chat event identifier */
  readonly id?: number | string,
  /** Point in time (Unix timestamp) when the event happened */
  readonly date?: number,
  /** Identifier of the user or chat who performed the action */
  readonly member_id?: MessageSender$Input,
  /** The action */
  readonly action?: ChatEventAction$Input,
}

/** Contains a list of chat events */
export type chatEvents = {
  _: 'chatEvents',
  /** List of events */
  events: Array<chatEvent>,
}

/** Contains a list of chat events */
export type chatEvents$Input = {
  readonly _: 'chatEvents',
  /** List of events */
  readonly events?: ReadonlyArray<chatEvent$Input>,
}

/** Represents a set of filters used to obtain a chat event log */
export type chatEventLogFilters = {
  _: 'chatEventLogFilters',
  /** True, if message edits need to be returned */
  message_edits: boolean,
  /** True, if message deletions need to be returned */
  message_deletions: boolean,
  /** True, if pin/unpin events need to be returned */
  message_pins: boolean,
  /** True, if members joining events need to be returned */
  member_joins: boolean,
  /** True, if members leaving events need to be returned */
  member_leaves: boolean,
  /** True, if invited member events need to be returned */
  member_invites: boolean,
  /** True, if member promotion/demotion events need to be returned */
  member_promotions: boolean,
  /** True, if member restricted/unrestricted/banned/unbanned events need to be returned */
  member_restrictions: boolean,
  /** True, if changes in chat information need to be returned */
  info_changes: boolean,
  /** True, if changes in chat settings need to be returned */
  setting_changes: boolean,
  /** True, if changes to invite links need to be returned */
  invite_link_changes: boolean,
  /** True, if video chat actions need to be returned */
  video_chat_changes: boolean,
}

/** Represents a set of filters used to obtain a chat event log */
export type chatEventLogFilters$Input = {
  readonly _: 'chatEventLogFilters',
  /** True, if message edits need to be returned */
  readonly message_edits?: boolean,
  /** True, if message deletions need to be returned */
  readonly message_deletions?: boolean,
  /** True, if pin/unpin events need to be returned */
  readonly message_pins?: boolean,
  /** True, if members joining events need to be returned */
  readonly member_joins?: boolean,
  /** True, if members leaving events need to be returned */
  readonly member_leaves?: boolean,
  /** True, if invited member events need to be returned */
  readonly member_invites?: boolean,
  /** True, if member promotion/demotion events need to be returned */
  readonly member_promotions?: boolean,
  /** True, if member restricted/unrestricted/banned/unbanned events need to be returned */
  readonly member_restrictions?: boolean,
  /** True, if changes in chat information need to be returned */
  readonly info_changes?: boolean,
  /** True, if changes in chat settings need to be returned */
  readonly setting_changes?: boolean,
  /** True, if changes to invite links need to be returned */
  readonly invite_link_changes?: boolean,
  /** True, if video chat actions need to be returned */
  readonly video_chat_changes?: boolean,
}

/** An ordinary language pack string */
export type languagePackStringValueOrdinary = {
  _: 'languagePackStringValueOrdinary',
  /** String value */
  value: string,
}

/** An ordinary language pack string */
export type languagePackStringValueOrdinary$Input = {
  readonly _: 'languagePackStringValueOrdinary',
  /** String value */
  readonly value?: string,
}

/**
 * A language pack string which has different forms based on the number of some object
 * it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
 * for more info
 */
export type languagePackStringValuePluralized = {
  _: 'languagePackStringValuePluralized',
  /** Value for zero objects */
  zero_value: string,
  /** Value for one object */
  one_value: string,
  /** Value for two objects */
  two_value: string,
  /** Value for few objects */
  few_value: string,
  /** Value for many objects */
  many_value: string,
  /** Default value */
  other_value: string,
}

/**
 * A language pack string which has different forms based on the number of some object
 * it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
 * for more info
 */
export type languagePackStringValuePluralized$Input = {
  readonly _: 'languagePackStringValuePluralized',
  /** Value for zero objects */
  readonly zero_value?: string,
  /** Value for one object */
  readonly one_value?: string,
  /** Value for two objects */
  readonly two_value?: string,
  /** Value for few objects */
  readonly few_value?: string,
  /** Value for many objects */
  readonly many_value?: string,
  /** Default value */
  readonly other_value?: string,
}

/**
 * A deleted language pack string, the value must be taken from the built-in English
 * language pack
 */
export type languagePackStringValueDeleted = {
  _: 'languagePackStringValueDeleted',
}

/**
 * A deleted language pack string, the value must be taken from the built-in English
 * language pack
 */
export type languagePackStringValueDeleted$Input = {
  readonly _: 'languagePackStringValueDeleted',
}

/** Represents one language pack string */
export type languagePackString = {
  _: 'languagePackString',
  /** String key */
  key: string,
  /**
   * String value; pass null if the string needs to be taken from the built-in English
   * language pack
   */
  value: LanguagePackStringValue,
}

/** Represents one language pack string */
export type languagePackString$Input = {
  readonly _: 'languagePackString',
  /** String key */
  readonly key?: string,
  /**
   * String value; pass null if the string needs to be taken from the built-in English
   * language pack
   */
  readonly value?: LanguagePackStringValue$Input,
}

/** Contains a list of language pack strings */
export type languagePackStrings = {
  _: 'languagePackStrings',
  /** A list of language pack strings */
  strings: Array<languagePackString>,
}

/** Contains a list of language pack strings */
export type languagePackStrings$Input = {
  readonly _: 'languagePackStrings',
  /** A list of language pack strings */
  readonly strings?: ReadonlyArray<languagePackString$Input>,
}

/** Contains information about a language pack */
export type languagePackInfo = {
  _: 'languagePackInfo',
  /** Unique language pack identifier */
  id: string,
  /**
   * Identifier of a base language pack; may be empty. If a string is missed in the language
   * pack, then it must be fetched from base language pack. Unsupported in custom language
   * packs
   */
  base_language_pack_id: string,
  /** Language name */
  name: string,
  /** Name of the language in that language */
  native_name: string,
  /**
   * A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
   * for more info
   */
  plural_code: string,
  /** True, if the language pack is official */
  is_official: boolean,
  /** True, if the language pack strings are RTL */
  is_rtl: boolean,
  /** True, if the language pack is a beta language pack */
  is_beta: boolean,
  /** True, if the language pack is installed by the current user */
  is_installed: boolean,
  /** Total number of non-deleted strings from the language pack */
  total_string_count: number,
  /** Total number of translated strings from the language pack */
  translated_string_count: number,
  /** Total number of non-deleted strings from the language pack available locally */
  local_string_count: number,
  /** Link to language translation interface; empty for custom local language packs */
  translation_url: string,
}

/** Contains information about a language pack */
export type languagePackInfo$Input = {
  readonly _: 'languagePackInfo',
  /** Unique language pack identifier */
  readonly id?: string,
  /**
   * Identifier of a base language pack; may be empty. If a string is missed in the language
   * pack, then it must be fetched from base language pack. Unsupported in custom language
   * packs
   */
  readonly base_language_pack_id?: string,
  /** Language name */
  readonly name?: string,
  /** Name of the language in that language */
  readonly native_name?: string,
  /**
   * A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
   * for more info
   */
  readonly plural_code?: string,
  /** True, if the language pack is official */
  readonly is_official?: boolean,
  /** True, if the language pack strings are RTL */
  readonly is_rtl?: boolean,
  /** True, if the language pack is a beta language pack */
  readonly is_beta?: boolean,
  /** True, if the language pack is installed by the current user */
  readonly is_installed?: boolean,
  /** Total number of non-deleted strings from the language pack */
  readonly total_string_count?: number,
  /** Total number of translated strings from the language pack */
  readonly translated_string_count?: number,
  /** Total number of non-deleted strings from the language pack available locally */
  readonly local_string_count?: number,
  /** Link to language translation interface; empty for custom local language packs */
  readonly translation_url?: string,
}

/** Contains information about the current localization target */
export type localizationTargetInfo = {
  _: 'localizationTargetInfo',
  /** List of available language packs for this application */
  language_packs: Array<languagePackInfo>,
}

/** Contains information about the current localization target */
export type localizationTargetInfo$Input = {
  readonly _: 'localizationTargetInfo',
  /** List of available language packs for this application */
  readonly language_packs?: ReadonlyArray<languagePackInfo$Input>,
}

/** A token for Firebase Cloud Messaging */
export type deviceTokenFirebaseCloudMessaging = {
  _: 'deviceTokenFirebaseCloudMessaging',
  /** Device registration token; may be empty to deregister a device */
  token: string,
  /** True, if push notifications must be additionally encrypted */
  encrypt: boolean,
}

/** A token for Firebase Cloud Messaging */
export type deviceTokenFirebaseCloudMessaging$Input = {
  readonly _: 'deviceTokenFirebaseCloudMessaging',
  /** Device registration token; may be empty to deregister a device */
  readonly token?: string,
  /** True, if push notifications must be additionally encrypted */
  readonly encrypt?: boolean,
}

/** A token for Apple Push Notification service */
export type deviceTokenApplePush = {
  _: 'deviceTokenApplePush',
  /** Device token; may be empty to deregister a device */
  device_token: string,
  /** True, if App Sandbox is enabled */
  is_app_sandbox: boolean,
}

/** A token for Apple Push Notification service */
export type deviceTokenApplePush$Input = {
  readonly _: 'deviceTokenApplePush',
  /** Device token; may be empty to deregister a device */
  readonly device_token?: string,
  /** True, if App Sandbox is enabled */
  readonly is_app_sandbox?: boolean,
}

/** A token for Apple Push Notification service VoIP notifications */
export type deviceTokenApplePushVoIP = {
  _: 'deviceTokenApplePushVoIP',
  /** Device token; may be empty to deregister a device */
  device_token: string,
  /** True, if App Sandbox is enabled */
  is_app_sandbox: boolean,
  /** True, if push notifications must be additionally encrypted */
  encrypt: boolean,
}

/** A token for Apple Push Notification service VoIP notifications */
export type deviceTokenApplePushVoIP$Input = {
  readonly _: 'deviceTokenApplePushVoIP',
  /** Device token; may be empty to deregister a device */
  readonly device_token?: string,
  /** True, if App Sandbox is enabled */
  readonly is_app_sandbox?: boolean,
  /** True, if push notifications must be additionally encrypted */
  readonly encrypt?: boolean,
}

/** A token for Windows Push Notification Services */
export type deviceTokenWindowsPush = {
  _: 'deviceTokenWindowsPush',
  /**
   * The access token that will be used to send notifications; may be empty to deregister
   * a device
   */
  access_token: string,
}

/** A token for Windows Push Notification Services */
export type deviceTokenWindowsPush$Input = {
  readonly _: 'deviceTokenWindowsPush',
  /**
   * The access token that will be used to send notifications; may be empty to deregister
   * a device
   */
  readonly access_token?: string,
}

/** A token for Microsoft Push Notification Service */
export type deviceTokenMicrosoftPush = {
  _: 'deviceTokenMicrosoftPush',
  /** Push notification channel URI; may be empty to deregister a device */
  channel_uri: string,
}

/** A token for Microsoft Push Notification Service */
export type deviceTokenMicrosoftPush$Input = {
  readonly _: 'deviceTokenMicrosoftPush',
  /** Push notification channel URI; may be empty to deregister a device */
  readonly channel_uri?: string,
}

/** A token for Microsoft Push Notification Service VoIP channel */
export type deviceTokenMicrosoftPushVoIP = {
  _: 'deviceTokenMicrosoftPushVoIP',
  /** Push notification channel URI; may be empty to deregister a device */
  channel_uri: string,
}

/** A token for Microsoft Push Notification Service VoIP channel */
export type deviceTokenMicrosoftPushVoIP$Input = {
  readonly _: 'deviceTokenMicrosoftPushVoIP',
  /** Push notification channel URI; may be empty to deregister a device */
  readonly channel_uri?: string,
}

/** A token for web Push API */
export type deviceTokenWebPush = {
  _: 'deviceTokenWebPush',
  /**
   * Absolute URL exposed by the push service where the application server can send push
   * messages; may be empty to deregister a device
   */
  endpoint: string,
  /** Base64url-encoded P-256 elliptic curve Diffie-Hellman public key */
  p256dh_base64url: string,
  /** Base64url-encoded authentication secret */
  auth_base64url: string,
}

/** A token for web Push API */
export type deviceTokenWebPush$Input = {
  readonly _: 'deviceTokenWebPush',
  /**
   * Absolute URL exposed by the push service where the application server can send push
   * messages; may be empty to deregister a device
   */
  readonly endpoint?: string,
  /** Base64url-encoded P-256 elliptic curve Diffie-Hellman public key */
  readonly p256dh_base64url?: string,
  /** Base64url-encoded authentication secret */
  readonly auth_base64url?: string,
}

/** A token for Simple Push API for Firefox OS */
export type deviceTokenSimplePush = {
  _: 'deviceTokenSimplePush',
  /**
   * Absolute URL exposed by the push service where the application server can send push
   * messages; may be empty to deregister a device
   */
  endpoint: string,
}

/** A token for Simple Push API for Firefox OS */
export type deviceTokenSimplePush$Input = {
  readonly _: 'deviceTokenSimplePush',
  /**
   * Absolute URL exposed by the push service where the application server can send push
   * messages; may be empty to deregister a device
   */
  readonly endpoint?: string,
}

/** A token for Ubuntu Push Client service */
export type deviceTokenUbuntuPush = {
  _: 'deviceTokenUbuntuPush',
  /** Token; may be empty to deregister a device */
  token: string,
}

/** A token for Ubuntu Push Client service */
export type deviceTokenUbuntuPush$Input = {
  readonly _: 'deviceTokenUbuntuPush',
  /** Token; may be empty to deregister a device */
  readonly token?: string,
}

/** A token for BlackBerry Push Service */
export type deviceTokenBlackBerryPush = {
  _: 'deviceTokenBlackBerryPush',
  /** Token; may be empty to deregister a device */
  token: string,
}

/** A token for BlackBerry Push Service */
export type deviceTokenBlackBerryPush$Input = {
  readonly _: 'deviceTokenBlackBerryPush',
  /** Token; may be empty to deregister a device */
  readonly token?: string,
}

/** A token for Tizen Push Service */
export type deviceTokenTizenPush = {
  _: 'deviceTokenTizenPush',
  /** Push service registration identifier; may be empty to deregister a device */
  reg_id: string,
}

/** A token for Tizen Push Service */
export type deviceTokenTizenPush$Input = {
  readonly _: 'deviceTokenTizenPush',
  /** Push service registration identifier; may be empty to deregister a device */
  readonly reg_id?: string,
}

/**
 * Contains a globally unique push receiver identifier, which can be used to identify
 * which account has received a push notification
 */
export type pushReceiverId = {
  _: 'pushReceiverId',
  /** The globally unique identifier of push notification subscription */
  id: number | string,
}

/**
 * Contains a globally unique push receiver identifier, which can be used to identify
 * which account has received a push notification
 */
export type pushReceiverId$Input = {
  readonly _: 'pushReceiverId',
  /** The globally unique identifier of push notification subscription */
  readonly id?: number | string,
}

/** Describes a solid fill of a background */
export type backgroundFillSolid = {
  _: 'backgroundFillSolid',
  /** A color of the background in the RGB24 format */
  color: number,
}

/** Describes a solid fill of a background */
export type backgroundFillSolid$Input = {
  readonly _: 'backgroundFillSolid',
  /** A color of the background in the RGB24 format */
  readonly color?: number,
}

/** Describes a gradient fill of a background */
export type backgroundFillGradient = {
  _: 'backgroundFillGradient',
  /** A top color of the background in the RGB24 format */
  top_color: number,
  /** A bottom color of the background in the RGB24 format */
  bottom_color: number,
  /**
   * Clockwise rotation angle of the gradient, in degrees; 0-359. Must be always divisible
   * by 45
   */
  rotation_angle: number,
}

/** Describes a gradient fill of a background */
export type backgroundFillGradient$Input = {
  readonly _: 'backgroundFillGradient',
  /** A top color of the background in the RGB24 format */
  readonly top_color?: number,
  /** A bottom color of the background in the RGB24 format */
  readonly bottom_color?: number,
  /**
   * Clockwise rotation angle of the gradient, in degrees; 0-359. Must be always divisible
   * by 45
   */
  readonly rotation_angle?: number,
}

/** Describes a freeform gradient fill of a background */
export type backgroundFillFreeformGradient = {
  _: 'backgroundFillFreeformGradient',
  /** A list of 3 or 4 colors of the freeform gradients in the RGB24 format */
  colors: Array<number>,
}

/** Describes a freeform gradient fill of a background */
export type backgroundFillFreeformGradient$Input = {
  readonly _: 'backgroundFillFreeformGradient',
  /** A list of 3 or 4 colors of the freeform gradients in the RGB24 format */
  readonly colors?: ReadonlyArray<number>,
}

/** A wallpaper in JPEG format */
export type backgroundTypeWallpaper = {
  _: 'backgroundTypeWallpaper',
  /**
   * True, if the wallpaper must be downscaled to fit in 450x450 square and then box-blurred
   * with radius 12
   */
  is_blurred: boolean,
  /** True, if the background needs to be slightly moved when device is tilted */
  is_moving: boolean,
}

/** A wallpaper in JPEG format */
export type backgroundTypeWallpaper$Input = {
  readonly _: 'backgroundTypeWallpaper',
  /**
   * True, if the wallpaper must be downscaled to fit in 450x450 square and then box-blurred
   * with radius 12
   */
  readonly is_blurred?: boolean,
  /** True, if the background needs to be slightly moved when device is tilted */
  readonly is_moving?: boolean,
}

/**
 * A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern")
 * pattern to be combined with the background fill chosen by the user
 */
export type backgroundTypePattern = {
  _: 'backgroundTypePattern',
  /** Fill of the background */
  fill: BackgroundFill,
  /** Intensity of the pattern when it is shown above the filled background; 0-100. */
  intensity: number,
  /**
   * True, if the background fill must be applied only to the pattern itself. All other
   * pixels are black in this case. For dark themes only
   */
  is_inverted: boolean,
  /** True, if the background needs to be slightly moved when device is tilted */
  is_moving: boolean,
}

/**
 * A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern")
 * pattern to be combined with the background fill chosen by the user
 */
export type backgroundTypePattern$Input = {
  readonly _: 'backgroundTypePattern',
  /** Fill of the background */
  readonly fill?: BackgroundFill$Input,
  /** Intensity of the pattern when it is shown above the filled background; 0-100. */
  readonly intensity?: number,
  /**
   * True, if the background fill must be applied only to the pattern itself. All other
   * pixels are black in this case. For dark themes only
   */
  readonly is_inverted?: boolean,
  /** True, if the background needs to be slightly moved when device is tilted */
  readonly is_moving?: boolean,
}

/** A filled background */
export type backgroundTypeFill = {
  _: 'backgroundTypeFill',
  /** The background fill */
  fill: BackgroundFill,
}

/** A filled background */
export type backgroundTypeFill$Input = {
  readonly _: 'backgroundTypeFill',
  /** The background fill */
  readonly fill?: BackgroundFill$Input,
}

/** Describes a chat background */
export type background = {
  _: 'background',
  /** Unique background identifier */
  id: number | string,
  /** True, if this is one of default backgrounds */
  is_default: boolean,
  /** True, if the background is dark and is recommended to be used with dark theme */
  is_dark: boolean,
  /** Unique background name */
  name: string,
  /** Document with the background; may be null. Null only for filled backgrounds */
  document: document | undefined,
  /** Type of the background */
  type: BackgroundType,
}

/** Describes a chat background */
export type background$Input = {
  readonly _: 'background',
  /** Unique background identifier */
  readonly id?: number | string,
  /** True, if this is one of default backgrounds */
  readonly is_default?: boolean,
  /** True, if the background is dark and is recommended to be used with dark theme */
  readonly is_dark?: boolean,
  /** Unique background name */
  readonly name?: string,
  /** Document with the background; may be null. Null only for filled backgrounds */
  readonly document?: document$Input | undefined,
  /** Type of the background */
  readonly type?: BackgroundType$Input,
}

/** Contains a list of backgrounds */
export type backgrounds = {
  _: 'backgrounds',
  /** A list of backgrounds */
  backgrounds: Array<background>,
}

/** Contains a list of backgrounds */
export type backgrounds$Input = {
  readonly _: 'backgrounds',
  /** A list of backgrounds */
  readonly backgrounds?: ReadonlyArray<background$Input>,
}

/** A background from a local file */
export type inputBackgroundLocal = {
  _: 'inputBackgroundLocal',
  /**
   * Background file to use. Only inputFileLocal and inputFileGenerated are supported.
   * The file must be in JPEG format for wallpapers and in PNG format for patterns
   */
  background: InputFile,
}

/** A background from a local file */
export type inputBackgroundLocal$Input = {
  readonly _: 'inputBackgroundLocal',
  /**
   * Background file to use. Only inputFileLocal and inputFileGenerated are supported.
   * The file must be in JPEG format for wallpapers and in PNG format for patterns
   */
  readonly background?: InputFile$Input,
}

/** A background from the server */
export type inputBackgroundRemote = {
  _: 'inputBackgroundRemote',
  /** The background identifier */
  background_id: number | string,
}

/** A background from the server */
export type inputBackgroundRemote$Input = {
  readonly _: 'inputBackgroundRemote',
  /** The background identifier */
  readonly background_id?: number | string,
}

/** Describes theme settings */
export type themeSettings = {
  _: 'themeSettings',
  /** Theme accent color in ARGB format */
  accent_color: number,
  /** The background to be used in chats; may be null */
  background: background | undefined,
  /** The fill to be used as a background for outgoing messages */
  outgoing_message_fill: BackgroundFill,
  /** If true, the freeform gradient fill needs to be animated on every sent message */
  animate_outgoing_message_fill: boolean,
  /** Accent color of outgoing messages in ARGB format */
  outgoing_message_accent_color: number,
}

/** Describes theme settings */
export type themeSettings$Input = {
  readonly _: 'themeSettings',
  /** Theme accent color in ARGB format */
  readonly accent_color?: number,
  /** The background to be used in chats; may be null */
  readonly background?: background$Input | undefined,
  /** The fill to be used as a background for outgoing messages */
  readonly outgoing_message_fill?: BackgroundFill$Input,
  /** If true, the freeform gradient fill needs to be animated on every sent message */
  readonly animate_outgoing_message_fill?: boolean,
  /** Accent color of outgoing messages in ARGB format */
  readonly outgoing_message_accent_color?: number,
}

/** Describes a chat theme */
export type chatTheme = {
  _: 'chatTheme',
  /** Theme name */
  name: string,
  /** Theme settings for a light chat theme */
  light_settings: themeSettings,
  /** Theme settings for a dark chat theme */
  dark_settings: themeSettings,
}

/** Describes a chat theme */
export type chatTheme$Input = {
  readonly _: 'chatTheme',
  /** Theme name */
  readonly name?: string,
  /** Theme settings for a light chat theme */
  readonly light_settings?: themeSettings$Input,
  /** Theme settings for a dark chat theme */
  readonly dark_settings?: themeSettings$Input,
}

/** Contains a list of hashtags */
export type hashtags = {
  _: 'hashtags',
  /** A list of hashtags */
  hashtags: Array<string>,
}

/** Contains a list of hashtags */
export type hashtags$Input = {
  readonly _: 'hashtags',
  /** A list of hashtags */
  readonly hashtags?: ReadonlyArray<string>,
}

/** The session can be used */
export type canTransferOwnershipResultOk = {
  _: 'canTransferOwnershipResultOk',
}

/** The session can be used */
export type canTransferOwnershipResultOk$Input = {
  readonly _: 'canTransferOwnershipResultOk',
}

/** The 2-step verification needs to be enabled first */
export type canTransferOwnershipResultPasswordNeeded = {
  _: 'canTransferOwnershipResultPasswordNeeded',
}

/** The 2-step verification needs to be enabled first */
export type canTransferOwnershipResultPasswordNeeded$Input = {
  readonly _: 'canTransferOwnershipResultPasswordNeeded',
}

/** The 2-step verification was enabled recently, user needs to wait */
export type canTransferOwnershipResultPasswordTooFresh = {
  _: 'canTransferOwnershipResultPasswordTooFresh',
  /** Time left before the session can be used to transfer ownership of a chat, in seconds */
  retry_after: number,
}

/** The 2-step verification was enabled recently, user needs to wait */
export type canTransferOwnershipResultPasswordTooFresh$Input = {
  readonly _: 'canTransferOwnershipResultPasswordTooFresh',
  /** Time left before the session can be used to transfer ownership of a chat, in seconds */
  readonly retry_after?: number,
}

/** The session was created recently, user needs to wait */
export type canTransferOwnershipResultSessionTooFresh = {
  _: 'canTransferOwnershipResultSessionTooFresh',
  /** Time left before the session can be used to transfer ownership of a chat, in seconds */
  retry_after: number,
}

/** The session was created recently, user needs to wait */
export type canTransferOwnershipResultSessionTooFresh$Input = {
  readonly _: 'canTransferOwnershipResultSessionTooFresh',
  /** Time left before the session can be used to transfer ownership of a chat, in seconds */
  readonly retry_after?: number,
}

/** The username can be set */
export type checkChatUsernameResultOk = {
  _: 'checkChatUsernameResultOk',
}

/** The username can be set */
export type checkChatUsernameResultOk$Input = {
  readonly _: 'checkChatUsernameResultOk',
}

/** The username is invalid */
export type checkChatUsernameResultUsernameInvalid = {
  _: 'checkChatUsernameResultUsernameInvalid',
}

/** The username is invalid */
export type checkChatUsernameResultUsernameInvalid$Input = {
  readonly _: 'checkChatUsernameResultUsernameInvalid',
}

/** The username is occupied */
export type checkChatUsernameResultUsernameOccupied = {
  _: 'checkChatUsernameResultUsernameOccupied',
}

/** The username is occupied */
export type checkChatUsernameResultUsernameOccupied$Input = {
  readonly _: 'checkChatUsernameResultUsernameOccupied',
}

/** The user has too much chats with username, one of them must be made private first */
export type checkChatUsernameResultPublicChatsTooMuch = {
  _: 'checkChatUsernameResultPublicChatsTooMuch',
}

/** The user has too much chats with username, one of them must be made private first */
export type checkChatUsernameResultPublicChatsTooMuch$Input = {
  readonly _: 'checkChatUsernameResultPublicChatsTooMuch',
}

/** The user can't be a member of a public supergroup */
export type checkChatUsernameResultPublicGroupsUnavailable = {
  _: 'checkChatUsernameResultPublicGroupsUnavailable',
}

/** The user can't be a member of a public supergroup */
export type checkChatUsernameResultPublicGroupsUnavailable$Input = {
  readonly _: 'checkChatUsernameResultPublicGroupsUnavailable',
}

/** The name can be set */
export type checkStickerSetNameResultOk = {
  _: 'checkStickerSetNameResultOk',
}

/** The name can be set */
export type checkStickerSetNameResultOk$Input = {
  readonly _: 'checkStickerSetNameResultOk',
}

/** The name is invalid */
export type checkStickerSetNameResultNameInvalid = {
  _: 'checkStickerSetNameResultNameInvalid',
}

/** The name is invalid */
export type checkStickerSetNameResultNameInvalid$Input = {
  readonly _: 'checkStickerSetNameResultNameInvalid',
}

/** The name is occupied */
export type checkStickerSetNameResultNameOccupied = {
  _: 'checkStickerSetNameResultNameOccupied',
}

/** The name is occupied */
export type checkStickerSetNameResultNameOccupied$Input = {
  readonly _: 'checkStickerSetNameResultNameOccupied',
}

/** The password was reset */
export type resetPasswordResultOk = {
  _: 'resetPasswordResultOk',
}

/** The password was reset */
export type resetPasswordResultOk$Input = {
  readonly _: 'resetPasswordResultOk',
}

/** The password reset request is pending */
export type resetPasswordResultPending = {
  _: 'resetPasswordResultPending',
  /**
   * Point in time (Unix timestamp) after which the password can be reset immediately
   * using resetPassword
   */
  pending_reset_date: number,
}

/** The password reset request is pending */
export type resetPasswordResultPending$Input = {
  readonly _: 'resetPasswordResultPending',
  /**
   * Point in time (Unix timestamp) after which the password can be reset immediately
   * using resetPassword
   */
  readonly pending_reset_date?: number,
}

/** The password reset request was declined */
export type resetPasswordResultDeclined = {
  _: 'resetPasswordResultDeclined',
  /** Point in time (Unix timestamp) when the password reset can be retried */
  retry_date: number,
}

/** The password reset request was declined */
export type resetPasswordResultDeclined$Input = {
  readonly _: 'resetPasswordResultDeclined',
  /** Point in time (Unix timestamp) when the password reset can be retried */
  readonly retry_date?: number,
}

/** The messages was exported from a private chat */
export type messageFileTypePrivate = {
  _: 'messageFileTypePrivate',
  /** Name of the other party; may be empty if unrecognized */
  name: string,
}

/** The messages was exported from a private chat */
export type messageFileTypePrivate$Input = {
  readonly _: 'messageFileTypePrivate',
  /** Name of the other party; may be empty if unrecognized */
  readonly name?: string,
}

/** The messages was exported from a group chat */
export type messageFileTypeGroup = {
  _: 'messageFileTypeGroup',
  /** Title of the group chat; may be empty if unrecognized */
  title: string,
}

/** The messages was exported from a group chat */
export type messageFileTypeGroup$Input = {
  readonly _: 'messageFileTypeGroup',
  /** Title of the group chat; may be empty if unrecognized */
  readonly title?: string,
}

/** The messages was exported from a chat of unknown type */
export type messageFileTypeUnknown = {
  _: 'messageFileTypeUnknown',
}

/** The messages was exported from a chat of unknown type */
export type messageFileTypeUnknown$Input = {
  readonly _: 'messageFileTypeUnknown',
}

/** A general message with hidden content */
export type pushMessageContentHidden = {
  _: 'pushMessageContentHidden',
  /** True, if the message is a pinned message with the specified content */
  is_pinned: boolean,
}

/** A general message with hidden content */
export type pushMessageContentHidden$Input = {
  readonly _: 'pushMessageContentHidden',
  /** True, if the message is a pinned message with the specified content */
  readonly is_pinned?: boolean,
}

/** An animation message (GIF-style). */
export type pushMessageContentAnimation = {
  _: 'pushMessageContentAnimation',
  /** Message content; may be null */
  animation: animation | undefined,
  /** Animation caption */
  caption: string,
  /** True, if the message is a pinned message with the specified content */
  is_pinned: boolean,
}

/** An animation message (GIF-style). */
export type pushMessageContentAnimation$Input = {
  readonly _: 'pushMessageContentAnimation',
  /** Message content; may be null */
  readonly animation?: animation$Input | undefined,
  /** Animation caption */
  readonly caption?: string,
  /** True, if the message is a pinned message with the specified content */
  readonly is_pinned?: boolean,
}

/** An audio message */
export type pushMessageContentAudio = {
  _: 'pushMessageContentAudio',
  /** Message content; may be null */
  audio: audio | undefined,
  /** True, if the message is a pinned message with the specified content */
  is_pinned: boolean,
}

/** An audio message */
export type pushMessageContentAudio$Input = {
  readonly _: 'pushMessageContentAudio',
  /** Message content; may be null */
  readonly audio?: audio$Input | undefined,
  /** True, if the message is a pinned message with the specified content */
  readonly is_pinned?: boolean,
}

/** A message with a user contact */
export type pushMessageContentContact = {
  _: 'pushMessageContentContact',
  /** Contact's name */
  name: string,
  /** True, if the message is a pinned message with the specified content */
  is_pinned: boolean,
}

/** A message with a user contact */
export type pushMessageContentContact$Input = {
  readonly _: 'pushMessageContentContact',
  /** Contact's name */
  readonly name?: string,
  /** True, if the message is a pinned message with the specified content */
  readonly is_pinned?: boolean,
}

/** A contact has registered with Telegram */
export type pushMessageContentContactRegistered = {
  _: 'pushMessageContentContactRegistered',
}

/** A contact has registered with Telegram */
export type pushMessageContentContactRegistered$Input = {
  readonly _: 'pushMessageContentContactRegistered',
}

/** A document message (a general file) */
export type pushMessageContentDocument = {
  _: 'pushMessageContentDocument',
  /** Message content; may be null */
  document: document | undefined,
  /** True, if the message is a pinned message with the specified content */
  is_pinned: boolean,
}

/** A document message (a general file) */
export type pushMessageContentDocument$Input = {
  readonly _: 'pushMessageContentDocument',
  /** Message content; may be null */
  readonly document?: document$Input | undefined,
  /** True, if the message is a pinned message with the specified content */
  readonly is_pinned?: boolean,
}

/** A message with a game */
export type pushMessageContentGame = {
  _: 'pushMessageContentGame',
  /** Game title, empty for pinned game message */
  title: string,
  /** True, if the message is a pinned message with the specified content */
  is_pinned: boolean,
}

/** A message with a game */
export type pushMessageContentGame$Input = {
  readonly _: 'pushMessageContentGame',
  /** Game title, empty for pinned game message */
  readonly title?: string,
  /** True, if the message is a pinned message with the specified content */
  readonly is_pinned?: boolean,
}

/** A new high score was achieved in a game */
export type pushMessageContentGameScore = {
  _: 'pushMessageContentGameScore',
  /** Game title, empty for pinned message */
  title: string,
  /** New score, 0 for pinned message */
  score: number,
  /** True, if the message is a pinned message with the specified content */
  is_pinned: boolean,
}

/** A new high score was achieved in a game */
export type pushMessageContentGameScore$Input = {
  readonly _: 'pushMessageContentGameScore',
  /** Game title, empty for pinned message */
  readonly title?: string,
  /** New score, 0 for pinned message */
  readonly score?: number,
  /** True, if the message is a pinned message with the specified content */
  readonly is_pinned?: boolean,
}

/** A message with an invoice from a bot */
export type pushMessageContentInvoice = {
  _: 'pushMessageContentInvoice',
  /** Product price */
  price: string,
  /** True, if the message is a pinned message with the specified content */
  is_pinned: boolean,
}

/** A message with an invoice from a bot */
export type pushMessageContentInvoice$Input = {
  readonly _: 'pushMessageContentInvoice',
  /** Product price */
  readonly price?: string,
  /** True, if the message is a pinned message with the specified content */
  readonly is_pinned?: boolean,
}

/** A message with a location */
export type pushMessageContentLocation = {
  _: 'pushMessageContentLocation',
  /** True, if the location is live */
  is_live: boolean,
  /** True, if the message is a pinned message with the specified content */
  is_pinned: boolean,
}

/** A message with a location */
export type pushMessageContentLocation$Input = {
  readonly _: 'pushMessageContentLocation',
  /** True, if the location is live */
  readonly is_live?: boolean,
  /** True, if the message is a pinned message with the specified content */
  readonly is_pinned?: boolean,
}

/** A photo message */
export type pushMessageContentPhoto = {
  _: 'pushMessageContentPhoto',
  /** Message content; may be null */
  photo: photo | undefined,
  /** Photo caption */
  caption: string,
  /** True, if the photo is secret */
  is_secret: boolean,
  /** True, if the message is a pinned message with the specified content */
  is_pinned: boolean,
}

/** A photo message */
export type pushMessageContentPhoto$Input = {
  readonly _: 'pushMessageContentPhoto',
  /** Message content; may be null */
  readonly photo?: photo$Input | undefined,
  /** Photo caption */
  readonly caption?: string,
  /** True, if the photo is secret */
  readonly is_secret?: boolean,
  /** True, if the message is a pinned message with the specified content */
  readonly is_pinned?: boolean,
}

/** A message with a poll */
export type pushMessageContentPoll = {
  _: 'pushMessageContentPoll',
  /** Poll question */
  question: string,
  /** True, if the poll is regular and not in quiz mode */
  is_regular: boolean,
  /** True, if the message is a pinned message with the specified content */
  is_pinned: boolean,
}

/** A message with a poll */
export type pushMessageContentPoll$Input = {
  readonly _: 'pushMessageContentPoll',
  /** Poll question */
  readonly question?: string,
  /** True, if the poll is regular and not in quiz mode */
  readonly is_regular?: boolean,
  /** True, if the message is a pinned message with the specified content */
  readonly is_pinned?: boolean,
}

/** A screenshot of a message in the chat has been taken */
export type pushMessageContentScreenshotTaken = {
  _: 'pushMessageContentScreenshotTaken',
}

/** A screenshot of a message in the chat has been taken */
export type pushMessageContentScreenshotTaken$Input = {
  readonly _: 'pushMessageContentScreenshotTaken',
}

/** A message with a sticker */
export type pushMessageContentSticker = {
  _: 'pushMessageContentSticker',
  /** Message content; may be null */
  sticker: sticker | undefined,
  /** Emoji corresponding to the sticker; may be empty */
  emoji: string,
  /** True, if the message is a pinned message with the specified content */
  is_pinned: boolean,
}

/** A message with a sticker */
export type pushMessageContentSticker$Input = {
  readonly _: 'pushMessageContentSticker',
  /** Message content; may be null */
  readonly sticker?: sticker$Input | undefined,
  /** Emoji corresponding to the sticker; may be empty */
  readonly emoji?: string,
  /** True, if the message is a pinned message with the specified content */
  readonly is_pinned?: boolean,
}

/** A text message */
export type pushMessageContentText = {
  _: 'pushMessageContentText',
  /** Message text */
  text: string,
  /** True, if the message is a pinned message with the specified content */
  is_pinned: boolean,
}

/** A text message */
export type pushMessageContentText$Input = {
  readonly _: 'pushMessageContentText',
  /** Message text */
  readonly text?: string,
  /** True, if the message is a pinned message with the specified content */
  readonly is_pinned?: boolean,
}

/** A video message */
export type pushMessageContentVideo = {
  _: 'pushMessageContentVideo',
  /** Message content; may be null */
  video: video | undefined,
  /** Video caption */
  caption: string,
  /** True, if the video is secret */
  is_secret: boolean,
  /** True, if the message is a pinned message with the specified content */
  is_pinned: boolean,
}

/** A video message */
export type pushMessageContentVideo$Input = {
  readonly _: 'pushMessageContentVideo',
  /** Message content; may be null */
  readonly video?: video$Input | undefined,
  /** Video caption */
  readonly caption?: string,
  /** True, if the video is secret */
  readonly is_secret?: boolean,
  /** True, if the message is a pinned message with the specified content */
  readonly is_pinned?: boolean,
}

/** A video note message */
export type pushMessageContentVideoNote = {
  _: 'pushMessageContentVideoNote',
  /** Message content; may be null */
  video_note: videoNote | undefined,
  /** True, if the message is a pinned message with the specified content */
  is_pinned: boolean,
}

/** A video note message */
export type pushMessageContentVideoNote$Input = {
  readonly _: 'pushMessageContentVideoNote',
  /** Message content; may be null */
  readonly video_note?: videoNote$Input | undefined,
  /** True, if the message is a pinned message with the specified content */
  readonly is_pinned?: boolean,
}

/** A voice note message */
export type pushMessageContentVoiceNote = {
  _: 'pushMessageContentVoiceNote',
  /** Message content; may be null */
  voice_note: voiceNote | undefined,
  /** True, if the message is a pinned message with the specified content */
  is_pinned: boolean,
}

/** A voice note message */
export type pushMessageContentVoiceNote$Input = {
  readonly _: 'pushMessageContentVoiceNote',
  /** Message content; may be null */
  readonly voice_note?: voiceNote$Input | undefined,
  /** True, if the message is a pinned message with the specified content */
  readonly is_pinned?: boolean,
}

/** A newly created basic group */
export type pushMessageContentBasicGroupChatCreate = {
  _: 'pushMessageContentBasicGroupChatCreate',
}

/** A newly created basic group */
export type pushMessageContentBasicGroupChatCreate$Input = {
  readonly _: 'pushMessageContentBasicGroupChatCreate',
}

/** New chat members were invited to a group */
export type pushMessageContentChatAddMembers = {
  _: 'pushMessageContentChatAddMembers',
  /** Name of the added member */
  member_name: string,
  /** True, if the current user was added to the group */
  is_current_user: boolean,
  /** True, if the user has returned to the group themselves */
  is_returned: boolean,
}

/** New chat members were invited to a group */
export type pushMessageContentChatAddMembers$Input = {
  readonly _: 'pushMessageContentChatAddMembers',
  /** Name of the added member */
  readonly member_name?: string,
  /** True, if the current user was added to the group */
  readonly is_current_user?: boolean,
  /** True, if the user has returned to the group themselves */
  readonly is_returned?: boolean,
}

/** A chat photo was edited */
export type pushMessageContentChatChangePhoto = {
  _: 'pushMessageContentChatChangePhoto',
}

/** A chat photo was edited */
export type pushMessageContentChatChangePhoto$Input = {
  readonly _: 'pushMessageContentChatChangePhoto',
}

/** A chat title was edited */
export type pushMessageContentChatChangeTitle = {
  _: 'pushMessageContentChatChangeTitle',
  /** New chat title */
  title: string,
}

/** A chat title was edited */
export type pushMessageContentChatChangeTitle$Input = {
  readonly _: 'pushMessageContentChatChangeTitle',
  /** New chat title */
  readonly title?: string,
}

/** A chat theme was edited */
export type pushMessageContentChatSetTheme = {
  _: 'pushMessageContentChatSetTheme',
  /**
   * If non-empty, name of a new theme, set for the chat. Otherwise chat theme was reset
   * to the default one
   */
  theme_name: string,
}

/** A chat theme was edited */
export type pushMessageContentChatSetTheme$Input = {
  readonly _: 'pushMessageContentChatSetTheme',
  /**
   * If non-empty, name of a new theme, set for the chat. Otherwise chat theme was reset
   * to the default one
   */
  readonly theme_name?: string,
}

/** A chat member was deleted */
export type pushMessageContentChatDeleteMember = {
  _: 'pushMessageContentChatDeleteMember',
  /** Name of the deleted member */
  member_name: string,
  /** True, if the current user was deleted from the group */
  is_current_user: boolean,
  /** True, if the user has left the group themselves */
  is_left: boolean,
}

/** A chat member was deleted */
export type pushMessageContentChatDeleteMember$Input = {
  readonly _: 'pushMessageContentChatDeleteMember',
  /** Name of the deleted member */
  readonly member_name?: string,
  /** True, if the current user was deleted from the group */
  readonly is_current_user?: boolean,
  /** True, if the user has left the group themselves */
  readonly is_left?: boolean,
}

/** A new member joined the chat via an invite link */
export type pushMessageContentChatJoinByLink = {
  _: 'pushMessageContentChatJoinByLink',
}

/** A new member joined the chat via an invite link */
export type pushMessageContentChatJoinByLink$Input = {
  readonly _: 'pushMessageContentChatJoinByLink',
}

/** A new member was accepted to the chat by an administrator */
export type pushMessageContentChatJoinByRequest = {
  _: 'pushMessageContentChatJoinByRequest',
}

/** A new member was accepted to the chat by an administrator */
export type pushMessageContentChatJoinByRequest$Input = {
  readonly _: 'pushMessageContentChatJoinByRequest',
}

/** A forwarded messages */
export type pushMessageContentMessageForwards = {
  _: 'pushMessageContentMessageForwards',
  /** Number of forwarded messages */
  total_count: number,
}

/** A forwarded messages */
export type pushMessageContentMessageForwards$Input = {
  readonly _: 'pushMessageContentMessageForwards',
  /** Number of forwarded messages */
  readonly total_count?: number,
}

/** A media album */
export type pushMessageContentMediaAlbum = {
  _: 'pushMessageContentMediaAlbum',
  /** Number of messages in the album */
  total_count: number,
  /** True, if the album has at least one photo */
  has_photos: boolean,
  /** True, if the album has at least one video */
  has_videos: boolean,
  /** True, if the album has at least one audio file */
  has_audios: boolean,
  /** True, if the album has at least one document */
  has_documents: boolean,
}

/** A media album */
export type pushMessageContentMediaAlbum$Input = {
  readonly _: 'pushMessageContentMediaAlbum',
  /** Number of messages in the album */
  readonly total_count?: number,
  /** True, if the album has at least one photo */
  readonly has_photos?: boolean,
  /** True, if the album has at least one video */
  readonly has_videos?: boolean,
  /** True, if the album has at least one audio file */
  readonly has_audios?: boolean,
  /** True, if the album has at least one document */
  readonly has_documents?: boolean,
}

/** New message was received */
export type notificationTypeNewMessage = {
  _: 'notificationTypeNewMessage',
  /** The message */
  message: message,
}

/** New message was received */
export type notificationTypeNewMessage$Input = {
  readonly _: 'notificationTypeNewMessage',
  /** The message */
  readonly message?: message$Input,
}

/** New secret chat was created */
export type notificationTypeNewSecretChat = {
  _: 'notificationTypeNewSecretChat',
}

/** New secret chat was created */
export type notificationTypeNewSecretChat$Input = {
  readonly _: 'notificationTypeNewSecretChat',
}

/** New call was received */
export type notificationTypeNewCall = {
  _: 'notificationTypeNewCall',
  /** Call identifier */
  call_id: number,
}

/** New call was received */
export type notificationTypeNewCall$Input = {
  readonly _: 'notificationTypeNewCall',
  /** Call identifier */
  readonly call_id?: number,
}

/** New message was received through a push notification */
export type notificationTypeNewPushMessage = {
  _: 'notificationTypeNewPushMessage',
  /**
   * The message identifier. The message will not be available in the chat history, but
   * the ID can be used in viewMessages, or as reply_to_message_id
   */
  message_id: number,
  /** Identifier of the sender of the message. Corresponding user or chat may be inaccessible */
  sender_id: MessageSender,
  /** Name of the sender */
  sender_name: string,
  /** True, if the message is outgoing */
  is_outgoing: boolean,
  /** Push message content */
  content: PushMessageContent,
}

/** New message was received through a push notification */
export type notificationTypeNewPushMessage$Input = {
  readonly _: 'notificationTypeNewPushMessage',
  /**
   * The message identifier. The message will not be available in the chat history, but
   * the ID can be used in viewMessages, or as reply_to_message_id
   */
  readonly message_id?: number,
  /** Identifier of the sender of the message. Corresponding user or chat may be inaccessible */
  readonly sender_id?: MessageSender$Input,
  /** Name of the sender */
  readonly sender_name?: string,
  /** True, if the message is outgoing */
  readonly is_outgoing?: boolean,
  /** Push message content */
  readonly content?: PushMessageContent$Input,
}

/**
 * A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage
 * with ordinary unread messages
 */
export type notificationGroupTypeMessages = {
  _: 'notificationGroupTypeMessages',
}

/**
 * A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage
 * with ordinary unread messages
 */
export type notificationGroupTypeMessages$Input = {
  readonly _: 'notificationGroupTypeMessages',
}

/**
 * A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage
 * with unread mentions of the current user, replies to their messages, or a pinned
 * message
 */
export type notificationGroupTypeMentions = {
  _: 'notificationGroupTypeMentions',
}

/**
 * A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage
 * with unread mentions of the current user, replies to their messages, or a pinned
 * message
 */
export type notificationGroupTypeMentions$Input = {
  readonly _: 'notificationGroupTypeMentions',
}

/** A group containing a notification of type notificationTypeNewSecretChat */
export type notificationGroupTypeSecretChat = {
  _: 'notificationGroupTypeSecretChat',
}

/** A group containing a notification of type notificationTypeNewSecretChat */
export type notificationGroupTypeSecretChat$Input = {
  readonly _: 'notificationGroupTypeSecretChat',
}

/** A group containing notifications of type notificationTypeNewCall */
export type notificationGroupTypeCalls = {
  _: 'notificationGroupTypeCalls',
}

/** A group containing notifications of type notificationTypeNewCall */
export type notificationGroupTypeCalls$Input = {
  readonly _: 'notificationGroupTypeCalls',
}

/** Contains information about a notification */
export type notification = {
  _: 'notification',
  /** Unique persistent identifier of this notification */
  id: number,
  /** Notification date */
  date: number,
  /** True, if the notification was initially silent */
  is_silent: boolean,
  /** Notification type */
  type: NotificationType,
}

/** Contains information about a notification */
export type notification$Input = {
  readonly _: 'notification',
  /** Unique persistent identifier of this notification */
  readonly id?: number,
  /** Notification date */
  readonly date?: number,
  /** True, if the notification was initially silent */
  readonly is_silent?: boolean,
  /** Notification type */
  readonly type?: NotificationType$Input,
}

/** Describes a group of notifications */
export type notificationGroup = {
  _: 'notificationGroup',
  /** Unique persistent auto-incremented from 1 identifier of the notification group */
  id: number,
  /** Type of the group */
  type: NotificationGroupType,
  /** Identifier of a chat to which all notifications in the group belong */
  chat_id: number,
  /** Total number of active notifications in the group */
  total_count: number,
  /** The list of active notifications */
  notifications: Array<notification>,
}

/** Describes a group of notifications */
export type notificationGroup$Input = {
  readonly _: 'notificationGroup',
  /** Unique persistent auto-incremented from 1 identifier of the notification group */
  readonly id?: number,
  /** Type of the group */
  readonly type?: NotificationGroupType$Input,
  /** Identifier of a chat to which all notifications in the group belong */
  readonly chat_id?: number,
  /** Total number of active notifications in the group */
  readonly total_count?: number,
  /** The list of active notifications */
  readonly notifications?: ReadonlyArray<notification$Input>,
}

/** Represents a boolean option */
export type optionValueBoolean = {
  _: 'optionValueBoolean',
  /** The value of the option */
  value: boolean,
}

/** Represents a boolean option */
export type optionValueBoolean$Input = {
  readonly _: 'optionValueBoolean',
  /** The value of the option */
  readonly value?: boolean,
}

/** Represents an unknown option or an option which has a default value */
export type optionValueEmpty = {
  _: 'optionValueEmpty',
}

/** Represents an unknown option or an option which has a default value */
export type optionValueEmpty$Input = {
  readonly _: 'optionValueEmpty',
}

/** Represents an integer option */
export type optionValueInteger = {
  _: 'optionValueInteger',
  /** The value of the option */
  value: number | string,
}

/** Represents an integer option */
export type optionValueInteger$Input = {
  readonly _: 'optionValueInteger',
  /** The value of the option */
  readonly value?: number | string,
}

/** Represents a string option */
export type optionValueString = {
  _: 'optionValueString',
  /** The value of the option */
  value: string,
}

/** Represents a string option */
export type optionValueString$Input = {
  readonly _: 'optionValueString',
  /** The value of the option */
  readonly value?: string,
}

/** Represents one member of a JSON object */
export type jsonObjectMember = {
  _: 'jsonObjectMember',
  /** Member's key */
  key: string,
  /** Member's value */
  value: JsonValue,
}

/** Represents one member of a JSON object */
export type jsonObjectMember$Input = {
  readonly _: 'jsonObjectMember',
  /** Member's key */
  readonly key?: string,
  /** Member's value */
  readonly value?: JsonValue$Input,
}

/** Represents a null JSON value */
export type jsonValueNull = {
  _: 'jsonValueNull',
}

/** Represents a null JSON value */
export type jsonValueNull$Input = {
  readonly _: 'jsonValueNull',
}

/** Represents a boolean JSON value */
export type jsonValueBoolean = {
  _: 'jsonValueBoolean',
  /** The value */
  value: boolean,
}

/** Represents a boolean JSON value */
export type jsonValueBoolean$Input = {
  readonly _: 'jsonValueBoolean',
  /** The value */
  readonly value?: boolean,
}

/** Represents a numeric JSON value */
export type jsonValueNumber = {
  _: 'jsonValueNumber',
  /** The value */
  value: number,
}

/** Represents a numeric JSON value */
export type jsonValueNumber$Input = {
  readonly _: 'jsonValueNumber',
  /** The value */
  readonly value?: number,
}

/** Represents a string JSON value */
export type jsonValueString = {
  _: 'jsonValueString',
  /** The value */
  value: string,
}

/** Represents a string JSON value */
export type jsonValueString$Input = {
  readonly _: 'jsonValueString',
  /** The value */
  readonly value?: string,
}

/** Represents a JSON array */
export type jsonValueArray = {
  _: 'jsonValueArray',
  /** The list of array elements */
  values: Array<JsonValue>,
}

/** Represents a JSON array */
export type jsonValueArray$Input = {
  readonly _: 'jsonValueArray',
  /** The list of array elements */
  readonly values?: ReadonlyArray<JsonValue$Input>,
}

/** Represents a JSON object */
export type jsonValueObject = {
  _: 'jsonValueObject',
  /** The list of object members */
  members: Array<jsonObjectMember>,
}

/** Represents a JSON object */
export type jsonValueObject$Input = {
  readonly _: 'jsonValueObject',
  /** The list of object members */
  readonly members?: ReadonlyArray<jsonObjectMember$Input>,
}

/** A rule to allow all users to do something */
export type userPrivacySettingRuleAllowAll = {
  _: 'userPrivacySettingRuleAllowAll',
}

/** A rule to allow all users to do something */
export type userPrivacySettingRuleAllowAll$Input = {
  readonly _: 'userPrivacySettingRuleAllowAll',
}

/** A rule to allow all of a user's contacts to do something */
export type userPrivacySettingRuleAllowContacts = {
  _: 'userPrivacySettingRuleAllowContacts',
}

/** A rule to allow all of a user's contacts to do something */
export type userPrivacySettingRuleAllowContacts$Input = {
  readonly _: 'userPrivacySettingRuleAllowContacts',
}

/** A rule to allow certain specified users to do something */
export type userPrivacySettingRuleAllowUsers = {
  _: 'userPrivacySettingRuleAllowUsers',
  /** The user identifiers, total number of users in all rules must not exceed 1000 */
  user_ids: Array<number>,
}

/** A rule to allow certain specified users to do something */
export type userPrivacySettingRuleAllowUsers$Input = {
  readonly _: 'userPrivacySettingRuleAllowUsers',
  /** The user identifiers, total number of users in all rules must not exceed 1000 */
  readonly user_ids?: ReadonlyArray<number>,
}

/**
 * A rule to allow all members of certain specified basic groups and supergroups to
 * doing something
 */
export type userPrivacySettingRuleAllowChatMembers = {
  _: 'userPrivacySettingRuleAllowChatMembers',
  /** The chat identifiers, total number of chats in all rules must not exceed 20 */
  chat_ids: Array<number>,
}

/**
 * A rule to allow all members of certain specified basic groups and supergroups to
 * doing something
 */
export type userPrivacySettingRuleAllowChatMembers$Input = {
  readonly _: 'userPrivacySettingRuleAllowChatMembers',
  /** The chat identifiers, total number of chats in all rules must not exceed 20 */
  readonly chat_ids?: ReadonlyArray<number>,
}

/** A rule to restrict all users from doing something */
export type userPrivacySettingRuleRestrictAll = {
  _: 'userPrivacySettingRuleRestrictAll',
}

/** A rule to restrict all users from doing something */
export type userPrivacySettingRuleRestrictAll$Input = {
  readonly _: 'userPrivacySettingRuleRestrictAll',
}

/** A rule to restrict all contacts of a user from doing something */
export type userPrivacySettingRuleRestrictContacts = {
  _: 'userPrivacySettingRuleRestrictContacts',
}

/** A rule to restrict all contacts of a user from doing something */
export type userPrivacySettingRuleRestrictContacts$Input = {
  readonly _: 'userPrivacySettingRuleRestrictContacts',
}

/** A rule to restrict all specified users from doing something */
export type userPrivacySettingRuleRestrictUsers = {
  _: 'userPrivacySettingRuleRestrictUsers',
  /** The user identifiers, total number of users in all rules must not exceed 1000 */
  user_ids: Array<number>,
}

/** A rule to restrict all specified users from doing something */
export type userPrivacySettingRuleRestrictUsers$Input = {
  readonly _: 'userPrivacySettingRuleRestrictUsers',
  /** The user identifiers, total number of users in all rules must not exceed 1000 */
  readonly user_ids?: ReadonlyArray<number>,
}

/**
 * A rule to restrict all members of specified basic groups and supergroups from doing
 * something
 */
export type userPrivacySettingRuleRestrictChatMembers = {
  _: 'userPrivacySettingRuleRestrictChatMembers',
  /** The chat identifiers, total number of chats in all rules must not exceed 20 */
  chat_ids: Array<number>,
}

/**
 * A rule to restrict all members of specified basic groups and supergroups from doing
 * something
 */
export type userPrivacySettingRuleRestrictChatMembers$Input = {
  readonly _: 'userPrivacySettingRuleRestrictChatMembers',
  /** The chat identifiers, total number of chats in all rules must not exceed 20 */
  readonly chat_ids?: ReadonlyArray<number>,
}

/**
 * A list of privacy rules. Rules are matched in the specified order. The first matched
 * rule defines the privacy setting for a given user. If no rule matches, the action
 * is not allowed
 */
export type userPrivacySettingRules = {
  _: 'userPrivacySettingRules',
  /** A list of rules */
  rules: Array<UserPrivacySettingRule>,
}

/**
 * A list of privacy rules. Rules are matched in the specified order. The first matched
 * rule defines the privacy setting for a given user. If no rule matches, the action
 * is not allowed
 */
export type userPrivacySettingRules$Input = {
  readonly _: 'userPrivacySettingRules',
  /** A list of rules */
  readonly rules?: ReadonlyArray<UserPrivacySettingRule$Input>,
}

/** A privacy setting for managing whether the user's online status is visible */
export type userPrivacySettingShowStatus = {
  _: 'userPrivacySettingShowStatus',
}

/** A privacy setting for managing whether the user's online status is visible */
export type userPrivacySettingShowStatus$Input = {
  readonly _: 'userPrivacySettingShowStatus',
}

/** A privacy setting for managing whether the user's profile photo is visible */
export type userPrivacySettingShowProfilePhoto = {
  _: 'userPrivacySettingShowProfilePhoto',
}

/** A privacy setting for managing whether the user's profile photo is visible */
export type userPrivacySettingShowProfilePhoto$Input = {
  readonly _: 'userPrivacySettingShowProfilePhoto',
}

/**
 * A privacy setting for managing whether a link to the user's account is included in
 * forwarded messages
 */
export type userPrivacySettingShowLinkInForwardedMessages = {
  _: 'userPrivacySettingShowLinkInForwardedMessages',
}

/**
 * A privacy setting for managing whether a link to the user's account is included in
 * forwarded messages
 */
export type userPrivacySettingShowLinkInForwardedMessages$Input = {
  readonly _: 'userPrivacySettingShowLinkInForwardedMessages',
}

/** A privacy setting for managing whether the user's phone number is visible */
export type userPrivacySettingShowPhoneNumber = {
  _: 'userPrivacySettingShowPhoneNumber',
}

/** A privacy setting for managing whether the user's phone number is visible */
export type userPrivacySettingShowPhoneNumber$Input = {
  readonly _: 'userPrivacySettingShowPhoneNumber',
}

/** A privacy setting for managing whether the user can be invited to chats */
export type userPrivacySettingAllowChatInvites = {
  _: 'userPrivacySettingAllowChatInvites',
}

/** A privacy setting for managing whether the user can be invited to chats */
export type userPrivacySettingAllowChatInvites$Input = {
  readonly _: 'userPrivacySettingAllowChatInvites',
}

/** A privacy setting for managing whether the user can be called */
export type userPrivacySettingAllowCalls = {
  _: 'userPrivacySettingAllowCalls',
}

/** A privacy setting for managing whether the user can be called */
export type userPrivacySettingAllowCalls$Input = {
  readonly _: 'userPrivacySettingAllowCalls',
}

/** A privacy setting for managing whether peer-to-peer connections can be used for calls */
export type userPrivacySettingAllowPeerToPeerCalls = {
  _: 'userPrivacySettingAllowPeerToPeerCalls',
}

/** A privacy setting for managing whether peer-to-peer connections can be used for calls */
export type userPrivacySettingAllowPeerToPeerCalls$Input = {
  readonly _: 'userPrivacySettingAllowPeerToPeerCalls',
}

/**
 * A privacy setting for managing whether the user can be found by their phone number.
 * Checked only if the phone number is not known to the other user. Can be set only
 * to "Allow contacts" or "Allow all"
 */
export type userPrivacySettingAllowFindingByPhoneNumber = {
  _: 'userPrivacySettingAllowFindingByPhoneNumber',
}

/**
 * A privacy setting for managing whether the user can be found by their phone number.
 * Checked only if the phone number is not known to the other user. Can be set only
 * to "Allow contacts" or "Allow all"
 */
export type userPrivacySettingAllowFindingByPhoneNumber$Input = {
  readonly _: 'userPrivacySettingAllowFindingByPhoneNumber',
}

/**
 * Contains information about the period of inactivity after which the current user's
 * account will automatically be deleted
 */
export type accountTtl = {
  _: 'accountTtl',
  /**
   * Number of days of inactivity before the account will be flagged for deletion; 30-366
   * days
   */
  days: number,
}

/**
 * Contains information about the period of inactivity after which the current user's
 * account will automatically be deleted
 */
export type accountTtl$Input = {
  readonly _: 'accountTtl',
  /**
   * Number of days of inactivity before the account will be flagged for deletion; 30-366
   * days
   */
  readonly days?: number,
}

/**
 * Contains information about one session in a Telegram application used by the current
 * user. Sessions must be shown to the user in the returned order
 */
export type session = {
  _: 'session',
  /** Session identifier */
  id: number | string,
  /** True, if this session is the current session */
  is_current: boolean,
  /** True, if a password is needed to complete authorization of the session */
  is_password_pending: boolean,
  /** True, if incoming secret chats can be accepted by the session */
  can_accept_secret_chats: boolean,
  /** True, if incoming calls can be accepted by the session */
  can_accept_calls: boolean,
  /** Telegram API identifier, as provided by the application */
  api_id: number,
  /** Name of the application, as provided by the application */
  application_name: string,
  /** The version of the application, as provided by the application */
  application_version: string,
  /**
   * True, if the application is an official application or uses the api_id of an official
   * application
   */
  is_official_application: boolean,
  /**
   * Model of the device the application has been run or is running on, as provided by
   * the application
   */
  device_model: string,
  /**
   * Operating system the application has been run or is running on, as provided by the
   * application
   */
  platform: string,
  /**
   * Version of the operating system the application has been run or is running on, as
   * provided by the application
   */
  system_version: string,
  /** Point in time (Unix timestamp) when the user has logged in */
  log_in_date: number,
  /** Point in time (Unix timestamp) when the session was last used */
  last_active_date: number,
  /** IP address from which the session was created, in human-readable format */
  ip: string,
  /**
   * A two-letter country code for the country from which the session was created, based
   * on the IP address
   */
  country: string,
  /** Region code from which the session was created, based on the IP address */
  region: string,
}

/**
 * Contains information about one session in a Telegram application used by the current
 * user. Sessions must be shown to the user in the returned order
 */
export type session$Input = {
  readonly _: 'session',
  /** Session identifier */
  readonly id?: number | string,
  /** True, if this session is the current session */
  readonly is_current?: boolean,
  /** True, if a password is needed to complete authorization of the session */
  readonly is_password_pending?: boolean,
  /** True, if incoming secret chats can be accepted by the session */
  readonly can_accept_secret_chats?: boolean,
  /** True, if incoming calls can be accepted by the session */
  readonly can_accept_calls?: boolean,
  /** Telegram API identifier, as provided by the application */
  readonly api_id?: number,
  /** Name of the application, as provided by the application */
  readonly application_name?: string,
  /** The version of the application, as provided by the application */
  readonly application_version?: string,
  /**
   * True, if the application is an official application or uses the api_id of an official
   * application
   */
  readonly is_official_application?: boolean,
  /**
   * Model of the device the application has been run or is running on, as provided by
   * the application
   */
  readonly device_model?: string,
  /**
   * Operating system the application has been run or is running on, as provided by the
   * application
   */
  readonly platform?: string,
  /**
   * Version of the operating system the application has been run or is running on, as
   * provided by the application
   */
  readonly system_version?: string,
  /** Point in time (Unix timestamp) when the user has logged in */
  readonly log_in_date?: number,
  /** Point in time (Unix timestamp) when the session was last used */
  readonly last_active_date?: number,
  /** IP address from which the session was created, in human-readable format */
  readonly ip?: string,
  /**
   * A two-letter country code for the country from which the session was created, based
   * on the IP address
   */
  readonly country?: string,
  /** Region code from which the session was created, based on the IP address */
  readonly region?: string,
}

/** Contains a list of sessions */
export type sessions = {
  _: 'sessions',
  /** List of sessions */
  sessions: Array<session>,
  /**
   * Number of days of inactivity before sessions will automatically be terminated; 1-366
   * days
   */
  inactive_session_ttl_days: number,
}

/** Contains a list of sessions */
export type sessions$Input = {
  readonly _: 'sessions',
  /** List of sessions */
  readonly sessions?: ReadonlyArray<session$Input>,
  /**
   * Number of days of inactivity before sessions will automatically be terminated; 1-366
   * days
   */
  readonly inactive_session_ttl_days?: number,
}

/** Contains information about one website the current user is logged in with Telegram */
export type connectedWebsite = {
  _: 'connectedWebsite',
  /** Website identifier */
  id: number | string,
  /** The domain name of the website */
  domain_name: string,
  /** User identifier of a bot linked with the website */
  bot_user_id: number,
  /** The version of a browser used to log in */
  browser: string,
  /** Operating system the browser is running on */
  platform: string,
  /** Point in time (Unix timestamp) when the user was logged in */
  log_in_date: number,
  /** Point in time (Unix timestamp) when obtained authorization was last used */
  last_active_date: number,
  /** IP address from which the user was logged in, in human-readable format */
  ip: string,
  /**
   * Human-readable description of a country and a region, from which the user was logged
   * in, based on the IP address
   */
  location: string,
}

/** Contains information about one website the current user is logged in with Telegram */
export type connectedWebsite$Input = {
  readonly _: 'connectedWebsite',
  /** Website identifier */
  readonly id?: number | string,
  /** The domain name of the website */
  readonly domain_name?: string,
  /** User identifier of a bot linked with the website */
  readonly bot_user_id?: number,
  /** The version of a browser used to log in */
  readonly browser?: string,
  /** Operating system the browser is running on */
  readonly platform?: string,
  /** Point in time (Unix timestamp) when the user was logged in */
  readonly log_in_date?: number,
  /** Point in time (Unix timestamp) when obtained authorization was last used */
  readonly last_active_date?: number,
  /** IP address from which the user was logged in, in human-readable format */
  readonly ip?: string,
  /**
   * Human-readable description of a country and a region, from which the user was logged
   * in, based on the IP address
   */
  readonly location?: string,
}

/** Contains a list of websites the current user is logged in with Telegram */
export type connectedWebsites = {
  _: 'connectedWebsites',
  /** List of connected websites */
  websites: Array<connectedWebsite>,
}

/** Contains a list of websites the current user is logged in with Telegram */
export type connectedWebsites$Input = {
  readonly _: 'connectedWebsites',
  /** List of connected websites */
  readonly websites?: ReadonlyArray<connectedWebsite$Input>,
}

/** The chat contains spam messages */
export type chatReportReasonSpam = {
  _: 'chatReportReasonSpam',
}

/** The chat contains spam messages */
export type chatReportReasonSpam$Input = {
  readonly _: 'chatReportReasonSpam',
}

/** The chat promotes violence */
export type chatReportReasonViolence = {
  _: 'chatReportReasonViolence',
}

/** The chat promotes violence */
export type chatReportReasonViolence$Input = {
  readonly _: 'chatReportReasonViolence',
}

/** The chat contains pornographic messages */
export type chatReportReasonPornography = {
  _: 'chatReportReasonPornography',
}

/** The chat contains pornographic messages */
export type chatReportReasonPornography$Input = {
  readonly _: 'chatReportReasonPornography',
}

/** The chat has child abuse related content */
export type chatReportReasonChildAbuse = {
  _: 'chatReportReasonChildAbuse',
}

/** The chat has child abuse related content */
export type chatReportReasonChildAbuse$Input = {
  readonly _: 'chatReportReasonChildAbuse',
}

/** The chat contains copyrighted content */
export type chatReportReasonCopyright = {
  _: 'chatReportReasonCopyright',
}

/** The chat contains copyrighted content */
export type chatReportReasonCopyright$Input = {
  readonly _: 'chatReportReasonCopyright',
}

/** The location-based chat is unrelated to its stated location */
export type chatReportReasonUnrelatedLocation = {
  _: 'chatReportReasonUnrelatedLocation',
}

/** The location-based chat is unrelated to its stated location */
export type chatReportReasonUnrelatedLocation$Input = {
  readonly _: 'chatReportReasonUnrelatedLocation',
}

/** The chat represents a fake account */
export type chatReportReasonFake = {
  _: 'chatReportReasonFake',
}

/** The chat represents a fake account */
export type chatReportReasonFake$Input = {
  readonly _: 'chatReportReasonFake',
}

/** A custom reason provided by the user */
export type chatReportReasonCustom = {
  _: 'chatReportReasonCustom',
}

/** A custom reason provided by the user */
export type chatReportReasonCustom$Input = {
  readonly _: 'chatReportReasonCustom',
}

/**
 * The link is a link to the active sessions section of the app. Use getActiveSessions
 * to handle the link
 */
export type internalLinkTypeActiveSessions = {
  _: 'internalLinkTypeActiveSessions',
}

/**
 * The link is a link to the active sessions section of the app. Use getActiveSessions
 * to handle the link
 */
export type internalLinkTypeActiveSessions$Input = {
  readonly _: 'internalLinkTypeActiveSessions',
}

/**
 * The link contains an authentication code. Call checkAuthenticationCode with the code
 * if the current authorization state is authorizationStateWaitCode
 */
export type internalLinkTypeAuthenticationCode = {
  _: 'internalLinkTypeAuthenticationCode',
  /** The authentication code */
  code: string,
}

/**
 * The link contains an authentication code. Call checkAuthenticationCode with the code
 * if the current authorization state is authorizationStateWaitCode
 */
export type internalLinkTypeAuthenticationCode$Input = {
  readonly _: 'internalLinkTypeAuthenticationCode',
  /** The authentication code */
  readonly code?: string,
}

/**
 * The link is a link to a background. Call searchBackground with the given background
 * name to process the link
 */
export type internalLinkTypeBackground = {
  _: 'internalLinkTypeBackground',
  /** Name of the background */
  background_name: string,
}

/**
 * The link is a link to a background. Call searchBackground with the given background
 * name to process the link
 */
export type internalLinkTypeBackground$Input = {
  readonly _: 'internalLinkTypeBackground',
  /** Name of the background */
  readonly background_name?: string,
}

/**
 * The link is a link to a chat with a Telegram bot. Call searchPublicChat with the
 * given bot username, check that the user is a bot, show START button in the chat with
 * the bot, and then call sendBotStartMessage with the given start parameter after the
 * button is pressed
 */
export type internalLinkTypeBotStart = {
  _: 'internalLinkTypeBotStart',
  /** Username of the bot */
  bot_username: string,
  /** The parameter to be passed to sendBotStartMessage */
  start_parameter: string,
}

/**
 * The link is a link to a chat with a Telegram bot. Call searchPublicChat with the
 * given bot username, check that the user is a bot, show START button in the chat with
 * the bot, and then call sendBotStartMessage with the given start parameter after the
 * button is pressed
 */
export type internalLinkTypeBotStart$Input = {
  readonly _: 'internalLinkTypeBotStart',
  /** Username of the bot */
  readonly bot_username?: string,
  /** The parameter to be passed to sendBotStartMessage */
  readonly start_parameter?: string,
}

/**
 * The link is a link to a Telegram bot, which is supposed to be added to a group chat.
 * Call searchPublicChat with the given bot username, check that the user is a bot and
 * can be added to groups, ask the current user to select a group to add the bot to,
 * and then call sendBotStartMessage with the given start parameter and the chosen group
 * chat. Bots can be added to a public group only by administrators of the group
 */
export type internalLinkTypeBotStartInGroup = {
  _: 'internalLinkTypeBotStartInGroup',
  /** Username of the bot */
  bot_username: string,
  /** The parameter to be passed to sendBotStartMessage */
  start_parameter: string,
}

/**
 * The link is a link to a Telegram bot, which is supposed to be added to a group chat.
 * Call searchPublicChat with the given bot username, check that the user is a bot and
 * can be added to groups, ask the current user to select a group to add the bot to,
 * and then call sendBotStartMessage with the given start parameter and the chosen group
 * chat. Bots can be added to a public group only by administrators of the group
 */
export type internalLinkTypeBotStartInGroup$Input = {
  readonly _: 'internalLinkTypeBotStartInGroup',
  /** Username of the bot */
  readonly bot_username?: string,
  /** The parameter to be passed to sendBotStartMessage */
  readonly start_parameter?: string,
}

/** The link is a link to the change phone number section of the app */
export type internalLinkTypeChangePhoneNumber = {
  _: 'internalLinkTypeChangePhoneNumber',
}

/** The link is a link to the change phone number section of the app */
export type internalLinkTypeChangePhoneNumber$Input = {
  readonly _: 'internalLinkTypeChangePhoneNumber',
}

/**
 * The link is a chat invite link. Call checkChatInviteLink with the given invite link
 * to process the link
 */
export type internalLinkTypeChatInvite = {
  _: 'internalLinkTypeChatInvite',
  /** Internal representation of the invite link */
  invite_link: string,
}

/**
 * The link is a chat invite link. Call checkChatInviteLink with the given invite link
 * to process the link
 */
export type internalLinkTypeChatInvite$Input = {
  readonly _: 'internalLinkTypeChatInvite',
  /** Internal representation of the invite link */
  readonly invite_link?: string,
}

/** The link is a link to the filter settings section of the app */
export type internalLinkTypeFilterSettings = {
  _: 'internalLinkTypeFilterSettings',
}

/** The link is a link to the filter settings section of the app */
export type internalLinkTypeFilterSettings$Input = {
  readonly _: 'internalLinkTypeFilterSettings',
}

/**
 * The link is a link to a game. Call searchPublicChat with the given bot username,
 * check that the user is a bot, ask the current user to select a chat to send the game,
 * and then call sendMessage with inputMessageGame
 */
export type internalLinkTypeGame = {
  _: 'internalLinkTypeGame',
  /** Username of the bot that owns the game */
  bot_username: string,
  /** Short name of the game */
  game_short_name: string,
}

/**
 * The link is a link to a game. Call searchPublicChat with the given bot username,
 * check that the user is a bot, ask the current user to select a chat to send the game,
 * and then call sendMessage with inputMessageGame
 */
export type internalLinkTypeGame$Input = {
  readonly _: 'internalLinkTypeGame',
  /** Username of the bot that owns the game */
  readonly bot_username?: string,
  /** Short name of the game */
  readonly game_short_name?: string,
}

/**
 * The link is a link to a language pack. Call getLanguagePackInfo with the given language
 * pack identifier to process the link
 */
export type internalLinkTypeLanguagePack = {
  _: 'internalLinkTypeLanguagePack',
  /** Language pack identifier */
  language_pack_id: string,
}

/**
 * The link is a link to a language pack. Call getLanguagePackInfo with the given language
 * pack identifier to process the link
 */
export type internalLinkTypeLanguagePack$Input = {
  readonly _: 'internalLinkTypeLanguagePack',
  /** Language pack identifier */
  readonly language_pack_id?: string,
}

/**
 * The link is a link to a Telegram message. Call getMessageLinkInfo with the given
 * URL to process the link
 */
export type internalLinkTypeMessage = {
  _: 'internalLinkTypeMessage',
  /** URL to be passed to getMessageLinkInfo */
  url: string,
}

/**
 * The link is a link to a Telegram message. Call getMessageLinkInfo with the given
 * URL to process the link
 */
export type internalLinkTypeMessage$Input = {
  readonly _: 'internalLinkTypeMessage',
  /** URL to be passed to getMessageLinkInfo */
  readonly url?: string,
}

/**
 * The link contains a message draft text. A share screen needs to be shown to the user,
 * then the chosen chat must be opened and the text is added to the input field
 */
export type internalLinkTypeMessageDraft = {
  _: 'internalLinkTypeMessageDraft',
  /** Message draft text */
  text: formattedText,
  /**
   * True, if the first line of the text contains a link. If true, the input field needs
   * to be focused and the text after the link must be selected
   */
  contains_link: boolean,
}

/**
 * The link contains a message draft text. A share screen needs to be shown to the user,
 * then the chosen chat must be opened and the text is added to the input field
 */
export type internalLinkTypeMessageDraft$Input = {
  readonly _: 'internalLinkTypeMessageDraft',
  /** Message draft text */
  readonly text?: formattedText$Input,
  /**
   * True, if the first line of the text contains a link. If true, the input field needs
   * to be focused and the text after the link must be selected
   */
  readonly contains_link?: boolean,
}

/**
 * The link contains a request of Telegram passport data. Call getPassportAuthorizationForm
 * with the given parameters to process the link if the link was received from outside
 * of the app, otherwise ignore it
 */
export type internalLinkTypePassportDataRequest = {
  _: 'internalLinkTypePassportDataRequest',
  /** User identifier of the service's bot */
  bot_user_id: number,
  /** Telegram Passport element types requested by the service */
  scope: string,
  /** Service's public key */
  public_key: string,
  /** Unique request identifier provided by the service */
  nonce: string,
  /**
   * An HTTP URL to open once the request is finished or canceled with the parameter tg_passport=success
   * or tg_passport=cancel respectively. If empty, then the link tgbot{bot_user_id}://passport/success
   * or tgbot{bot_user_id}://passport/cancel needs to be opened instead
   */
  callback_url: string,
}

/**
 * The link contains a request of Telegram passport data. Call getPassportAuthorizationForm
 * with the given parameters to process the link if the link was received from outside
 * of the app, otherwise ignore it
 */
export type internalLinkTypePassportDataRequest$Input = {
  readonly _: 'internalLinkTypePassportDataRequest',
  /** User identifier of the service's bot */
  readonly bot_user_id?: number,
  /** Telegram Passport element types requested by the service */
  readonly scope?: string,
  /** Service's public key */
  readonly public_key?: string,
  /** Unique request identifier provided by the service */
  readonly nonce?: string,
  /**
   * An HTTP URL to open once the request is finished or canceled with the parameter tg_passport=success
   * or tg_passport=cancel respectively. If empty, then the link tgbot{bot_user_id}://passport/success
   * or tgbot{bot_user_id}://passport/cancel needs to be opened instead
   */
  readonly callback_url?: string,
}

/**
 * The link can be used to confirm ownership of a phone number to prevent account deletion.
 * Call sendPhoneNumberConfirmationCode with the given hash and phone number to process
 * the link
 */
export type internalLinkTypePhoneNumberConfirmation = {
  _: 'internalLinkTypePhoneNumberConfirmation',
  /** Hash value from the link */
  hash: string,
  /** Phone number value from the link */
  phone_number: string,
}

/**
 * The link can be used to confirm ownership of a phone number to prevent account deletion.
 * Call sendPhoneNumberConfirmationCode with the given hash and phone number to process
 * the link
 */
export type internalLinkTypePhoneNumberConfirmation$Input = {
  readonly _: 'internalLinkTypePhoneNumberConfirmation',
  /** Hash value from the link */
  readonly hash?: string,
  /** Phone number value from the link */
  readonly phone_number?: string,
}

/**
 * The link is a link to a proxy. Call addProxy with the given parameters to process
 * the link and add the proxy
 */
export type internalLinkTypeProxy = {
  _: 'internalLinkTypeProxy',
  /** Proxy server IP address */
  server: string,
  /** Proxy server port */
  port: number,
  /** Type of the proxy */
  type: ProxyType,
}

/**
 * The link is a link to a proxy. Call addProxy with the given parameters to process
 * the link and add the proxy
 */
export type internalLinkTypeProxy$Input = {
  readonly _: 'internalLinkTypeProxy',
  /** Proxy server IP address */
  readonly server?: string,
  /** Proxy server port */
  readonly port?: number,
  /** Type of the proxy */
  readonly type?: ProxyType$Input,
}

/**
 * The link is a link to a chat by its username. Call searchPublicChat with the given
 * chat username to process the link
 */
export type internalLinkTypePublicChat = {
  _: 'internalLinkTypePublicChat',
  /** Username of the chat */
  chat_username: string,
}

/**
 * The link is a link to a chat by its username. Call searchPublicChat with the given
 * chat username to process the link
 */
export type internalLinkTypePublicChat$Input = {
  readonly _: 'internalLinkTypePublicChat',
  /** Username of the chat */
  readonly chat_username?: string,
}

/**
 * The link can be used to login the current user on another device, but it must be
 * scanned from QR-code using in-app camera. An alert similar to "This code can be used
 * to allow someone to log in to your Telegram account. To confirm Telegram login, please
 * go to Settings > Devices > Scan QR and scan the code" needs to be shown
 */
export type internalLinkTypeQrCodeAuthentication = {
  _: 'internalLinkTypeQrCodeAuthentication',
}

/**
 * The link can be used to login the current user on another device, but it must be
 * scanned from QR-code using in-app camera. An alert similar to "This code can be used
 * to allow someone to log in to your Telegram account. To confirm Telegram login, please
 * go to Settings > Devices > Scan QR and scan the code" needs to be shown
 */
export type internalLinkTypeQrCodeAuthentication$Input = {
  readonly _: 'internalLinkTypeQrCodeAuthentication',
}

/** The link is a link to app settings */
export type internalLinkTypeSettings = {
  _: 'internalLinkTypeSettings',
}

/** The link is a link to app settings */
export type internalLinkTypeSettings$Input = {
  readonly _: 'internalLinkTypeSettings',
}

/**
 * The link is a link to a sticker set. Call searchStickerSet with the given sticker
 * set name to process the link and show the sticker set
 */
export type internalLinkTypeStickerSet = {
  _: 'internalLinkTypeStickerSet',
  /** Name of the sticker set */
  sticker_set_name: string,
}

/**
 * The link is a link to a sticker set. Call searchStickerSet with the given sticker
 * set name to process the link and show the sticker set
 */
export type internalLinkTypeStickerSet$Input = {
  readonly _: 'internalLinkTypeStickerSet',
  /** Name of the sticker set */
  readonly sticker_set_name?: string,
}

/** The link is a link to a theme. TDLib has no theme support yet */
export type internalLinkTypeTheme = {
  _: 'internalLinkTypeTheme',
  /** Name of the theme */
  theme_name: string,
}

/** The link is a link to a theme. TDLib has no theme support yet */
export type internalLinkTypeTheme$Input = {
  readonly _: 'internalLinkTypeTheme',
  /** Name of the theme */
  readonly theme_name?: string,
}

/** The link is a link to the theme settings section of the app */
export type internalLinkTypeThemeSettings = {
  _: 'internalLinkTypeThemeSettings',
}

/** The link is a link to the theme settings section of the app */
export type internalLinkTypeThemeSettings$Input = {
  readonly _: 'internalLinkTypeThemeSettings',
}

/** The link is an unknown tg: link. Call getDeepLinkInfo to process the link */
export type internalLinkTypeUnknownDeepLink = {
  _: 'internalLinkTypeUnknownDeepLink',
  /** Link to be passed to getDeepLinkInfo */
  link: string,
}

/** The link is an unknown tg: link. Call getDeepLinkInfo to process the link */
export type internalLinkTypeUnknownDeepLink$Input = {
  readonly _: 'internalLinkTypeUnknownDeepLink',
  /** Link to be passed to getDeepLinkInfo */
  readonly link?: string,
}

/** The link is a link to an unsupported proxy. An alert can be shown to the user */
export type internalLinkTypeUnsupportedProxy = {
  _: 'internalLinkTypeUnsupportedProxy',
}

/** The link is a link to an unsupported proxy. An alert can be shown to the user */
export type internalLinkTypeUnsupportedProxy$Input = {
  readonly _: 'internalLinkTypeUnsupportedProxy',
}

/**
 * The link is a link to a video chat. Call searchPublicChat with the given chat username,
 * and then joinGoupCall with the given invite hash to process the link
 */
export type internalLinkTypeVideoChat = {
  _: 'internalLinkTypeVideoChat',
  /** Username of the chat with the video chat */
  chat_username: string,
  /**
   * If non-empty, invite hash to be used to join the video chat without being muted by
   * administrators
   */
  invite_hash: string,
  /**
   * True, if the video chat is expected to be a live stream in a channel or a broadcast
   * group
   */
  is_live_stream: boolean,
}

/**
 * The link is a link to a video chat. Call searchPublicChat with the given chat username,
 * and then joinGoupCall with the given invite hash to process the link
 */
export type internalLinkTypeVideoChat$Input = {
  readonly _: 'internalLinkTypeVideoChat',
  /** Username of the chat with the video chat */
  readonly chat_username?: string,
  /**
   * If non-empty, invite hash to be used to join the video chat without being muted by
   * administrators
   */
  readonly invite_hash?: string,
  /**
   * True, if the video chat is expected to be a live stream in a channel or a broadcast
   * group
   */
  readonly is_live_stream?: boolean,
}

/** Contains an HTTPS link to a message in a supergroup or channel */
export type messageLink = {
  _: 'messageLink',
  /** Message link */
  link: string,
  /** True, if the link will work for non-members of the chat */
  is_public: boolean,
}

/** Contains an HTTPS link to a message in a supergroup or channel */
export type messageLink$Input = {
  readonly _: 'messageLink',
  /** Message link */
  readonly link?: string,
  /** True, if the link will work for non-members of the chat */
  readonly is_public?: boolean,
}

/** Contains information about a link to a message in a chat */
export type messageLinkInfo = {
  _: 'messageLinkInfo',
  /** True, if the link is a public link for a message in a chat */
  is_public: boolean,
  /** If found, identifier of the chat to which the message belongs, 0 otherwise */
  chat_id: number,
  /** If found, the linked message; may be null */
  message: message | undefined,
  /**
   * Timestamp from which the video/audio/video note/voice note playing must start, in
   * seconds; 0 if not specified. The media can be in the message content or in its web
   * page preview
   */
  media_timestamp: number,
  /** True, if the whole media album to which the message belongs is linked */
  for_album: boolean,
  /** True, if the message is linked as a channel post comment or from a message thread */
  for_comment: boolean,
}

/** Contains information about a link to a message in a chat */
export type messageLinkInfo$Input = {
  readonly _: 'messageLinkInfo',
  /** True, if the link is a public link for a message in a chat */
  readonly is_public?: boolean,
  /** If found, identifier of the chat to which the message belongs, 0 otherwise */
  readonly chat_id?: number,
  /** If found, the linked message; may be null */
  readonly message?: message$Input | undefined,
  /**
   * Timestamp from which the video/audio/video note/voice note playing must start, in
   * seconds; 0 if not specified. The media can be in the message content or in its web
   * page preview
   */
  readonly media_timestamp?: number,
  /** True, if the whole media album to which the message belongs is linked */
  readonly for_album?: boolean,
  /** True, if the message is linked as a channel post comment or from a message thread */
  readonly for_comment?: boolean,
}

/** Contains a part of a file */
export type filePart = {
  _: 'filePart',
  /** File bytes */
  data: string,
}

/** Contains a part of a file */
export type filePart$Input = {
  readonly _: 'filePart',
  /** File bytes */
  readonly data?: string,
}

/** The data is not a file */
export type fileTypeNone = {
  _: 'fileTypeNone',
}

/** The data is not a file */
export type fileTypeNone$Input = {
  readonly _: 'fileTypeNone',
}

/** The file is an animation */
export type fileTypeAnimation = {
  _: 'fileTypeAnimation',
}

/** The file is an animation */
export type fileTypeAnimation$Input = {
  readonly _: 'fileTypeAnimation',
}

/** The file is an audio file */
export type fileTypeAudio = {
  _: 'fileTypeAudio',
}

/** The file is an audio file */
export type fileTypeAudio$Input = {
  readonly _: 'fileTypeAudio',
}

/** The file is a document */
export type fileTypeDocument = {
  _: 'fileTypeDocument',
}

/** The file is a document */
export type fileTypeDocument$Input = {
  readonly _: 'fileTypeDocument',
}

/** The file is a photo */
export type fileTypePhoto = {
  _: 'fileTypePhoto',
}

/** The file is a photo */
export type fileTypePhoto$Input = {
  readonly _: 'fileTypePhoto',
}

/** The file is a profile photo */
export type fileTypeProfilePhoto = {
  _: 'fileTypeProfilePhoto',
}

/** The file is a profile photo */
export type fileTypeProfilePhoto$Input = {
  readonly _: 'fileTypeProfilePhoto',
}

/** The file was sent to a secret chat (the file type is not known to the server) */
export type fileTypeSecret = {
  _: 'fileTypeSecret',
}

/** The file was sent to a secret chat (the file type is not known to the server) */
export type fileTypeSecret$Input = {
  readonly _: 'fileTypeSecret',
}

/** The file is a thumbnail of a file from a secret chat */
export type fileTypeSecretThumbnail = {
  _: 'fileTypeSecretThumbnail',
}

/** The file is a thumbnail of a file from a secret chat */
export type fileTypeSecretThumbnail$Input = {
  readonly _: 'fileTypeSecretThumbnail',
}

/** The file is a file from Secure storage used for storing Telegram Passport files */
export type fileTypeSecure = {
  _: 'fileTypeSecure',
}

/** The file is a file from Secure storage used for storing Telegram Passport files */
export type fileTypeSecure$Input = {
  readonly _: 'fileTypeSecure',
}

/** The file is a sticker */
export type fileTypeSticker = {
  _: 'fileTypeSticker',
}

/** The file is a sticker */
export type fileTypeSticker$Input = {
  readonly _: 'fileTypeSticker',
}

/** The file is a thumbnail of another file */
export type fileTypeThumbnail = {
  _: 'fileTypeThumbnail',
}

/** The file is a thumbnail of another file */
export type fileTypeThumbnail$Input = {
  readonly _: 'fileTypeThumbnail',
}

/** The file type is not yet known */
export type fileTypeUnknown = {
  _: 'fileTypeUnknown',
}

/** The file type is not yet known */
export type fileTypeUnknown$Input = {
  readonly _: 'fileTypeUnknown',
}

/** The file is a video */
export type fileTypeVideo = {
  _: 'fileTypeVideo',
}

/** The file is a video */
export type fileTypeVideo$Input = {
  readonly _: 'fileTypeVideo',
}

/** The file is a video note */
export type fileTypeVideoNote = {
  _: 'fileTypeVideoNote',
}

/** The file is a video note */
export type fileTypeVideoNote$Input = {
  readonly _: 'fileTypeVideoNote',
}

/** The file is a voice note */
export type fileTypeVoiceNote = {
  _: 'fileTypeVoiceNote',
}

/** The file is a voice note */
export type fileTypeVoiceNote$Input = {
  readonly _: 'fileTypeVoiceNote',
}

/** The file is a wallpaper or a background pattern */
export type fileTypeWallpaper = {
  _: 'fileTypeWallpaper',
}

/** The file is a wallpaper or a background pattern */
export type fileTypeWallpaper$Input = {
  readonly _: 'fileTypeWallpaper',
}

/** Contains the storage usage statistics for a specific file type */
export type storageStatisticsByFileType = {
  _: 'storageStatisticsByFileType',
  /** File type */
  file_type: FileType,
  /** Total size of the files, in bytes */
  size: number,
  /** Total number of files */
  count: number,
}

/** Contains the storage usage statistics for a specific file type */
export type storageStatisticsByFileType$Input = {
  readonly _: 'storageStatisticsByFileType',
  /** File type */
  readonly file_type?: FileType$Input,
  /** Total size of the files, in bytes */
  readonly size?: number,
  /** Total number of files */
  readonly count?: number,
}

/** Contains the storage usage statistics for a specific chat */
export type storageStatisticsByChat = {
  _: 'storageStatisticsByChat',
  /** Chat identifier; 0 if none */
  chat_id: number,
  /** Total size of the files in the chat, in bytes */
  size: number,
  /** Total number of files in the chat */
  count: number,
  /** Statistics split by file types */
  by_file_type: Array<storageStatisticsByFileType>,
}

/** Contains the storage usage statistics for a specific chat */
export type storageStatisticsByChat$Input = {
  readonly _: 'storageStatisticsByChat',
  /** Chat identifier; 0 if none */
  readonly chat_id?: number,
  /** Total size of the files in the chat, in bytes */
  readonly size?: number,
  /** Total number of files in the chat */
  readonly count?: number,
  /** Statistics split by file types */
  readonly by_file_type?: ReadonlyArray<storageStatisticsByFileType$Input>,
}

/** Contains the exact storage usage statistics split by chats and file type */
export type storageStatistics = {
  _: 'storageStatistics',
  /** Total size of files, in bytes */
  size: number,
  /** Total number of files */
  count: number,
  /** Statistics split by chats */
  by_chat: Array<storageStatisticsByChat>,
}

/** Contains the exact storage usage statistics split by chats and file type */
export type storageStatistics$Input = {
  readonly _: 'storageStatistics',
  /** Total size of files, in bytes */
  readonly size?: number,
  /** Total number of files */
  readonly count?: number,
  /** Statistics split by chats */
  readonly by_chat?: ReadonlyArray<storageStatisticsByChat$Input>,
}

/** Contains approximate storage usage statistics, excluding files of unknown file type */
export type storageStatisticsFast = {
  _: 'storageStatisticsFast',
  /** Approximate total size of files, in bytes */
  files_size: number,
  /** Approximate number of files */
  file_count: number,
  /** Size of the database */
  database_size: number,
  /** Size of the language pack database */
  language_pack_database_size: number,
  /** Size of the TDLib internal log */
  log_size: number,
}

/** Contains approximate storage usage statistics, excluding files of unknown file type */
export type storageStatisticsFast$Input = {
  readonly _: 'storageStatisticsFast',
  /** Approximate total size of files, in bytes */
  readonly files_size?: number,
  /** Approximate number of files */
  readonly file_count?: number,
  /** Size of the database */
  readonly database_size?: number,
  /** Size of the language pack database */
  readonly language_pack_database_size?: number,
  /** Size of the TDLib internal log */
  readonly log_size?: number,
}

/** Contains database statistics */
export type databaseStatistics = {
  _: 'databaseStatistics',
  /** Database statistics in an unspecified human-readable format */
  statistics: string,
}

/** Contains database statistics */
export type databaseStatistics$Input = {
  readonly _: 'databaseStatistics',
  /** Database statistics in an unspecified human-readable format */
  readonly statistics?: string,
}

/** The network is not available */
export type networkTypeNone = {
  _: 'networkTypeNone',
}

/** The network is not available */
export type networkTypeNone$Input = {
  readonly _: 'networkTypeNone',
}

/** A mobile network */
export type networkTypeMobile = {
  _: 'networkTypeMobile',
}

/** A mobile network */
export type networkTypeMobile$Input = {
  readonly _: 'networkTypeMobile',
}

/** A mobile roaming network */
export type networkTypeMobileRoaming = {
  _: 'networkTypeMobileRoaming',
}

/** A mobile roaming network */
export type networkTypeMobileRoaming$Input = {
  readonly _: 'networkTypeMobileRoaming',
}

/** A Wi-Fi network */
export type networkTypeWiFi = {
  _: 'networkTypeWiFi',
}

/** A Wi-Fi network */
export type networkTypeWiFi$Input = {
  readonly _: 'networkTypeWiFi',
}

/** A different network type (e.g., Ethernet network) */
export type networkTypeOther = {
  _: 'networkTypeOther',
}

/** A different network type (e.g., Ethernet network) */
export type networkTypeOther$Input = {
  readonly _: 'networkTypeOther',
}

/**
 * Contains information about the total amount of data that was used to send and receive
 * files
 */
export type networkStatisticsEntryFile = {
  _: 'networkStatisticsEntryFile',
  /** Type of the file the data is part of; pass null if the data isn't related to files */
  file_type: FileType,
  /**
   * Type of the network the data was sent through. Call setNetworkType to maintain the
   * actual network type
   */
  network_type: NetworkType,
  /** Total number of bytes sent */
  sent_bytes: number,
  /** Total number of bytes received */
  received_bytes: number,
}

/**
 * Contains information about the total amount of data that was used to send and receive
 * files
 */
export type networkStatisticsEntryFile$Input = {
  readonly _: 'networkStatisticsEntryFile',
  /** Type of the file the data is part of; pass null if the data isn't related to files */
  readonly file_type?: FileType$Input,
  /**
   * Type of the network the data was sent through. Call setNetworkType to maintain the
   * actual network type
   */
  readonly network_type?: NetworkType$Input,
  /** Total number of bytes sent */
  readonly sent_bytes?: number,
  /** Total number of bytes received */
  readonly received_bytes?: number,
}

/** Contains information about the total amount of data that was used for calls */
export type networkStatisticsEntryCall = {
  _: 'networkStatisticsEntryCall',
  /**
   * Type of the network the data was sent through. Call setNetworkType to maintain the
   * actual network type
   */
  network_type: NetworkType,
  /** Total number of bytes sent */
  sent_bytes: number,
  /** Total number of bytes received */
  received_bytes: number,
  /** Total call duration, in seconds */
  duration: number,
}

/** Contains information about the total amount of data that was used for calls */
export type networkStatisticsEntryCall$Input = {
  readonly _: 'networkStatisticsEntryCall',
  /**
   * Type of the network the data was sent through. Call setNetworkType to maintain the
   * actual network type
   */
  readonly network_type?: NetworkType$Input,
  /** Total number of bytes sent */
  readonly sent_bytes?: number,
  /** Total number of bytes received */
  readonly received_bytes?: number,
  /** Total call duration, in seconds */
  readonly duration?: number,
}

/** A full list of available network statistic entries */
export type networkStatistics = {
  _: 'networkStatistics',
  /** Point in time (Unix timestamp) from which the statistics are collected */
  since_date: number,
  /** Network statistics entries */
  entries: Array<NetworkStatisticsEntry>,
}

/** A full list of available network statistic entries */
export type networkStatistics$Input = {
  readonly _: 'networkStatistics',
  /** Point in time (Unix timestamp) from which the statistics are collected */
  readonly since_date?: number,
  /** Network statistics entries */
  readonly entries?: ReadonlyArray<NetworkStatisticsEntry$Input>,
}

/** Contains auto-download settings */
export type autoDownloadSettings = {
  _: 'autoDownloadSettings',
  /** True, if the auto-download is enabled */
  is_auto_download_enabled: boolean,
  /** The maximum size of a photo file to be auto-downloaded, in bytes */
  max_photo_file_size: number,
  /** The maximum size of a video file to be auto-downloaded, in bytes */
  max_video_file_size: number,
  /** The maximum size of other file types to be auto-downloaded, in bytes */
  max_other_file_size: number,
  /** The maximum suggested bitrate for uploaded videos, in kbit/s */
  video_upload_bitrate: number,
  /** True, if the beginning of video files needs to be preloaded for instant playback */
  preload_large_videos: boolean,
  /**
   * True, if the next audio track needs to be preloaded while the user is listening to
   * an audio file
   */
  preload_next_audio: boolean,
  /** True, if "use less data for calls" option needs to be enabled */
  use_less_data_for_calls: boolean,
}

/** Contains auto-download settings */
export type autoDownloadSettings$Input = {
  readonly _: 'autoDownloadSettings',
  /** True, if the auto-download is enabled */
  readonly is_auto_download_enabled?: boolean,
  /** The maximum size of a photo file to be auto-downloaded, in bytes */
  readonly max_photo_file_size?: number,
  /** The maximum size of a video file to be auto-downloaded, in bytes */
  readonly max_video_file_size?: number,
  /** The maximum size of other file types to be auto-downloaded, in bytes */
  readonly max_other_file_size?: number,
  /** The maximum suggested bitrate for uploaded videos, in kbit/s */
  readonly video_upload_bitrate?: number,
  /** True, if the beginning of video files needs to be preloaded for instant playback */
  readonly preload_large_videos?: boolean,
  /**
   * True, if the next audio track needs to be preloaded while the user is listening to
   * an audio file
   */
  readonly preload_next_audio?: boolean,
  /** True, if "use less data for calls" option needs to be enabled */
  readonly use_less_data_for_calls?: boolean,
}

/** Contains auto-download settings presets for the current user */
export type autoDownloadSettingsPresets = {
  _: 'autoDownloadSettingsPresets',
  /** Preset with lowest settings; supposed to be used by default when roaming */
  low: autoDownloadSettings,
  /** Preset with medium settings; supposed to be used by default when using mobile data */
  medium: autoDownloadSettings,
  /** Preset with highest settings; supposed to be used by default when connected on Wi-Fi */
  high: autoDownloadSettings,
}

/** Contains auto-download settings presets for the current user */
export type autoDownloadSettingsPresets$Input = {
  readonly _: 'autoDownloadSettingsPresets',
  /** Preset with lowest settings; supposed to be used by default when roaming */
  readonly low?: autoDownloadSettings$Input,
  /** Preset with medium settings; supposed to be used by default when using mobile data */
  readonly medium?: autoDownloadSettings$Input,
  /** Preset with highest settings; supposed to be used by default when connected on Wi-Fi */
  readonly high?: autoDownloadSettings$Input,
}

/**
 * Currently waiting for the network to become available. Use setNetworkType to change
 * the available network type
 */
export type connectionStateWaitingForNetwork = {
  _: 'connectionStateWaitingForNetwork',
}

/**
 * Currently waiting for the network to become available. Use setNetworkType to change
 * the available network type
 */
export type connectionStateWaitingForNetwork$Input = {
  readonly _: 'connectionStateWaitingForNetwork',
}

/** Currently establishing a connection with a proxy server */
export type connectionStateConnectingToProxy = {
  _: 'connectionStateConnectingToProxy',
}

/** Currently establishing a connection with a proxy server */
export type connectionStateConnectingToProxy$Input = {
  readonly _: 'connectionStateConnectingToProxy',
}

/** Currently establishing a connection to the Telegram servers */
export type connectionStateConnecting = {
  _: 'connectionStateConnecting',
}

/** Currently establishing a connection to the Telegram servers */
export type connectionStateConnecting$Input = {
  readonly _: 'connectionStateConnecting',
}

/** Downloading data received while the application was offline */
export type connectionStateUpdating = {
  _: 'connectionStateUpdating',
}

/** Downloading data received while the application was offline */
export type connectionStateUpdating$Input = {
  readonly _: 'connectionStateUpdating',
}

/** There is a working connection to the Telegram servers */
export type connectionStateReady = {
  _: 'connectionStateReady',
}

/** There is a working connection to the Telegram servers */
export type connectionStateReady$Input = {
  readonly _: 'connectionStateReady',
}

/** A category containing frequently used private chats with non-bot users */
export type topChatCategoryUsers = {
  _: 'topChatCategoryUsers',
}

/** A category containing frequently used private chats with non-bot users */
export type topChatCategoryUsers$Input = {
  readonly _: 'topChatCategoryUsers',
}

/** A category containing frequently used private chats with bot users */
export type topChatCategoryBots = {
  _: 'topChatCategoryBots',
}

/** A category containing frequently used private chats with bot users */
export type topChatCategoryBots$Input = {
  readonly _: 'topChatCategoryBots',
}

/** A category containing frequently used basic groups and supergroups */
export type topChatCategoryGroups = {
  _: 'topChatCategoryGroups',
}

/** A category containing frequently used basic groups and supergroups */
export type topChatCategoryGroups$Input = {
  readonly _: 'topChatCategoryGroups',
}

/** A category containing frequently used channels */
export type topChatCategoryChannels = {
  _: 'topChatCategoryChannels',
}

/** A category containing frequently used channels */
export type topChatCategoryChannels$Input = {
  readonly _: 'topChatCategoryChannels',
}

/**
 * A category containing frequently used chats with inline bots sorted by their usage
 * in inline mode
 */
export type topChatCategoryInlineBots = {
  _: 'topChatCategoryInlineBots',
}

/**
 * A category containing frequently used chats with inline bots sorted by their usage
 * in inline mode
 */
export type topChatCategoryInlineBots$Input = {
  readonly _: 'topChatCategoryInlineBots',
}

/** A category containing frequently used chats used for calls */
export type topChatCategoryCalls = {
  _: 'topChatCategoryCalls',
}

/** A category containing frequently used chats used for calls */
export type topChatCategoryCalls$Input = {
  readonly _: 'topChatCategoryCalls',
}

/** A category containing frequently used chats used to forward messages */
export type topChatCategoryForwardChats = {
  _: 'topChatCategoryForwardChats',
}

/** A category containing frequently used chats used to forward messages */
export type topChatCategoryForwardChats$Input = {
  readonly _: 'topChatCategoryForwardChats',
}

/** A URL linking to a user */
export type tMeUrlTypeUser = {
  _: 'tMeUrlTypeUser',
  /** Identifier of the user */
  user_id: number,
}

/** A URL linking to a user */
export type tMeUrlTypeUser$Input = {
  readonly _: 'tMeUrlTypeUser',
  /** Identifier of the user */
  readonly user_id?: number,
}

/** A URL linking to a public supergroup or channel */
export type tMeUrlTypeSupergroup = {
  _: 'tMeUrlTypeSupergroup',
  /** Identifier of the supergroup or channel */
  supergroup_id: number,
}

/** A URL linking to a public supergroup or channel */
export type tMeUrlTypeSupergroup$Input = {
  readonly _: 'tMeUrlTypeSupergroup',
  /** Identifier of the supergroup or channel */
  readonly supergroup_id?: number,
}

/** A chat invite link */
export type tMeUrlTypeChatInvite = {
  _: 'tMeUrlTypeChatInvite',
  /** Chat invite link info */
  info: chatInviteLinkInfo,
}

/** A chat invite link */
export type tMeUrlTypeChatInvite$Input = {
  readonly _: 'tMeUrlTypeChatInvite',
  /** Chat invite link info */
  readonly info?: chatInviteLinkInfo$Input,
}

/** A URL linking to a sticker set */
export type tMeUrlTypeStickerSet = {
  _: 'tMeUrlTypeStickerSet',
  /** Identifier of the sticker set */
  sticker_set_id: number | string,
}

/** A URL linking to a sticker set */
export type tMeUrlTypeStickerSet$Input = {
  readonly _: 'tMeUrlTypeStickerSet',
  /** Identifier of the sticker set */
  readonly sticker_set_id?: number | string,
}

/** Represents a URL linking to an internal Telegram entity */
export type tMeUrl = {
  _: 'tMeUrl',
  /** URL */
  url: string,
  /** Type of the URL */
  type: TMeUrlType,
}

/** Represents a URL linking to an internal Telegram entity */
export type tMeUrl$Input = {
  readonly _: 'tMeUrl',
  /** URL */
  readonly url?: string,
  /** Type of the URL */
  readonly type?: TMeUrlType$Input,
}

/** Contains a list of t.me URLs */
export type tMeUrls = {
  _: 'tMeUrls',
  /** List of URLs */
  urls: Array<tMeUrl>,
}

/** Contains a list of t.me URLs */
export type tMeUrls$Input = {
  readonly _: 'tMeUrls',
  /** List of URLs */
  readonly urls?: ReadonlyArray<tMeUrl$Input>,
}

/** Suggests the user to enable "archive_and_mute_new_chats_from_unknown_users" option */
export type suggestedActionEnableArchiveAndMuteNewChats = {
  _: 'suggestedActionEnableArchiveAndMuteNewChats',
}

/** Suggests the user to enable "archive_and_mute_new_chats_from_unknown_users" option */
export type suggestedActionEnableArchiveAndMuteNewChats$Input = {
  readonly _: 'suggestedActionEnableArchiveAndMuteNewChats',
}

/**
 * Suggests the user to check whether they still remember their 2-step verification
 * password
 */
export type suggestedActionCheckPassword = {
  _: 'suggestedActionCheckPassword',
}

/**
 * Suggests the user to check whether they still remember their 2-step verification
 * password
 */
export type suggestedActionCheckPassword$Input = {
  readonly _: 'suggestedActionCheckPassword',
}

/**
 * Suggests the user to check whether authorization phone number is correct and change
 * the phone number if it is inaccessible
 */
export type suggestedActionCheckPhoneNumber = {
  _: 'suggestedActionCheckPhoneNumber',
}

/**
 * Suggests the user to check whether authorization phone number is correct and change
 * the phone number if it is inaccessible
 */
export type suggestedActionCheckPhoneNumber$Input = {
  readonly _: 'suggestedActionCheckPhoneNumber',
}

/**
 * Suggests the user to view a hint about the meaning of one and two check marks on
 * sent messages
 */
export type suggestedActionViewChecksHint = {
  _: 'suggestedActionViewChecksHint',
}

/**
 * Suggests the user to view a hint about the meaning of one and two check marks on
 * sent messages
 */
export type suggestedActionViewChecksHint$Input = {
  readonly _: 'suggestedActionViewChecksHint',
}

/** Suggests the user to convert specified supergroup to a broadcast group */
export type suggestedActionConvertToBroadcastGroup = {
  _: 'suggestedActionConvertToBroadcastGroup',
  /** Supergroup identifier */
  supergroup_id: number,
}

/** Suggests the user to convert specified supergroup to a broadcast group */
export type suggestedActionConvertToBroadcastGroup$Input = {
  readonly _: 'suggestedActionConvertToBroadcastGroup',
  /** Supergroup identifier */
  readonly supergroup_id?: number,
}

/** Suggests the user to set a 2-step verification password to be able to log in again */
export type suggestedActionSetPassword = {
  _: 'suggestedActionSetPassword',
  /**
   * The number of days to pass between consecutive authorizations if the user declines
   * to set password
   */
  authorization_delay: number,
}

/** Suggests the user to set a 2-step verification password to be able to log in again */
export type suggestedActionSetPassword$Input = {
  readonly _: 'suggestedActionSetPassword',
  /**
   * The number of days to pass between consecutive authorizations if the user declines
   * to set password
   */
  readonly authorization_delay?: number,
}

/** Contains a counter */
export type count = {
  _: 'count',
  /** Count */
  count: number,
}

/** Contains a counter */
export type count$Input = {
  readonly _: 'count',
  /** Count */
  readonly count?: number,
}

/** Contains some text */
export type text = {
  _: 'text',
  /** Text */
  text: string,
}

/** Contains some text */
export type text$Input = {
  readonly _: 'text',
  /** Text */
  readonly text?: string,
}

/** Contains a value representing a number of seconds */
export type seconds = {
  _: 'seconds',
  /** Number of seconds */
  seconds: number,
}

/** Contains a value representing a number of seconds */
export type seconds$Input = {
  readonly _: 'seconds',
  /** Number of seconds */
  readonly seconds?: number,
}

/** Contains information about a tg: deep link */
export type deepLinkInfo = {
  _: 'deepLinkInfo',
  /** Text to be shown to the user */
  text: formattedText,
  /** True, if the user must be asked to update the application */
  need_update_application: boolean,
}

/** Contains information about a tg: deep link */
export type deepLinkInfo$Input = {
  readonly _: 'deepLinkInfo',
  /** Text to be shown to the user */
  readonly text?: formattedText$Input,
  /** True, if the user must be asked to update the application */
  readonly need_update_application?: boolean,
}

/** The text uses Markdown-style formatting */
export type textParseModeMarkdown = {
  _: 'textParseModeMarkdown',
  /**
   * Version of the parser: 0 or 1 - Telegram Bot API "Markdown" parse mode, 2 - Telegram
   * Bot API "MarkdownV2" parse mode
   */
  version: number,
}

/** The text uses Markdown-style formatting */
export type textParseModeMarkdown$Input = {
  readonly _: 'textParseModeMarkdown',
  /**
   * Version of the parser: 0 or 1 - Telegram Bot API "Markdown" parse mode, 2 - Telegram
   * Bot API "MarkdownV2" parse mode
   */
  readonly version?: number,
}

/** The text uses HTML-style formatting. The same as Telegram Bot API "HTML" parse mode */
export type textParseModeHTML = {
  _: 'textParseModeHTML',
}

/** The text uses HTML-style formatting. The same as Telegram Bot API "HTML" parse mode */
export type textParseModeHTML$Input = {
  readonly _: 'textParseModeHTML',
}

/** A SOCKS5 proxy server */
export type proxyTypeSocks5 = {
  _: 'proxyTypeSocks5',
  /** Username for logging in; may be empty */
  username: string,
  /** Password for logging in; may be empty */
  password: string,
}

/** A SOCKS5 proxy server */
export type proxyTypeSocks5$Input = {
  readonly _: 'proxyTypeSocks5',
  /** Username for logging in; may be empty */
  readonly username?: string,
  /** Password for logging in; may be empty */
  readonly password?: string,
}

/** A HTTP transparent proxy server */
export type proxyTypeHttp = {
  _: 'proxyTypeHttp',
  /** Username for logging in; may be empty */
  username: string,
  /** Password for logging in; may be empty */
  password: string,
  /**
   * Pass true if the proxy supports only HTTP requests and doesn't support transparent
   * TCP connections via HTTP CONNECT method
   */
  http_only: boolean,
}

/** A HTTP transparent proxy server */
export type proxyTypeHttp$Input = {
  readonly _: 'proxyTypeHttp',
  /** Username for logging in; may be empty */
  readonly username?: string,
  /** Password for logging in; may be empty */
  readonly password?: string,
  /**
   * Pass true if the proxy supports only HTTP requests and doesn't support transparent
   * TCP connections via HTTP CONNECT method
   */
  readonly http_only?: boolean,
}

/** An MTProto proxy server */
export type proxyTypeMtproto = {
  _: 'proxyTypeMtproto',
  /** The proxy's secret in hexadecimal encoding */
  secret: string,
}

/** An MTProto proxy server */
export type proxyTypeMtproto$Input = {
  readonly _: 'proxyTypeMtproto',
  /** The proxy's secret in hexadecimal encoding */
  readonly secret?: string,
}

/** Contains information about a proxy server */
export type proxy = {
  _: 'proxy',
  /** Unique identifier of the proxy */
  id: number,
  /** Proxy server IP address */
  server: string,
  /** Proxy server port */
  port: number,
  /** Point in time (Unix timestamp) when the proxy was last used; 0 if never */
  last_used_date: number,
  /** True, if the proxy is enabled now */
  is_enabled: boolean,
  /** Type of the proxy */
  type: ProxyType,
}

/** Contains information about a proxy server */
export type proxy$Input = {
  readonly _: 'proxy',
  /** Unique identifier of the proxy */
  readonly id?: number,
  /** Proxy server IP address */
  readonly server?: string,
  /** Proxy server port */
  readonly port?: number,
  /** Point in time (Unix timestamp) when the proxy was last used; 0 if never */
  readonly last_used_date?: number,
  /** True, if the proxy is enabled now */
  readonly is_enabled?: boolean,
  /** Type of the proxy */
  readonly type?: ProxyType$Input,
}

/** Represents a list of proxy servers */
export type proxies = {
  _: 'proxies',
  /** List of proxy servers */
  proxies: Array<proxy>,
}

/** Represents a list of proxy servers */
export type proxies$Input = {
  readonly _: 'proxies',
  /** List of proxy servers */
  readonly proxies?: ReadonlyArray<proxy$Input>,
}

/** A static sticker in PNG format, which will be converted to WEBP server-side */
export type inputStickerStatic = {
  _: 'inputStickerStatic',
  /** PNG image with the sticker; must be up to 512 KB in size and fit in a 512x512 square */
  sticker: InputFile,
  /** Emojis corresponding to the sticker */
  emojis: string,
  /** For masks, position where the mask is placed; pass null if unspecified */
  mask_position: maskPosition,
}

/** A static sticker in PNG format, which will be converted to WEBP server-side */
export type inputStickerStatic$Input = {
  readonly _: 'inputStickerStatic',
  /** PNG image with the sticker; must be up to 512 KB in size and fit in a 512x512 square */
  readonly sticker?: InputFile$Input,
  /** Emojis corresponding to the sticker */
  readonly emojis?: string,
  /** For masks, position where the mask is placed; pass null if unspecified */
  readonly mask_position?: maskPosition$Input,
}

/** An animated sticker in TGS format */
export type inputStickerAnimated = {
  _: 'inputStickerAnimated',
  /**
   * File with the animated sticker. Only local or uploaded within a week files are supported.
   * See https://core.telegram.org/animated_stickers#technical-requirements for technical
   * requirements
   */
  sticker: InputFile,
  /** Emojis corresponding to the sticker */
  emojis: string,
}

/** An animated sticker in TGS format */
export type inputStickerAnimated$Input = {
  readonly _: 'inputStickerAnimated',
  /**
   * File with the animated sticker. Only local or uploaded within a week files are supported.
   * See https://core.telegram.org/animated_stickers#technical-requirements for technical
   * requirements
   */
  readonly sticker?: InputFile$Input,
  /** Emojis corresponding to the sticker */
  readonly emojis?: string,
}

/** Represents a date range */
export type dateRange = {
  _: 'dateRange',
  /** Point in time (Unix timestamp) at which the date range begins */
  start_date: number,
  /** Point in time (Unix timestamp) at which the date range ends */
  end_date: number,
}

/** Represents a date range */
export type dateRange$Input = {
  readonly _: 'dateRange',
  /** Point in time (Unix timestamp) at which the date range begins */
  readonly start_date?: number,
  /** Point in time (Unix timestamp) at which the date range ends */
  readonly end_date?: number,
}

/** A value with information about its recent changes */
export type statisticalValue = {
  _: 'statisticalValue',
  /** The current value */
  value: number,
  /** The value for the previous day */
  previous_value: number,
  /** The growth rate of the value, as a percentage */
  growth_rate_percentage: number,
}

/** A value with information about its recent changes */
export type statisticalValue$Input = {
  readonly _: 'statisticalValue',
  /** The current value */
  readonly value?: number,
  /** The value for the previous day */
  readonly previous_value?: number,
  /** The growth rate of the value, as a percentage */
  readonly growth_rate_percentage?: number,
}

/** A graph data */
export type statisticalGraphData = {
  _: 'statisticalGraphData',
  /** Graph data in JSON format */
  json_data: string,
  /** If non-empty, a token which can be used to receive a zoomed in graph */
  zoom_token: string,
}

/** A graph data */
export type statisticalGraphData$Input = {
  readonly _: 'statisticalGraphData',
  /** Graph data in JSON format */
  readonly json_data?: string,
  /** If non-empty, a token which can be used to receive a zoomed in graph */
  readonly zoom_token?: string,
}

/** The graph data to be asynchronously loaded through getStatisticalGraph */
export type statisticalGraphAsync = {
  _: 'statisticalGraphAsync',
  /** The token to use for data loading */
  token: string,
}

/** The graph data to be asynchronously loaded through getStatisticalGraph */
export type statisticalGraphAsync$Input = {
  readonly _: 'statisticalGraphAsync',
  /** The token to use for data loading */
  readonly token?: string,
}

/** An error message to be shown to the user instead of the graph */
export type statisticalGraphError = {
  _: 'statisticalGraphError',
  /** The error message */
  error_message: string,
}

/** An error message to be shown to the user instead of the graph */
export type statisticalGraphError$Input = {
  readonly _: 'statisticalGraphError',
  /** The error message */
  readonly error_message?: string,
}

/** Contains statistics about interactions with a message */
export type chatStatisticsMessageInteractionInfo = {
  _: 'chatStatisticsMessageInteractionInfo',
  /** Message identifier */
  message_id: number,
  /** Number of times the message was viewed */
  view_count: number,
  /** Number of times the message was forwarded */
  forward_count: number,
}

/** Contains statistics about interactions with a message */
export type chatStatisticsMessageInteractionInfo$Input = {
  readonly _: 'chatStatisticsMessageInteractionInfo',
  /** Message identifier */
  readonly message_id?: number,
  /** Number of times the message was viewed */
  readonly view_count?: number,
  /** Number of times the message was forwarded */
  readonly forward_count?: number,
}

/** Contains statistics about messages sent by a user */
export type chatStatisticsMessageSenderInfo = {
  _: 'chatStatisticsMessageSenderInfo',
  /** User identifier */
  user_id: number,
  /** Number of sent messages */
  sent_message_count: number,
  /** Average number of characters in sent messages; 0 if unknown */
  average_character_count: number,
}

/** Contains statistics about messages sent by a user */
export type chatStatisticsMessageSenderInfo$Input = {
  readonly _: 'chatStatisticsMessageSenderInfo',
  /** User identifier */
  readonly user_id?: number,
  /** Number of sent messages */
  readonly sent_message_count?: number,
  /** Average number of characters in sent messages; 0 if unknown */
  readonly average_character_count?: number,
}

/** Contains statistics about administrator actions done by a user */
export type chatStatisticsAdministratorActionsInfo = {
  _: 'chatStatisticsAdministratorActionsInfo',
  /** Administrator user identifier */
  user_id: number,
  /** Number of messages deleted by the administrator */
  deleted_message_count: number,
  /** Number of users banned by the administrator */
  banned_user_count: number,
  /** Number of users restricted by the administrator */
  restricted_user_count: number,
}

/** Contains statistics about administrator actions done by a user */
export type chatStatisticsAdministratorActionsInfo$Input = {
  readonly _: 'chatStatisticsAdministratorActionsInfo',
  /** Administrator user identifier */
  readonly user_id?: number,
  /** Number of messages deleted by the administrator */
  readonly deleted_message_count?: number,
  /** Number of users banned by the administrator */
  readonly banned_user_count?: number,
  /** Number of users restricted by the administrator */
  readonly restricted_user_count?: number,
}

/** Contains statistics about number of new members invited by a user */
export type chatStatisticsInviterInfo = {
  _: 'chatStatisticsInviterInfo',
  /** User identifier */
  user_id: number,
  /** Number of new members invited by the user */
  added_member_count: number,
}

/** Contains statistics about number of new members invited by a user */
export type chatStatisticsInviterInfo$Input = {
  readonly _: 'chatStatisticsInviterInfo',
  /** User identifier */
  readonly user_id?: number,
  /** Number of new members invited by the user */
  readonly added_member_count?: number,
}

/** A detailed statistics about a supergroup chat */
export type chatStatisticsSupergroup = {
  _: 'chatStatisticsSupergroup',
  /** A period to which the statistics applies */
  period: dateRange,
  /** Number of members in the chat */
  member_count: statisticalValue,
  /** Number of messages sent to the chat */
  message_count: statisticalValue,
  /** Number of users who viewed messages in the chat */
  viewer_count: statisticalValue,
  /** Number of users who sent messages to the chat */
  sender_count: statisticalValue,
  /** A graph containing number of members in the chat */
  member_count_graph: StatisticalGraph,
  /** A graph containing number of members joined and left the chat */
  join_graph: StatisticalGraph,
  /** A graph containing number of new member joins per source */
  join_by_source_graph: StatisticalGraph,
  /** A graph containing distribution of active users per language */
  language_graph: StatisticalGraph,
  /** A graph containing distribution of sent messages by content type */
  message_content_graph: StatisticalGraph,
  /** A graph containing number of different actions in the chat */
  action_graph: StatisticalGraph,
  /** A graph containing distribution of message views per hour */
  day_graph: StatisticalGraph,
  /** A graph containing distribution of message views per day of week */
  week_graph: StatisticalGraph,
  /** List of users sent most messages in the last week */
  top_senders: Array<chatStatisticsMessageSenderInfo>,
  /** List of most active administrators in the last week */
  top_administrators: Array<chatStatisticsAdministratorActionsInfo>,
  /** List of most active inviters of new members in the last week */
  top_inviters: Array<chatStatisticsInviterInfo>,
}

/** A detailed statistics about a supergroup chat */
export type chatStatisticsSupergroup$Input = {
  readonly _: 'chatStatisticsSupergroup',
  /** A period to which the statistics applies */
  readonly period?: dateRange$Input,
  /** Number of members in the chat */
  readonly member_count?: statisticalValue$Input,
  /** Number of messages sent to the chat */
  readonly message_count?: statisticalValue$Input,
  /** Number of users who viewed messages in the chat */
  readonly viewer_count?: statisticalValue$Input,
  /** Number of users who sent messages to the chat */
  readonly sender_count?: statisticalValue$Input,
  /** A graph containing number of members in the chat */
  readonly member_count_graph?: StatisticalGraph$Input,
  /** A graph containing number of members joined and left the chat */
  readonly join_graph?: StatisticalGraph$Input,
  /** A graph containing number of new member joins per source */
  readonly join_by_source_graph?: StatisticalGraph$Input,
  /** A graph containing distribution of active users per language */
  readonly language_graph?: StatisticalGraph$Input,
  /** A graph containing distribution of sent messages by content type */
  readonly message_content_graph?: StatisticalGraph$Input,
  /** A graph containing number of different actions in the chat */
  readonly action_graph?: StatisticalGraph$Input,
  /** A graph containing distribution of message views per hour */
  readonly day_graph?: StatisticalGraph$Input,
  /** A graph containing distribution of message views per day of week */
  readonly week_graph?: StatisticalGraph$Input,
  /** List of users sent most messages in the last week */
  readonly top_senders?: ReadonlyArray<chatStatisticsMessageSenderInfo$Input>,
  /** List of most active administrators in the last week */
  readonly top_administrators?: ReadonlyArray<chatStatisticsAdministratorActionsInfo$Input>,
  /** List of most active inviters of new members in the last week */
  readonly top_inviters?: ReadonlyArray<chatStatisticsInviterInfo$Input>,
}

/** A detailed statistics about a channel chat */
export type chatStatisticsChannel = {
  _: 'chatStatisticsChannel',
  /** A period to which the statistics applies */
  period: dateRange,
  /** Number of members in the chat */
  member_count: statisticalValue,
  /** Mean number of times the recently sent messages was viewed */
  mean_view_count: statisticalValue,
  /** Mean number of times the recently sent messages was shared */
  mean_share_count: statisticalValue,
  /** A percentage of users with enabled notifications for the chat */
  enabled_notifications_percentage: number,
  /** A graph containing number of members in the chat */
  member_count_graph: StatisticalGraph,
  /** A graph containing number of members joined and left the chat */
  join_graph: StatisticalGraph,
  /** A graph containing number of members muted and unmuted the chat */
  mute_graph: StatisticalGraph,
  /** A graph containing number of message views in a given hour in the last two weeks */
  view_count_by_hour_graph: StatisticalGraph,
  /** A graph containing number of message views per source */
  view_count_by_source_graph: StatisticalGraph,
  /** A graph containing number of new member joins per source */
  join_by_source_graph: StatisticalGraph,
  /** A graph containing number of users viewed chat messages per language */
  language_graph: StatisticalGraph,
  /** A graph containing number of chat message views and shares */
  message_interaction_graph: StatisticalGraph,
  /** A graph containing number of views of associated with the chat instant views */
  instant_view_interaction_graph: StatisticalGraph,
  /** Detailed statistics about number of views and shares of recently sent messages */
  recent_message_interactions: Array<chatStatisticsMessageInteractionInfo>,
}

/** A detailed statistics about a channel chat */
export type chatStatisticsChannel$Input = {
  readonly _: 'chatStatisticsChannel',
  /** A period to which the statistics applies */
  readonly period?: dateRange$Input,
  /** Number of members in the chat */
  readonly member_count?: statisticalValue$Input,
  /** Mean number of times the recently sent messages was viewed */
  readonly mean_view_count?: statisticalValue$Input,
  /** Mean number of times the recently sent messages was shared */
  readonly mean_share_count?: statisticalValue$Input,
  /** A percentage of users with enabled notifications for the chat */
  readonly enabled_notifications_percentage?: number,
  /** A graph containing number of members in the chat */
  readonly member_count_graph?: StatisticalGraph$Input,
  /** A graph containing number of members joined and left the chat */
  readonly join_graph?: StatisticalGraph$Input,
  /** A graph containing number of members muted and unmuted the chat */
  readonly mute_graph?: StatisticalGraph$Input,
  /** A graph containing number of message views in a given hour in the last two weeks */
  readonly view_count_by_hour_graph?: StatisticalGraph$Input,
  /** A graph containing number of message views per source */
  readonly view_count_by_source_graph?: StatisticalGraph$Input,
  /** A graph containing number of new member joins per source */
  readonly join_by_source_graph?: StatisticalGraph$Input,
  /** A graph containing number of users viewed chat messages per language */
  readonly language_graph?: StatisticalGraph$Input,
  /** A graph containing number of chat message views and shares */
  readonly message_interaction_graph?: StatisticalGraph$Input,
  /** A graph containing number of views of associated with the chat instant views */
  readonly instant_view_interaction_graph?: StatisticalGraph$Input,
  /** Detailed statistics about number of views and shares of recently sent messages */
  readonly recent_message_interactions?: ReadonlyArray<chatStatisticsMessageInteractionInfo$Input>,
}

/** A detailed statistics about a message */
export type messageStatistics = {
  _: 'messageStatistics',
  /** A graph containing number of message views and shares */
  message_interaction_graph: StatisticalGraph,
}

/** A detailed statistics about a message */
export type messageStatistics$Input = {
  readonly _: 'messageStatistics',
  /** A graph containing number of message views and shares */
  readonly message_interaction_graph?: StatisticalGraph$Input,
}

/** A point on a Cartesian plane */
export type point = {
  _: 'point',
  /** The point's first coordinate */
  x: number,
  /** The point's second coordinate */
  y: number,
}

/** A point on a Cartesian plane */
export type point$Input = {
  readonly _: 'point',
  /** The point's first coordinate */
  readonly x?: number,
  /** The point's second coordinate */
  readonly y?: number,
}

/** A straight line to a given point */
export type vectorPathCommandLine = {
  _: 'vectorPathCommandLine',
  /** The end point of the straight line */
  end_point: point,
}

/** A straight line to a given point */
export type vectorPathCommandLine$Input = {
  readonly _: 'vectorPathCommandLine',
  /** The end point of the straight line */
  readonly end_point?: point$Input,
}

/** A cubic Bézier curve to a given point */
export type vectorPathCommandCubicBezierCurve = {
  _: 'vectorPathCommandCubicBezierCurve',
  /** The start control point of the curve */
  start_control_point: point,
  /** The end control point of the curve */
  end_control_point: point,
  /** The end point of the curve */
  end_point: point,
}

/** A cubic Bézier curve to a given point */
export type vectorPathCommandCubicBezierCurve$Input = {
  readonly _: 'vectorPathCommandCubicBezierCurve',
  /** The start control point of the curve */
  readonly start_control_point?: point$Input,
  /** The end control point of the curve */
  readonly end_control_point?: point$Input,
  /** The end point of the curve */
  readonly end_point?: point$Input,
}

/** A scope covering all users */
export type botCommandScopeDefault = {
  _: 'botCommandScopeDefault',
}

/** A scope covering all users */
export type botCommandScopeDefault$Input = {
  readonly _: 'botCommandScopeDefault',
}

/** A scope covering all private chats */
export type botCommandScopeAllPrivateChats = {
  _: 'botCommandScopeAllPrivateChats',
}

/** A scope covering all private chats */
export type botCommandScopeAllPrivateChats$Input = {
  readonly _: 'botCommandScopeAllPrivateChats',
}

/** A scope covering all group and supergroup chats */
export type botCommandScopeAllGroupChats = {
  _: 'botCommandScopeAllGroupChats',
}

/** A scope covering all group and supergroup chats */
export type botCommandScopeAllGroupChats$Input = {
  readonly _: 'botCommandScopeAllGroupChats',
}

/** A scope covering all group and supergroup chat administrators */
export type botCommandScopeAllChatAdministrators = {
  _: 'botCommandScopeAllChatAdministrators',
}

/** A scope covering all group and supergroup chat administrators */
export type botCommandScopeAllChatAdministrators$Input = {
  readonly _: 'botCommandScopeAllChatAdministrators',
}

/** A scope covering all members of a chat */
export type botCommandScopeChat = {
  _: 'botCommandScopeChat',
  /** Chat identifier */
  chat_id: number,
}

/** A scope covering all members of a chat */
export type botCommandScopeChat$Input = {
  readonly _: 'botCommandScopeChat',
  /** Chat identifier */
  readonly chat_id?: number,
}

/** A scope covering all administrators of a chat */
export type botCommandScopeChatAdministrators = {
  _: 'botCommandScopeChatAdministrators',
  /** Chat identifier */
  chat_id: number,
}

/** A scope covering all administrators of a chat */
export type botCommandScopeChatAdministrators$Input = {
  readonly _: 'botCommandScopeChatAdministrators',
  /** Chat identifier */
  readonly chat_id?: number,
}

/** A scope covering a member of a chat */
export type botCommandScopeChatMember = {
  _: 'botCommandScopeChatMember',
  /** Chat identifier */
  chat_id: number,
  /** User identifier */
  user_id: number,
}

/** A scope covering a member of a chat */
export type botCommandScopeChatMember$Input = {
  readonly _: 'botCommandScopeChatMember',
  /** Chat identifier */
  readonly chat_id?: number,
  /** User identifier */
  readonly user_id?: number,
}

/** The user authorization state has changed */
export type updateAuthorizationState = {
  _: 'updateAuthorizationState',
  /** New authorization state */
  authorization_state: AuthorizationState,
}

/** The user authorization state has changed */
export type updateAuthorizationState$Input = {
  readonly _: 'updateAuthorizationState',
  /** New authorization state */
  readonly authorization_state?: AuthorizationState$Input,
}

/** A new message was received; can also be an outgoing message */
export type updateNewMessage = {
  _: 'updateNewMessage',
  /** The new message */
  message: message,
}

/** A new message was received; can also be an outgoing message */
export type updateNewMessage$Input = {
  readonly _: 'updateNewMessage',
  /** The new message */
  readonly message?: message$Input,
}

/**
 * A request to send a message has reached the Telegram server. This doesn't mean that
 * the message will be sent successfully or even that the send message request will
 * be processed. This update will be sent only if the option "use_quick_ack" is set
 * to true. This update may be sent multiple times for the same message
 */
export type updateMessageSendAcknowledged = {
  _: 'updateMessageSendAcknowledged',
  /** The chat identifier of the sent message */
  chat_id: number,
  /** A temporary message identifier */
  message_id: number,
}

/**
 * A request to send a message has reached the Telegram server. This doesn't mean that
 * the message will be sent successfully or even that the send message request will
 * be processed. This update will be sent only if the option "use_quick_ack" is set
 * to true. This update may be sent multiple times for the same message
 */
export type updateMessageSendAcknowledged$Input = {
  readonly _: 'updateMessageSendAcknowledged',
  /** The chat identifier of the sent message */
  readonly chat_id?: number,
  /** A temporary message identifier */
  readonly message_id?: number,
}

/** A message has been successfully sent */
export type updateMessageSendSucceeded = {
  _: 'updateMessageSendSucceeded',
  /**
   * The sent message. Usually only the message identifier, date, and content are changed,
   * but almost all other fields can also change
   */
  message: message,
  /** The previous temporary message identifier */
  old_message_id: number,
}

/** A message has been successfully sent */
export type updateMessageSendSucceeded$Input = {
  readonly _: 'updateMessageSendSucceeded',
  /**
   * The sent message. Usually only the message identifier, date, and content are changed,
   * but almost all other fields can also change
   */
  readonly message?: message$Input,
  /** The previous temporary message identifier */
  readonly old_message_id?: number,
}

/**
 * A message failed to send. Be aware that some messages being sent can be irrecoverably
 * deleted, in which case updateDeleteMessages will be received instead of this update
 */
export type updateMessageSendFailed = {
  _: 'updateMessageSendFailed',
  /** The failed to send message */
  message: message,
  /** The previous temporary message identifier */
  old_message_id: number,
  /** An error code */
  error_code: number,
  /** Error message */
  error_message: string,
}

/**
 * A message failed to send. Be aware that some messages being sent can be irrecoverably
 * deleted, in which case updateDeleteMessages will be received instead of this update
 */
export type updateMessageSendFailed$Input = {
  readonly _: 'updateMessageSendFailed',
  /** The failed to send message */
  readonly message?: message$Input,
  /** The previous temporary message identifier */
  readonly old_message_id?: number,
  /** An error code */
  readonly error_code?: number,
  /** Error message */
  readonly error_message?: string,
}

/** The message content has changed */
export type updateMessageContent = {
  _: 'updateMessageContent',
  /** Chat identifier */
  chat_id: number,
  /** Message identifier */
  message_id: number,
  /** New message content */
  new_content: MessageContent,
}

/** The message content has changed */
export type updateMessageContent$Input = {
  readonly _: 'updateMessageContent',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Message identifier */
  readonly message_id?: number,
  /** New message content */
  readonly new_content?: MessageContent$Input,
}

/** A message was edited. Changes in the message content will come in a separate updateMessageContent */
export type updateMessageEdited = {
  _: 'updateMessageEdited',
  /** Chat identifier */
  chat_id: number,
  /** Message identifier */
  message_id: number,
  /** Point in time (Unix timestamp) when the message was edited */
  edit_date: number,
  /** New message reply markup; may be null */
  reply_markup: ReplyMarkup | undefined,
}

/** A message was edited. Changes in the message content will come in a separate updateMessageContent */
export type updateMessageEdited$Input = {
  readonly _: 'updateMessageEdited',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Message identifier */
  readonly message_id?: number,
  /** Point in time (Unix timestamp) when the message was edited */
  readonly edit_date?: number,
  /** New message reply markup; may be null */
  readonly reply_markup?: ReplyMarkup$Input | undefined,
}

/** The message pinned state was changed */
export type updateMessageIsPinned = {
  _: 'updateMessageIsPinned',
  /** Chat identifier */
  chat_id: number,
  /** The message identifier */
  message_id: number,
  /** True, if the message is pinned */
  is_pinned: boolean,
}

/** The message pinned state was changed */
export type updateMessageIsPinned$Input = {
  readonly _: 'updateMessageIsPinned',
  /** Chat identifier */
  readonly chat_id?: number,
  /** The message identifier */
  readonly message_id?: number,
  /** True, if the message is pinned */
  readonly is_pinned?: boolean,
}

/** The information about interactions with a message has changed */
export type updateMessageInteractionInfo = {
  _: 'updateMessageInteractionInfo',
  /** Chat identifier */
  chat_id: number,
  /** Message identifier */
  message_id: number,
  /** New information about interactions with the message; may be null */
  interaction_info: messageInteractionInfo | undefined,
}

/** The information about interactions with a message has changed */
export type updateMessageInteractionInfo$Input = {
  readonly _: 'updateMessageInteractionInfo',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Message identifier */
  readonly message_id?: number,
  /** New information about interactions with the message; may be null */
  readonly interaction_info?: messageInteractionInfo$Input | undefined,
}

/**
 * The message content was opened. Updates voice note messages to "listened", video
 * note messages to "viewed" and starts the TTL timer for self-destructing messages
 */
export type updateMessageContentOpened = {
  _: 'updateMessageContentOpened',
  /** Chat identifier */
  chat_id: number,
  /** Message identifier */
  message_id: number,
}

/**
 * The message content was opened. Updates voice note messages to "listened", video
 * note messages to "viewed" and starts the TTL timer for self-destructing messages
 */
export type updateMessageContentOpened$Input = {
  readonly _: 'updateMessageContentOpened',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Message identifier */
  readonly message_id?: number,
}

/** A message with an unread mention was read */
export type updateMessageMentionRead = {
  _: 'updateMessageMentionRead',
  /** Chat identifier */
  chat_id: number,
  /** Message identifier */
  message_id: number,
  /** The new number of unread mention messages left in the chat */
  unread_mention_count: number,
}

/** A message with an unread mention was read */
export type updateMessageMentionRead$Input = {
  readonly _: 'updateMessageMentionRead',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Message identifier */
  readonly message_id?: number,
  /** The new number of unread mention messages left in the chat */
  readonly unread_mention_count?: number,
}

/**
 * A message with a live location was viewed. When the update is received, the application
 * is supposed to update the live location
 */
export type updateMessageLiveLocationViewed = {
  _: 'updateMessageLiveLocationViewed',
  /** Identifier of the chat with the live location message */
  chat_id: number,
  /** Identifier of the message with live location */
  message_id: number,
}

/**
 * A message with a live location was viewed. When the update is received, the application
 * is supposed to update the live location
 */
export type updateMessageLiveLocationViewed$Input = {
  readonly _: 'updateMessageLiveLocationViewed',
  /** Identifier of the chat with the live location message */
  readonly chat_id?: number,
  /** Identifier of the message with live location */
  readonly message_id?: number,
}

/**
 * A new chat has been loaded/created. This update is guaranteed to come before the
 * chat identifier is returned to the application. The chat field changes will be reported
 * through separate updates
 */
export type updateNewChat = {
  _: 'updateNewChat',
  /** The chat */
  chat: chat,
}

/**
 * A new chat has been loaded/created. This update is guaranteed to come before the
 * chat identifier is returned to the application. The chat field changes will be reported
 * through separate updates
 */
export type updateNewChat$Input = {
  readonly _: 'updateNewChat',
  /** The chat */
  readonly chat?: chat$Input,
}

/** The title of a chat was changed */
export type updateChatTitle = {
  _: 'updateChatTitle',
  /** Chat identifier */
  chat_id: number,
  /** The new chat title */
  title: string,
}

/** The title of a chat was changed */
export type updateChatTitle$Input = {
  readonly _: 'updateChatTitle',
  /** Chat identifier */
  readonly chat_id?: number,
  /** The new chat title */
  readonly title?: string,
}

/** A chat photo was changed */
export type updateChatPhoto = {
  _: 'updateChatPhoto',
  /** Chat identifier */
  chat_id: number,
  /** The new chat photo; may be null */
  photo: chatPhotoInfo | undefined,
}

/** A chat photo was changed */
export type updateChatPhoto$Input = {
  readonly _: 'updateChatPhoto',
  /** Chat identifier */
  readonly chat_id?: number,
  /** The new chat photo; may be null */
  readonly photo?: chatPhotoInfo$Input | undefined,
}

/** Chat permissions was changed */
export type updateChatPermissions = {
  _: 'updateChatPermissions',
  /** Chat identifier */
  chat_id: number,
  /** The new chat permissions */
  permissions: chatPermissions,
}

/** Chat permissions was changed */
export type updateChatPermissions$Input = {
  readonly _: 'updateChatPermissions',
  /** Chat identifier */
  readonly chat_id?: number,
  /** The new chat permissions */
  readonly permissions?: chatPermissions$Input,
}

/**
 * The last message of a chat was changed. If last_message is null, then the last message
 * in the chat became unknown. Some new unknown messages might be added to the chat
 * in this case
 */
export type updateChatLastMessage = {
  _: 'updateChatLastMessage',
  /** Chat identifier */
  chat_id: number,
  /** The new last message in the chat; may be null */
  last_message: message | undefined,
  /** The new chat positions in the chat lists */
  positions: Array<chatPosition>,
}

/**
 * The last message of a chat was changed. If last_message is null, then the last message
 * in the chat became unknown. Some new unknown messages might be added to the chat
 * in this case
 */
export type updateChatLastMessage$Input = {
  readonly _: 'updateChatLastMessage',
  /** Chat identifier */
  readonly chat_id?: number,
  /** The new last message in the chat; may be null */
  readonly last_message?: message$Input | undefined,
  /** The new chat positions in the chat lists */
  readonly positions?: ReadonlyArray<chatPosition$Input>,
}

/**
 * The position of a chat in a chat list has changed. Instead of this update updateChatLastMessage
 * or updateChatDraftMessage might be sent
 */
export type updateChatPosition = {
  _: 'updateChatPosition',
  /** Chat identifier */
  chat_id: number,
  /**
   * New chat position. If new order is 0, then the chat needs to be removed from the
   * list
   */
  position: chatPosition,
}

/**
 * The position of a chat in a chat list has changed. Instead of this update updateChatLastMessage
 * or updateChatDraftMessage might be sent
 */
export type updateChatPosition$Input = {
  readonly _: 'updateChatPosition',
  /** Chat identifier */
  readonly chat_id?: number,
  /**
   * New chat position. If new order is 0, then the chat needs to be removed from the
   * list
   */
  readonly position?: chatPosition$Input,
}

/** Incoming messages were read or the number of unread messages has been changed */
export type updateChatReadInbox = {
  _: 'updateChatReadInbox',
  /** Chat identifier */
  chat_id: number,
  /** Identifier of the last read incoming message */
  last_read_inbox_message_id: number,
  /** The number of unread messages left in the chat */
  unread_count: number,
}

/** Incoming messages were read or the number of unread messages has been changed */
export type updateChatReadInbox$Input = {
  readonly _: 'updateChatReadInbox',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Identifier of the last read incoming message */
  readonly last_read_inbox_message_id?: number,
  /** The number of unread messages left in the chat */
  readonly unread_count?: number,
}

/** Outgoing messages were read */
export type updateChatReadOutbox = {
  _: 'updateChatReadOutbox',
  /** Chat identifier */
  chat_id: number,
  /** Identifier of last read outgoing message */
  last_read_outbox_message_id: number,
}

/** Outgoing messages were read */
export type updateChatReadOutbox$Input = {
  readonly _: 'updateChatReadOutbox',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Identifier of last read outgoing message */
  readonly last_read_outbox_message_id?: number,
}

/** The chat action bar was changed */
export type updateChatActionBar = {
  _: 'updateChatActionBar',
  /** Chat identifier */
  chat_id: number,
  /** The new value of the action bar; may be null */
  action_bar: ChatActionBar | undefined,
}

/** The chat action bar was changed */
export type updateChatActionBar$Input = {
  readonly _: 'updateChatActionBar',
  /** Chat identifier */
  readonly chat_id?: number,
  /** The new value of the action bar; may be null */
  readonly action_bar?: ChatActionBar$Input | undefined,
}

/**
 * A chat draft has changed. Be aware that the update may come in the currently opened
 * chat but with old content of the draft. If the user has changed the content of the
 * draft, this update mustn't be applied
 */
export type updateChatDraftMessage = {
  _: 'updateChatDraftMessage',
  /** Chat identifier */
  chat_id: number,
  /** The new draft message; may be null */
  draft_message: draftMessage | undefined,
  /** The new chat positions in the chat lists */
  positions: Array<chatPosition>,
}

/**
 * A chat draft has changed. Be aware that the update may come in the currently opened
 * chat but with old content of the draft. If the user has changed the content of the
 * draft, this update mustn't be applied
 */
export type updateChatDraftMessage$Input = {
  readonly _: 'updateChatDraftMessage',
  /** Chat identifier */
  readonly chat_id?: number,
  /** The new draft message; may be null */
  readonly draft_message?: draftMessage$Input | undefined,
  /** The new chat positions in the chat lists */
  readonly positions?: ReadonlyArray<chatPosition$Input>,
}

/** The message sender that is selected to send messages in a chat has changed */
export type updateChatMessageSender = {
  _: 'updateChatMessageSender',
  /** Chat identifier */
  chat_id: number,
  /** New value of message_sender_id; may be null if the user can't change message sender */
  message_sender_id: MessageSender | undefined,
}

/** The message sender that is selected to send messages in a chat has changed */
export type updateChatMessageSender$Input = {
  readonly _: 'updateChatMessageSender',
  /** Chat identifier */
  readonly chat_id?: number,
  /** New value of message_sender_id; may be null if the user can't change message sender */
  readonly message_sender_id?: MessageSender$Input | undefined,
}

/** The message Time To Live setting for a chat was changed */
export type updateChatMessageTtl = {
  _: 'updateChatMessageTtl',
  /** Chat identifier */
  chat_id: number,
  /** New value of message_ttl */
  message_ttl: number,
}

/** The message Time To Live setting for a chat was changed */
export type updateChatMessageTtl$Input = {
  readonly _: 'updateChatMessageTtl',
  /** Chat identifier */
  readonly chat_id?: number,
  /** New value of message_ttl */
  readonly message_ttl?: number,
}

/** Notification settings for a chat were changed */
export type updateChatNotificationSettings = {
  _: 'updateChatNotificationSettings',
  /** Chat identifier */
  chat_id: number,
  /** The new notification settings */
  notification_settings: chatNotificationSettings,
}

/** Notification settings for a chat were changed */
export type updateChatNotificationSettings$Input = {
  readonly _: 'updateChatNotificationSettings',
  /** Chat identifier */
  readonly chat_id?: number,
  /** The new notification settings */
  readonly notification_settings?: chatNotificationSettings$Input,
}

/** The chat pending join requests were changed */
export type updateChatPendingJoinRequests = {
  _: 'updateChatPendingJoinRequests',
  /** Chat identifier */
  chat_id: number,
  /** The new data about pending join requests; may be null */
  pending_join_requests: chatJoinRequestsInfo | undefined,
}

/** The chat pending join requests were changed */
export type updateChatPendingJoinRequests$Input = {
  readonly _: 'updateChatPendingJoinRequests',
  /** Chat identifier */
  readonly chat_id?: number,
  /** The new data about pending join requests; may be null */
  readonly pending_join_requests?: chatJoinRequestsInfo$Input | undefined,
}

/**
 * The default chat reply markup was changed. Can occur because new messages with reply
 * markup were received or because an old reply markup was hidden by the user
 */
export type updateChatReplyMarkup = {
  _: 'updateChatReplyMarkup',
  /** Chat identifier */
  chat_id: number,
  /**
   * Identifier of the message from which reply markup needs to be used; 0 if there is
   * no default custom reply markup in the chat
   */
  reply_markup_message_id: number,
}

/**
 * The default chat reply markup was changed. Can occur because new messages with reply
 * markup were received or because an old reply markup was hidden by the user
 */
export type updateChatReplyMarkup$Input = {
  readonly _: 'updateChatReplyMarkup',
  /** Chat identifier */
  readonly chat_id?: number,
  /**
   * Identifier of the message from which reply markup needs to be used; 0 if there is
   * no default custom reply markup in the chat
   */
  readonly reply_markup_message_id?: number,
}

/** The chat theme was changed */
export type updateChatTheme = {
  _: 'updateChatTheme',
  /** Chat identifier */
  chat_id: number,
  /** The new name of the chat theme; may be empty if theme was reset to default */
  theme_name: string,
}

/** The chat theme was changed */
export type updateChatTheme$Input = {
  readonly _: 'updateChatTheme',
  /** Chat identifier */
  readonly chat_id?: number,
  /** The new name of the chat theme; may be empty if theme was reset to default */
  readonly theme_name?: string,
}

/** The chat unread_mention_count has changed */
export type updateChatUnreadMentionCount = {
  _: 'updateChatUnreadMentionCount',
  /** Chat identifier */
  chat_id: number,
  /** The number of unread mention messages left in the chat */
  unread_mention_count: number,
}

/** The chat unread_mention_count has changed */
export type updateChatUnreadMentionCount$Input = {
  readonly _: 'updateChatUnreadMentionCount',
  /** Chat identifier */
  readonly chat_id?: number,
  /** The number of unread mention messages left in the chat */
  readonly unread_mention_count?: number,
}

/** A chat video chat state has changed */
export type updateChatVideoChat = {
  _: 'updateChatVideoChat',
  /** Chat identifier */
  chat_id: number,
  /** New value of video_chat */
  video_chat: videoChat,
}

/** A chat video chat state has changed */
export type updateChatVideoChat$Input = {
  readonly _: 'updateChatVideoChat',
  /** Chat identifier */
  readonly chat_id?: number,
  /** New value of video_chat */
  readonly video_chat?: videoChat$Input,
}

/**
 * The value of the default disable_notification parameter, used when a message is sent
 * to the chat, was changed
 */
export type updateChatDefaultDisableNotification = {
  _: 'updateChatDefaultDisableNotification',
  /** Chat identifier */
  chat_id: number,
  /** The new default_disable_notification value */
  default_disable_notification: boolean,
}

/**
 * The value of the default disable_notification parameter, used when a message is sent
 * to the chat, was changed
 */
export type updateChatDefaultDisableNotification$Input = {
  readonly _: 'updateChatDefaultDisableNotification',
  /** Chat identifier */
  readonly chat_id?: number,
  /** The new default_disable_notification value */
  readonly default_disable_notification?: boolean,
}

/** A chat content was allowed or restricted for saving */
export type updateChatHasProtectedContent = {
  _: 'updateChatHasProtectedContent',
  /** Chat identifier */
  chat_id: number,
  /** New value of has_protected_content */
  has_protected_content: boolean,
}

/** A chat content was allowed or restricted for saving */
export type updateChatHasProtectedContent$Input = {
  readonly _: 'updateChatHasProtectedContent',
  /** Chat identifier */
  readonly chat_id?: number,
  /** New value of has_protected_content */
  readonly has_protected_content?: boolean,
}

/** A chat's has_scheduled_messages field has changed */
export type updateChatHasScheduledMessages = {
  _: 'updateChatHasScheduledMessages',
  /** Chat identifier */
  chat_id: number,
  /** New value of has_scheduled_messages */
  has_scheduled_messages: boolean,
}

/** A chat's has_scheduled_messages field has changed */
export type updateChatHasScheduledMessages$Input = {
  readonly _: 'updateChatHasScheduledMessages',
  /** Chat identifier */
  readonly chat_id?: number,
  /** New value of has_scheduled_messages */
  readonly has_scheduled_messages?: boolean,
}

/** A chat was blocked or unblocked */
export type updateChatIsBlocked = {
  _: 'updateChatIsBlocked',
  /** Chat identifier */
  chat_id: number,
  /** New value of is_blocked */
  is_blocked: boolean,
}

/** A chat was blocked or unblocked */
export type updateChatIsBlocked$Input = {
  readonly _: 'updateChatIsBlocked',
  /** Chat identifier */
  readonly chat_id?: number,
  /** New value of is_blocked */
  readonly is_blocked?: boolean,
}

/** A chat was marked as unread or was read */
export type updateChatIsMarkedAsUnread = {
  _: 'updateChatIsMarkedAsUnread',
  /** Chat identifier */
  chat_id: number,
  /** New value of is_marked_as_unread */
  is_marked_as_unread: boolean,
}

/** A chat was marked as unread or was read */
export type updateChatIsMarkedAsUnread$Input = {
  readonly _: 'updateChatIsMarkedAsUnread',
  /** Chat identifier */
  readonly chat_id?: number,
  /** New value of is_marked_as_unread */
  readonly is_marked_as_unread?: boolean,
}

/** The list of chat filters or a chat filter has changed */
export type updateChatFilters = {
  _: 'updateChatFilters',
  /** The new list of chat filters */
  chat_filters: Array<chatFilterInfo>,
}

/** The list of chat filters or a chat filter has changed */
export type updateChatFilters$Input = {
  readonly _: 'updateChatFilters',
  /** The new list of chat filters */
  readonly chat_filters?: ReadonlyArray<chatFilterInfo$Input>,
}

/**
 * The number of online group members has changed. This update with non-zero count is
 * sent only for currently opened chats. There is no guarantee that it will be sent
 * just after the count has changed
 */
export type updateChatOnlineMemberCount = {
  _: 'updateChatOnlineMemberCount',
  /** Identifier of the chat */
  chat_id: number,
  /** New number of online members in the chat, or 0 if unknown */
  online_member_count: number,
}

/**
 * The number of online group members has changed. This update with non-zero count is
 * sent only for currently opened chats. There is no guarantee that it will be sent
 * just after the count has changed
 */
export type updateChatOnlineMemberCount$Input = {
  readonly _: 'updateChatOnlineMemberCount',
  /** Identifier of the chat */
  readonly chat_id?: number,
  /** New number of online members in the chat, or 0 if unknown */
  readonly online_member_count?: number,
}

/** Notification settings for some type of chats were updated */
export type updateScopeNotificationSettings = {
  _: 'updateScopeNotificationSettings',
  /** Types of chats for which notification settings were updated */
  scope: NotificationSettingsScope,
  /** The new notification settings */
  notification_settings: scopeNotificationSettings,
}

/** Notification settings for some type of chats were updated */
export type updateScopeNotificationSettings$Input = {
  readonly _: 'updateScopeNotificationSettings',
  /** Types of chats for which notification settings were updated */
  readonly scope?: NotificationSettingsScope$Input,
  /** The new notification settings */
  readonly notification_settings?: scopeNotificationSettings$Input,
}

/** A notification was changed */
export type updateNotification = {
  _: 'updateNotification',
  /** Unique notification group identifier */
  notification_group_id: number,
  /** Changed notification */
  notification: notification,
}

/** A notification was changed */
export type updateNotification$Input = {
  readonly _: 'updateNotification',
  /** Unique notification group identifier */
  readonly notification_group_id?: number,
  /** Changed notification */
  readonly notification?: notification$Input,
}

/** A list of active notifications in a notification group has changed */
export type updateNotificationGroup = {
  _: 'updateNotificationGroup',
  /** Unique notification group identifier */
  notification_group_id: number,
  /** New type of the notification group */
  type: NotificationGroupType,
  /** Identifier of a chat to which all notifications in the group belong */
  chat_id: number,
  /** Chat identifier, which notification settings must be applied to the added notifications */
  notification_settings_chat_id: number,
  /** True, if the notifications must be shown without sound */
  is_silent: boolean,
  /**
   * Total number of unread notifications in the group, can be bigger than number of active
   * notifications
   */
  total_count: number,
  /** List of added group notifications, sorted by notification ID */
  added_notifications: Array<notification>,
  /** Identifiers of removed group notifications, sorted by notification ID */
  removed_notification_ids: Array<number>,
}

/** A list of active notifications in a notification group has changed */
export type updateNotificationGroup$Input = {
  readonly _: 'updateNotificationGroup',
  /** Unique notification group identifier */
  readonly notification_group_id?: number,
  /** New type of the notification group */
  readonly type?: NotificationGroupType$Input,
  /** Identifier of a chat to which all notifications in the group belong */
  readonly chat_id?: number,
  /** Chat identifier, which notification settings must be applied to the added notifications */
  readonly notification_settings_chat_id?: number,
  /** True, if the notifications must be shown without sound */
  readonly is_silent?: boolean,
  /**
   * Total number of unread notifications in the group, can be bigger than number of active
   * notifications
   */
  readonly total_count?: number,
  /** List of added group notifications, sorted by notification ID */
  readonly added_notifications?: ReadonlyArray<notification$Input>,
  /** Identifiers of removed group notifications, sorted by notification ID */
  readonly removed_notification_ids?: ReadonlyArray<number>,
}

/**
 * Contains active notifications that was shown on previous application launches. This
 * update is sent only if the message database is used. In that case it comes once before
 * any updateNotification and updateNotificationGroup update
 */
export type updateActiveNotifications = {
  _: 'updateActiveNotifications',
  /** Lists of active notification groups */
  groups: Array<notificationGroup>,
}

/**
 * Contains active notifications that was shown on previous application launches. This
 * update is sent only if the message database is used. In that case it comes once before
 * any updateNotification and updateNotificationGroup update
 */
export type updateActiveNotifications$Input = {
  readonly _: 'updateActiveNotifications',
  /** Lists of active notification groups */
  readonly groups?: ReadonlyArray<notificationGroup$Input>,
}

/**
 * Describes whether there are some pending notification updates. Can be used to prevent
 * application from killing, while there are some pending notifications
 */
export type updateHavePendingNotifications = {
  _: 'updateHavePendingNotifications',
  /** True, if there are some delayed notification updates, which will be sent soon */
  have_delayed_notifications: boolean,
  /**
   * True, if there can be some yet unreceived notifications, which are being fetched
   * from the server
   */
  have_unreceived_notifications: boolean,
}

/**
 * Describes whether there are some pending notification updates. Can be used to prevent
 * application from killing, while there are some pending notifications
 */
export type updateHavePendingNotifications$Input = {
  readonly _: 'updateHavePendingNotifications',
  /** True, if there are some delayed notification updates, which will be sent soon */
  readonly have_delayed_notifications?: boolean,
  /**
   * True, if there can be some yet unreceived notifications, which are being fetched
   * from the server
   */
  readonly have_unreceived_notifications?: boolean,
}

/** Some messages were deleted */
export type updateDeleteMessages = {
  _: 'updateDeleteMessages',
  /** Chat identifier */
  chat_id: number,
  /** Identifiers of the deleted messages */
  message_ids: Array<number>,
  /**
   * True, if the messages are permanently deleted by a user (as opposed to just becoming
   * inaccessible)
   */
  is_permanent: boolean,
  /**
   * True, if the messages are deleted only from the cache and can possibly be retrieved
   * again in the future
   */
  from_cache: boolean,
}

/** Some messages were deleted */
export type updateDeleteMessages$Input = {
  readonly _: 'updateDeleteMessages',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Identifiers of the deleted messages */
  readonly message_ids?: ReadonlyArray<number>,
  /**
   * True, if the messages are permanently deleted by a user (as opposed to just becoming
   * inaccessible)
   */
  readonly is_permanent?: boolean,
  /**
   * True, if the messages are deleted only from the cache and can possibly be retrieved
   * again in the future
   */
  readonly from_cache?: boolean,
}

/** A message sender activity in the chat has changed */
export type updateChatAction = {
  _: 'updateChatAction',
  /** Chat identifier */
  chat_id: number,
  /** If not 0, a message thread identifier in which the action was performed */
  message_thread_id: number,
  /** Identifier of a message sender performing the action */
  sender_id: MessageSender,
  /** The action */
  action: ChatAction,
}

/** A message sender activity in the chat has changed */
export type updateChatAction$Input = {
  readonly _: 'updateChatAction',
  /** Chat identifier */
  readonly chat_id?: number,
  /** If not 0, a message thread identifier in which the action was performed */
  readonly message_thread_id?: number,
  /** Identifier of a message sender performing the action */
  readonly sender_id?: MessageSender$Input,
  /** The action */
  readonly action?: ChatAction$Input,
}

/** The user went online or offline */
export type updateUserStatus = {
  _: 'updateUserStatus',
  /** User identifier */
  user_id: number,
  /** New status of the user */
  status: UserStatus,
}

/** The user went online or offline */
export type updateUserStatus$Input = {
  readonly _: 'updateUserStatus',
  /** User identifier */
  readonly user_id?: number,
  /** New status of the user */
  readonly status?: UserStatus$Input,
}

/**
 * Some data of a user has changed. This update is guaranteed to come before the user
 * identifier is returned to the application
 */
export type updateUser = {
  _: 'updateUser',
  /** New data about the user */
  user: user,
}

/**
 * Some data of a user has changed. This update is guaranteed to come before the user
 * identifier is returned to the application
 */
export type updateUser$Input = {
  readonly _: 'updateUser',
  /** New data about the user */
  readonly user?: user$Input,
}

/**
 * Some data of a basic group has changed. This update is guaranteed to come before
 * the basic group identifier is returned to the application
 */
export type updateBasicGroup = {
  _: 'updateBasicGroup',
  /** New data about the group */
  basic_group: basicGroup,
}

/**
 * Some data of a basic group has changed. This update is guaranteed to come before
 * the basic group identifier is returned to the application
 */
export type updateBasicGroup$Input = {
  readonly _: 'updateBasicGroup',
  /** New data about the group */
  readonly basic_group?: basicGroup$Input,
}

/**
 * Some data of a supergroup or a channel has changed. This update is guaranteed to
 * come before the supergroup identifier is returned to the application
 */
export type updateSupergroup = {
  _: 'updateSupergroup',
  /** New data about the supergroup */
  supergroup: supergroup,
}

/**
 * Some data of a supergroup or a channel has changed. This update is guaranteed to
 * come before the supergroup identifier is returned to the application
 */
export type updateSupergroup$Input = {
  readonly _: 'updateSupergroup',
  /** New data about the supergroup */
  readonly supergroup?: supergroup$Input,
}

/**
 * Some data of a secret chat has changed. This update is guaranteed to come before
 * the secret chat identifier is returned to the application
 */
export type updateSecretChat = {
  _: 'updateSecretChat',
  /** New data about the secret chat */
  secret_chat: secretChat,
}

/**
 * Some data of a secret chat has changed. This update is guaranteed to come before
 * the secret chat identifier is returned to the application
 */
export type updateSecretChat$Input = {
  readonly _: 'updateSecretChat',
  /** New data about the secret chat */
  readonly secret_chat?: secretChat$Input,
}

/** Some data in userFullInfo has been changed */
export type updateUserFullInfo = {
  _: 'updateUserFullInfo',
  /** User identifier */
  user_id: number,
  /** New full information about the user */
  user_full_info: userFullInfo,
}

/** Some data in userFullInfo has been changed */
export type updateUserFullInfo$Input = {
  readonly _: 'updateUserFullInfo',
  /** User identifier */
  readonly user_id?: number,
  /** New full information about the user */
  readonly user_full_info?: userFullInfo$Input,
}

/** Some data in basicGroupFullInfo has been changed */
export type updateBasicGroupFullInfo = {
  _: 'updateBasicGroupFullInfo',
  /** Identifier of a basic group */
  basic_group_id: number,
  /** New full information about the group */
  basic_group_full_info: basicGroupFullInfo,
}

/** Some data in basicGroupFullInfo has been changed */
export type updateBasicGroupFullInfo$Input = {
  readonly _: 'updateBasicGroupFullInfo',
  /** Identifier of a basic group */
  readonly basic_group_id?: number,
  /** New full information about the group */
  readonly basic_group_full_info?: basicGroupFullInfo$Input,
}

/** Some data in supergroupFullInfo has been changed */
export type updateSupergroupFullInfo = {
  _: 'updateSupergroupFullInfo',
  /** Identifier of the supergroup or channel */
  supergroup_id: number,
  /** New full information about the supergroup */
  supergroup_full_info: supergroupFullInfo,
}

/** Some data in supergroupFullInfo has been changed */
export type updateSupergroupFullInfo$Input = {
  readonly _: 'updateSupergroupFullInfo',
  /** Identifier of the supergroup or channel */
  readonly supergroup_id?: number,
  /** New full information about the supergroup */
  readonly supergroup_full_info?: supergroupFullInfo$Input,
}

/**
 * A service notification from the server was received. Upon receiving this the application
 * must show a popup with the content of the notification
 */
export type updateServiceNotification = {
  _: 'updateServiceNotification',
  /**
   * Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel"
   * and "Log out" must be shown under notification; if user presses the second, all local
   * data must be destroyed using Destroy method
   */
  type: string,
  /** Notification content */
  content: MessageContent,
}

/**
 * A service notification from the server was received. Upon receiving this the application
 * must show a popup with the content of the notification
 */
export type updateServiceNotification$Input = {
  readonly _: 'updateServiceNotification',
  /**
   * Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel"
   * and "Log out" must be shown under notification; if user presses the second, all local
   * data must be destroyed using Destroy method
   */
  readonly type?: string,
  /** Notification content */
  readonly content?: MessageContent$Input,
}

/** Information about a file was updated */
export type updateFile = {
  _: 'updateFile',
  /** New data about the file */
  file: file,
}

/** Information about a file was updated */
export type updateFile$Input = {
  readonly _: 'updateFile',
  /** New data about the file */
  readonly file?: file$Input,
}

/** The file generation process needs to be started by the application */
export type updateFileGenerationStart = {
  _: 'updateFileGenerationStart',
  /** Unique identifier for the generation process */
  generation_id: number | string,
  /** The path to a file from which a new file is generated; may be empty */
  original_path: string,
  /** The path to a file that must be created and where the new file is generated */
  destination_path: string,
  /**
   * String specifying the conversion applied to the original file. If conversion is "#url#"
   * than original_path contains an HTTP/HTTPS URL of a file, which must be downloaded
   * by the application
   */
  conversion: string,
}

/** The file generation process needs to be started by the application */
export type updateFileGenerationStart$Input = {
  readonly _: 'updateFileGenerationStart',
  /** Unique identifier for the generation process */
  readonly generation_id?: number | string,
  /** The path to a file from which a new file is generated; may be empty */
  readonly original_path?: string,
  /** The path to a file that must be created and where the new file is generated */
  readonly destination_path?: string,
  /**
   * String specifying the conversion applied to the original file. If conversion is "#url#"
   * than original_path contains an HTTP/HTTPS URL of a file, which must be downloaded
   * by the application
   */
  readonly conversion?: string,
}

/** File generation is no longer needed */
export type updateFileGenerationStop = {
  _: 'updateFileGenerationStop',
  /** Unique identifier for the generation process */
  generation_id: number | string,
}

/** File generation is no longer needed */
export type updateFileGenerationStop$Input = {
  readonly _: 'updateFileGenerationStop',
  /** Unique identifier for the generation process */
  readonly generation_id?: number | string,
}

/** New call was created or information about a call was updated */
export type updateCall = {
  _: 'updateCall',
  /** New data about a call */
  call: call,
}

/** New call was created or information about a call was updated */
export type updateCall$Input = {
  readonly _: 'updateCall',
  /** New data about a call */
  readonly call?: call$Input,
}

/** Information about a group call was updated */
export type updateGroupCall = {
  _: 'updateGroupCall',
  /** New data about a group call */
  group_call: groupCall,
}

/** Information about a group call was updated */
export type updateGroupCall$Input = {
  readonly _: 'updateGroupCall',
  /** New data about a group call */
  readonly group_call?: groupCall$Input,
}

/**
 * Information about a group call participant was changed. The updates are sent only
 * after the group call is received through getGroupCall and only if the call is joined
 * or being joined
 */
export type updateGroupCallParticipant = {
  _: 'updateGroupCallParticipant',
  /** Identifier of group call */
  group_call_id: number,
  /** New data about a participant */
  participant: groupCallParticipant,
}

/**
 * Information about a group call participant was changed. The updates are sent only
 * after the group call is received through getGroupCall and only if the call is joined
 * or being joined
 */
export type updateGroupCallParticipant$Input = {
  readonly _: 'updateGroupCallParticipant',
  /** Identifier of group call */
  readonly group_call_id?: number,
  /** New data about a participant */
  readonly participant?: groupCallParticipant$Input,
}

/** New call signaling data arrived */
export type updateNewCallSignalingData = {
  _: 'updateNewCallSignalingData',
  /** The call identifier */
  call_id: number,
  /** The data */
  data: string,
}

/** New call signaling data arrived */
export type updateNewCallSignalingData$Input = {
  readonly _: 'updateNewCallSignalingData',
  /** The call identifier */
  readonly call_id?: number,
  /** The data */
  readonly data?: string,
}

/** Some privacy setting rules have been changed */
export type updateUserPrivacySettingRules = {
  _: 'updateUserPrivacySettingRules',
  /** The privacy setting */
  setting: UserPrivacySetting,
  /** New privacy rules */
  rules: userPrivacySettingRules,
}

/** Some privacy setting rules have been changed */
export type updateUserPrivacySettingRules$Input = {
  readonly _: 'updateUserPrivacySettingRules',
  /** The privacy setting */
  readonly setting?: UserPrivacySetting$Input,
  /** New privacy rules */
  readonly rules?: userPrivacySettingRules$Input,
}

/**
 * Number of unread messages in a chat list has changed. This update is sent only if
 * the message database is used
 */
export type updateUnreadMessageCount = {
  _: 'updateUnreadMessageCount',
  /** The chat list with changed number of unread messages */
  chat_list: ChatList,
  /** Total number of unread messages */
  unread_count: number,
  /** Total number of unread messages in unmuted chats */
  unread_unmuted_count: number,
}

/**
 * Number of unread messages in a chat list has changed. This update is sent only if
 * the message database is used
 */
export type updateUnreadMessageCount$Input = {
  readonly _: 'updateUnreadMessageCount',
  /** The chat list with changed number of unread messages */
  readonly chat_list?: ChatList$Input,
  /** Total number of unread messages */
  readonly unread_count?: number,
  /** Total number of unread messages in unmuted chats */
  readonly unread_unmuted_count?: number,
}

/**
 * Number of unread chats, i.e. with unread messages or marked as unread, has changed.
 * This update is sent only if the message database is used
 */
export type updateUnreadChatCount = {
  _: 'updateUnreadChatCount',
  /** The chat list with changed number of unread messages */
  chat_list: ChatList,
  /** Approximate total number of chats in the chat list */
  total_count: number,
  /** Total number of unread chats */
  unread_count: number,
  /** Total number of unread unmuted chats */
  unread_unmuted_count: number,
  /** Total number of chats marked as unread */
  marked_as_unread_count: number,
  /** Total number of unmuted chats marked as unread */
  marked_as_unread_unmuted_count: number,
}

/**
 * Number of unread chats, i.e. with unread messages or marked as unread, has changed.
 * This update is sent only if the message database is used
 */
export type updateUnreadChatCount$Input = {
  readonly _: 'updateUnreadChatCount',
  /** The chat list with changed number of unread messages */
  readonly chat_list?: ChatList$Input,
  /** Approximate total number of chats in the chat list */
  readonly total_count?: number,
  /** Total number of unread chats */
  readonly unread_count?: number,
  /** Total number of unread unmuted chats */
  readonly unread_unmuted_count?: number,
  /** Total number of chats marked as unread */
  readonly marked_as_unread_count?: number,
  /** Total number of unmuted chats marked as unread */
  readonly marked_as_unread_unmuted_count?: number,
}

/** An option changed its value */
export type updateOption = {
  _: 'updateOption',
  /** The option name */
  name: string,
  /** The new option value */
  value: OptionValue,
}

/** An option changed its value */
export type updateOption$Input = {
  readonly _: 'updateOption',
  /** The option name */
  readonly name?: string,
  /** The new option value */
  readonly value?: OptionValue$Input,
}

/** A sticker set has changed */
export type updateStickerSet = {
  _: 'updateStickerSet',
  /** The sticker set */
  sticker_set: stickerSet,
}

/** A sticker set has changed */
export type updateStickerSet$Input = {
  readonly _: 'updateStickerSet',
  /** The sticker set */
  readonly sticker_set?: stickerSet$Input,
}

/** The list of installed sticker sets was updated */
export type updateInstalledStickerSets = {
  _: 'updateInstalledStickerSets',
  /** True, if the list of installed mask sticker sets was updated */
  is_masks: boolean,
  /** The new list of installed ordinary sticker sets */
  sticker_set_ids: Array<number | string>,
}

/** The list of installed sticker sets was updated */
export type updateInstalledStickerSets$Input = {
  readonly _: 'updateInstalledStickerSets',
  /** True, if the list of installed mask sticker sets was updated */
  readonly is_masks?: boolean,
  /** The new list of installed ordinary sticker sets */
  readonly sticker_set_ids?: ReadonlyArray<number | string>,
}

/** The list of trending sticker sets was updated or some of them were viewed */
export type updateTrendingStickerSets = {
  _: 'updateTrendingStickerSets',
  /**
   * The prefix of the list of trending sticker sets with the newest trending sticker
   * sets
   */
  sticker_sets: stickerSets,
}

/** The list of trending sticker sets was updated or some of them were viewed */
export type updateTrendingStickerSets$Input = {
  readonly _: 'updateTrendingStickerSets',
  /**
   * The prefix of the list of trending sticker sets with the newest trending sticker
   * sets
   */
  readonly sticker_sets?: stickerSets$Input,
}

/** The list of recently used stickers was updated */
export type updateRecentStickers = {
  _: 'updateRecentStickers',
  /**
   * True, if the list of stickers attached to photo or video files was updated, otherwise
   * the list of sent stickers is updated
   */
  is_attached: boolean,
  /** The new list of file identifiers of recently used stickers */
  sticker_ids: Array<number>,
}

/** The list of recently used stickers was updated */
export type updateRecentStickers$Input = {
  readonly _: 'updateRecentStickers',
  /**
   * True, if the list of stickers attached to photo or video files was updated, otherwise
   * the list of sent stickers is updated
   */
  readonly is_attached?: boolean,
  /** The new list of file identifiers of recently used stickers */
  readonly sticker_ids?: ReadonlyArray<number>,
}

/** The list of favorite stickers was updated */
export type updateFavoriteStickers = {
  _: 'updateFavoriteStickers',
  /** The new list of file identifiers of favorite stickers */
  sticker_ids: Array<number>,
}

/** The list of favorite stickers was updated */
export type updateFavoriteStickers$Input = {
  readonly _: 'updateFavoriteStickers',
  /** The new list of file identifiers of favorite stickers */
  readonly sticker_ids?: ReadonlyArray<number>,
}

/** The list of saved animations was updated */
export type updateSavedAnimations = {
  _: 'updateSavedAnimations',
  /** The new list of file identifiers of saved animations */
  animation_ids: Array<number>,
}

/** The list of saved animations was updated */
export type updateSavedAnimations$Input = {
  readonly _: 'updateSavedAnimations',
  /** The new list of file identifiers of saved animations */
  readonly animation_ids?: ReadonlyArray<number>,
}

/** The selected background has changed */
export type updateSelectedBackground = {
  _: 'updateSelectedBackground',
  /** True, if background for dark theme has changed */
  for_dark_theme: boolean,
  /** The new selected background; may be null */
  background: background | undefined,
}

/** The selected background has changed */
export type updateSelectedBackground$Input = {
  readonly _: 'updateSelectedBackground',
  /** True, if background for dark theme has changed */
  readonly for_dark_theme?: boolean,
  /** The new selected background; may be null */
  readonly background?: background$Input | undefined,
}

/** The list of available chat themes has changed */
export type updateChatThemes = {
  _: 'updateChatThemes',
  /** The new list of chat themes */
  chat_themes: Array<chatTheme>,
}

/** The list of available chat themes has changed */
export type updateChatThemes$Input = {
  readonly _: 'updateChatThemes',
  /** The new list of chat themes */
  readonly chat_themes?: ReadonlyArray<chatTheme$Input>,
}

/** Some language pack strings have been updated */
export type updateLanguagePackStrings = {
  _: 'updateLanguagePackStrings',
  /** Localization target to which the language pack belongs */
  localization_target: string,
  /** Identifier of the updated language pack */
  language_pack_id: string,
  /** List of changed language pack strings */
  strings: Array<languagePackString>,
}

/** Some language pack strings have been updated */
export type updateLanguagePackStrings$Input = {
  readonly _: 'updateLanguagePackStrings',
  /** Localization target to which the language pack belongs */
  readonly localization_target?: string,
  /** Identifier of the updated language pack */
  readonly language_pack_id?: string,
  /** List of changed language pack strings */
  readonly strings?: ReadonlyArray<languagePackString$Input>,
}

/**
 * The connection state has changed. This update must be used only to show a human-readable
 * description of the connection state
 */
export type updateConnectionState = {
  _: 'updateConnectionState',
  /** The new connection state */
  state: ConnectionState,
}

/**
 * The connection state has changed. This update must be used only to show a human-readable
 * description of the connection state
 */
export type updateConnectionState$Input = {
  readonly _: 'updateConnectionState',
  /** The new connection state */
  readonly state?: ConnectionState$Input,
}

/**
 * New terms of service must be accepted by the user. If the terms of service are declined,
 * then the deleteAccount method must be called with the reason "Decline ToS update"
 */
export type updateTermsOfService = {
  _: 'updateTermsOfService',
  /** Identifier of the terms of service */
  terms_of_service_id: string,
  /** The new terms of service */
  terms_of_service: termsOfService,
}

/**
 * New terms of service must be accepted by the user. If the terms of service are declined,
 * then the deleteAccount method must be called with the reason "Decline ToS update"
 */
export type updateTermsOfService$Input = {
  readonly _: 'updateTermsOfService',
  /** Identifier of the terms of service */
  readonly terms_of_service_id?: string,
  /** The new terms of service */
  readonly terms_of_service?: termsOfService$Input,
}

/**
 * The list of users nearby has changed. The update is guaranteed to be sent only 60
 * seconds after a successful searchChatsNearby request
 */
export type updateUsersNearby = {
  _: 'updateUsersNearby',
  /** The new list of users nearby */
  users_nearby: Array<chatNearby>,
}

/**
 * The list of users nearby has changed. The update is guaranteed to be sent only 60
 * seconds after a successful searchChatsNearby request
 */
export type updateUsersNearby$Input = {
  readonly _: 'updateUsersNearby',
  /** The new list of users nearby */
  readonly users_nearby?: ReadonlyArray<chatNearby$Input>,
}

/** The list of supported dice emojis has changed */
export type updateDiceEmojis = {
  _: 'updateDiceEmojis',
  /** The new list of supported dice emojis */
  emojis: Array<string>,
}

/** The list of supported dice emojis has changed */
export type updateDiceEmojis$Input = {
  readonly _: 'updateDiceEmojis',
  /** The new list of supported dice emojis */
  readonly emojis?: ReadonlyArray<string>,
}

/**
 * Some animated emoji message was clicked and a big animated sticker must be played
 * if the message is visible on the screen. chatActionWatchingAnimations with the text
 * of the message needs to be sent if the sticker is played
 */
export type updateAnimatedEmojiMessageClicked = {
  _: 'updateAnimatedEmojiMessageClicked',
  /** Chat identifier */
  chat_id: number,
  /** Message identifier */
  message_id: number,
  /** The animated sticker to be played */
  sticker: sticker,
}

/**
 * Some animated emoji message was clicked and a big animated sticker must be played
 * if the message is visible on the screen. chatActionWatchingAnimations with the text
 * of the message needs to be sent if the sticker is played
 */
export type updateAnimatedEmojiMessageClicked$Input = {
  readonly _: 'updateAnimatedEmojiMessageClicked',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Message identifier */
  readonly message_id?: number,
  /** The animated sticker to be played */
  readonly sticker?: sticker$Input,
}

/**
 * The parameters of animation search through GetOption("animation_search_bot_username")
 * bot has changed
 */
export type updateAnimationSearchParameters = {
  _: 'updateAnimationSearchParameters',
  /** Name of the animation search provider */
  provider: string,
  /** The new list of emojis suggested for searching */
  emojis: Array<string>,
}

/**
 * The parameters of animation search through GetOption("animation_search_bot_username")
 * bot has changed
 */
export type updateAnimationSearchParameters$Input = {
  readonly _: 'updateAnimationSearchParameters',
  /** Name of the animation search provider */
  readonly provider?: string,
  /** The new list of emojis suggested for searching */
  readonly emojis?: ReadonlyArray<string>,
}

/** The list of suggested to the user actions has changed */
export type updateSuggestedActions = {
  _: 'updateSuggestedActions',
  /** Added suggested actions */
  added_actions: Array<SuggestedAction>,
  /** Removed suggested actions */
  removed_actions: Array<SuggestedAction>,
}

/** The list of suggested to the user actions has changed */
export type updateSuggestedActions$Input = {
  readonly _: 'updateSuggestedActions',
  /** Added suggested actions */
  readonly added_actions?: ReadonlyArray<SuggestedAction$Input>,
  /** Removed suggested actions */
  readonly removed_actions?: ReadonlyArray<SuggestedAction$Input>,
}

/** A new incoming inline query; for bots only */
export type updateNewInlineQuery = {
  _: 'updateNewInlineQuery',
  /** Unique query identifier */
  id: number | string,
  /** Identifier of the user who sent the query */
  sender_user_id: number,
  /** User location; may be null */
  user_location: location | undefined,
  /** The type of the chat, from which the query originated; may be null if unknown */
  chat_type: ChatType | undefined,
  /** Text of the query */
  query: string,
  /** Offset of the first entry to return */
  offset: string,
}

/** A new incoming inline query; for bots only */
export type updateNewInlineQuery$Input = {
  readonly _: 'updateNewInlineQuery',
  /** Unique query identifier */
  readonly id?: number | string,
  /** Identifier of the user who sent the query */
  readonly sender_user_id?: number,
  /** User location; may be null */
  readonly user_location?: location$Input | undefined,
  /** The type of the chat, from which the query originated; may be null if unknown */
  readonly chat_type?: ChatType$Input | undefined,
  /** Text of the query */
  readonly query?: string,
  /** Offset of the first entry to return */
  readonly offset?: string,
}

/** The user has chosen a result of an inline query; for bots only */
export type updateNewChosenInlineResult = {
  _: 'updateNewChosenInlineResult',
  /** Identifier of the user who sent the query */
  sender_user_id: number,
  /** User location; may be null */
  user_location: location | undefined,
  /** Text of the query */
  query: string,
  /** Identifier of the chosen result */
  result_id: string,
  /** Identifier of the sent inline message, if known */
  inline_message_id: string,
}

/** The user has chosen a result of an inline query; for bots only */
export type updateNewChosenInlineResult$Input = {
  readonly _: 'updateNewChosenInlineResult',
  /** Identifier of the user who sent the query */
  readonly sender_user_id?: number,
  /** User location; may be null */
  readonly user_location?: location$Input | undefined,
  /** Text of the query */
  readonly query?: string,
  /** Identifier of the chosen result */
  readonly result_id?: string,
  /** Identifier of the sent inline message, if known */
  readonly inline_message_id?: string,
}

/** A new incoming callback query; for bots only */
export type updateNewCallbackQuery = {
  _: 'updateNewCallbackQuery',
  /** Unique query identifier */
  id: number | string,
  /** Identifier of the user who sent the query */
  sender_user_id: number,
  /** Identifier of the chat where the query was sent */
  chat_id: number,
  /** Identifier of the message, from which the query originated */
  message_id: number,
  /** Identifier that uniquely corresponds to the chat to which the message was sent */
  chat_instance: number | string,
  /** Query payload */
  payload: CallbackQueryPayload,
}

/** A new incoming callback query; for bots only */
export type updateNewCallbackQuery$Input = {
  readonly _: 'updateNewCallbackQuery',
  /** Unique query identifier */
  readonly id?: number | string,
  /** Identifier of the user who sent the query */
  readonly sender_user_id?: number,
  /** Identifier of the chat where the query was sent */
  readonly chat_id?: number,
  /** Identifier of the message, from which the query originated */
  readonly message_id?: number,
  /** Identifier that uniquely corresponds to the chat to which the message was sent */
  readonly chat_instance?: number | string,
  /** Query payload */
  readonly payload?: CallbackQueryPayload$Input,
}

/** A new incoming callback query from a message sent via a bot; for bots only */
export type updateNewInlineCallbackQuery = {
  _: 'updateNewInlineCallbackQuery',
  /** Unique query identifier */
  id: number | string,
  /** Identifier of the user who sent the query */
  sender_user_id: number,
  /** Identifier of the inline message, from which the query originated */
  inline_message_id: string,
  /** An identifier uniquely corresponding to the chat a message was sent to */
  chat_instance: number | string,
  /** Query payload */
  payload: CallbackQueryPayload,
}

/** A new incoming callback query from a message sent via a bot; for bots only */
export type updateNewInlineCallbackQuery$Input = {
  readonly _: 'updateNewInlineCallbackQuery',
  /** Unique query identifier */
  readonly id?: number | string,
  /** Identifier of the user who sent the query */
  readonly sender_user_id?: number,
  /** Identifier of the inline message, from which the query originated */
  readonly inline_message_id?: string,
  /** An identifier uniquely corresponding to the chat a message was sent to */
  readonly chat_instance?: number | string,
  /** Query payload */
  readonly payload?: CallbackQueryPayload$Input,
}

/** A new incoming shipping query; for bots only. Only for invoices with flexible price */
export type updateNewShippingQuery = {
  _: 'updateNewShippingQuery',
  /** Unique query identifier */
  id: number | string,
  /** Identifier of the user who sent the query */
  sender_user_id: number,
  /** Invoice payload */
  invoice_payload: string,
  /** User shipping address */
  shipping_address: address,
}

/** A new incoming shipping query; for bots only. Only for invoices with flexible price */
export type updateNewShippingQuery$Input = {
  readonly _: 'updateNewShippingQuery',
  /** Unique query identifier */
  readonly id?: number | string,
  /** Identifier of the user who sent the query */
  readonly sender_user_id?: number,
  /** Invoice payload */
  readonly invoice_payload?: string,
  /** User shipping address */
  readonly shipping_address?: address$Input,
}

/**
 * A new incoming pre-checkout query; for bots only. Contains full information about
 * a checkout
 */
export type updateNewPreCheckoutQuery = {
  _: 'updateNewPreCheckoutQuery',
  /** Unique query identifier */
  id: number | string,
  /** Identifier of the user who sent the query */
  sender_user_id: number,
  /** Currency for the product price */
  currency: string,
  /** Total price for the product, in the smallest units of the currency */
  total_amount: number,
  /** Invoice payload */
  invoice_payload: string,
  /** Identifier of a shipping option chosen by the user; may be empty if not applicable */
  shipping_option_id: string,
  /** Information about the order; may be null */
  order_info: orderInfo | undefined,
}

/**
 * A new incoming pre-checkout query; for bots only. Contains full information about
 * a checkout
 */
export type updateNewPreCheckoutQuery$Input = {
  readonly _: 'updateNewPreCheckoutQuery',
  /** Unique query identifier */
  readonly id?: number | string,
  /** Identifier of the user who sent the query */
  readonly sender_user_id?: number,
  /** Currency for the product price */
  readonly currency?: string,
  /** Total price for the product, in the smallest units of the currency */
  readonly total_amount?: number,
  /** Invoice payload */
  readonly invoice_payload?: string,
  /** Identifier of a shipping option chosen by the user; may be empty if not applicable */
  readonly shipping_option_id?: string,
  /** Information about the order; may be null */
  readonly order_info?: orderInfo$Input | undefined,
}

/** A new incoming event; for bots only */
export type updateNewCustomEvent = {
  _: 'updateNewCustomEvent',
  /** A JSON-serialized event */
  event: string,
}

/** A new incoming event; for bots only */
export type updateNewCustomEvent$Input = {
  readonly _: 'updateNewCustomEvent',
  /** A JSON-serialized event */
  readonly event?: string,
}

/** A new incoming query; for bots only */
export type updateNewCustomQuery = {
  _: 'updateNewCustomQuery',
  /** The query identifier */
  id: number | string,
  /** JSON-serialized query data */
  data: string,
  /** Query timeout */
  timeout: number,
}

/** A new incoming query; for bots only */
export type updateNewCustomQuery$Input = {
  readonly _: 'updateNewCustomQuery',
  /** The query identifier */
  readonly id?: number | string,
  /** JSON-serialized query data */
  readonly data?: string,
  /** Query timeout */
  readonly timeout?: number,
}

/** A poll was updated; for bots only */
export type updatePoll = {
  _: 'updatePoll',
  /** New data about the poll */
  poll: poll,
}

/** A poll was updated; for bots only */
export type updatePoll$Input = {
  readonly _: 'updatePoll',
  /** New data about the poll */
  readonly poll?: poll$Input,
}

/** A user changed the answer to a poll; for bots only */
export type updatePollAnswer = {
  _: 'updatePollAnswer',
  /** Unique poll identifier */
  poll_id: number | string,
  /** The user, who changed the answer to the poll */
  user_id: number,
  /** 0-based identifiers of answer options, chosen by the user */
  option_ids: Array<number>,
}

/** A user changed the answer to a poll; for bots only */
export type updatePollAnswer$Input = {
  readonly _: 'updatePollAnswer',
  /** Unique poll identifier */
  readonly poll_id?: number | string,
  /** The user, who changed the answer to the poll */
  readonly user_id?: number,
  /** 0-based identifiers of answer options, chosen by the user */
  readonly option_ids?: ReadonlyArray<number>,
}

/** User rights changed in a chat; for bots only */
export type updateChatMember = {
  _: 'updateChatMember',
  /** Chat identifier */
  chat_id: number,
  /** Identifier of the user, changing the rights */
  actor_user_id: number,
  /** Point in time (Unix timestamp) when the user rights was changed */
  date: number,
  /** If user has joined the chat using an invite link, the invite link; may be null */
  invite_link: chatInviteLink | undefined,
  /** Previous chat member */
  old_chat_member: chatMember,
  /** New chat member */
  new_chat_member: chatMember,
}

/** User rights changed in a chat; for bots only */
export type updateChatMember$Input = {
  readonly _: 'updateChatMember',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Identifier of the user, changing the rights */
  readonly actor_user_id?: number,
  /** Point in time (Unix timestamp) when the user rights was changed */
  readonly date?: number,
  /** If user has joined the chat using an invite link, the invite link; may be null */
  readonly invite_link?: chatInviteLink$Input | undefined,
  /** Previous chat member */
  readonly old_chat_member?: chatMember$Input,
  /** New chat member */
  readonly new_chat_member?: chatMember$Input,
}

/** A user sent a join request to a chat; for bots only */
export type updateNewChatJoinRequest = {
  _: 'updateNewChatJoinRequest',
  /** Chat identifier */
  chat_id: number,
  /** Join request */
  request: chatJoinRequest,
  /** The invite link, which was used to send join request; may be null */
  invite_link: chatInviteLink | undefined,
}

/** A user sent a join request to a chat; for bots only */
export type updateNewChatJoinRequest$Input = {
  readonly _: 'updateNewChatJoinRequest',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Join request */
  readonly request?: chatJoinRequest$Input,
  /** The invite link, which was used to send join request; may be null */
  readonly invite_link?: chatInviteLink$Input | undefined,
}

/** Contains a list of updates */
export type updates = {
  _: 'updates',
  /** List of updates */
  updates: Array<Update>,
}

/** Contains a list of updates */
export type updates$Input = {
  readonly _: 'updates',
  /** List of updates */
  readonly updates?: ReadonlyArray<Update$Input>,
}

/** The log is written to stderr or an OS specific log */
export type logStreamDefault = {
  _: 'logStreamDefault',
}

/** The log is written to stderr or an OS specific log */
export type logStreamDefault$Input = {
  readonly _: 'logStreamDefault',
}

/** The log is written to a file */
export type logStreamFile = {
  _: 'logStreamFile',
  /** Path to the file to where the internal TDLib log will be written */
  path: string,
  /**
   * The maximum size of the file to where the internal TDLib log is written before the
   * file will automatically be rotated, in bytes
   */
  max_file_size: number,
  /** Pass true to additionally redirect stderr to the log file. Ignored on Windows */
  redirect_stderr: boolean,
}

/** The log is written to a file */
export type logStreamFile$Input = {
  readonly _: 'logStreamFile',
  /** Path to the file to where the internal TDLib log will be written */
  readonly path?: string,
  /**
   * The maximum size of the file to where the internal TDLib log is written before the
   * file will automatically be rotated, in bytes
   */
  readonly max_file_size?: number,
  /** Pass true to additionally redirect stderr to the log file. Ignored on Windows */
  readonly redirect_stderr?: boolean,
}

/** The log is written nowhere */
export type logStreamEmpty = {
  _: 'logStreamEmpty',
}

/** The log is written nowhere */
export type logStreamEmpty$Input = {
  readonly _: 'logStreamEmpty',
}

/** Contains a TDLib internal log verbosity level */
export type logVerbosityLevel = {
  _: 'logVerbosityLevel',
  /** Log verbosity level */
  verbosity_level: number,
}

/** Contains a TDLib internal log verbosity level */
export type logVerbosityLevel$Input = {
  readonly _: 'logVerbosityLevel',
  /** Log verbosity level */
  readonly verbosity_level?: number,
}

/** Contains a list of available TDLib internal log tags */
export type logTags = {
  _: 'logTags',
  /** List of log tags */
  tags: Array<string>,
}

/** Contains a list of available TDLib internal log tags */
export type logTags$Input = {
  readonly _: 'logTags',
  /** List of log tags */
  readonly tags?: ReadonlyArray<string>,
}

/** A simple object containing a number; for testing only */
export type testInt = {
  _: 'testInt',
  /** Number */
  value: number,
}

/** A simple object containing a number; for testing only */
export type testInt$Input = {
  readonly _: 'testInt',
  /** Number */
  readonly value?: number,
}

/** A simple object containing a string; for testing only */
export type testString = {
  _: 'testString',
  /** String */
  value: string,
}

/** A simple object containing a string; for testing only */
export type testString$Input = {
  readonly _: 'testString',
  /** String */
  readonly value?: string,
}

/** A simple object containing a sequence of bytes; for testing only */
export type testBytes = {
  _: 'testBytes',
  /** Bytes */
  value: string,
}

/** A simple object containing a sequence of bytes; for testing only */
export type testBytes$Input = {
  readonly _: 'testBytes',
  /** Bytes */
  readonly value?: string,
}

/** A simple object containing a vector of numbers; for testing only */
export type testVectorInt = {
  _: 'testVectorInt',
  /** Vector of numbers */
  value: Array<number>,
}

/** A simple object containing a vector of numbers; for testing only */
export type testVectorInt$Input = {
  readonly _: 'testVectorInt',
  /** Vector of numbers */
  readonly value?: ReadonlyArray<number>,
}

/** A simple object containing a vector of objects that hold a number; for testing only */
export type testVectorIntObject = {
  _: 'testVectorIntObject',
  /** Vector of objects */
  value: Array<testInt>,
}

/** A simple object containing a vector of objects that hold a number; for testing only */
export type testVectorIntObject$Input = {
  readonly _: 'testVectorIntObject',
  /** Vector of objects */
  readonly value?: ReadonlyArray<testInt$Input>,
}

/** A simple object containing a vector of strings; for testing only */
export type testVectorString = {
  _: 'testVectorString',
  /** Vector of strings */
  value: Array<string>,
}

/** A simple object containing a vector of strings; for testing only */
export type testVectorString$Input = {
  readonly _: 'testVectorString',
  /** Vector of strings */
  readonly value?: ReadonlyArray<string>,
}

/** A simple object containing a vector of objects that hold a string; for testing only */
export type testVectorStringObject = {
  _: 'testVectorStringObject',
  /** Vector of objects */
  value: Array<testString>,
}

/** A simple object containing a vector of objects that hold a string; for testing only */
export type testVectorStringObject$Input = {
  readonly _: 'testVectorStringObject',
  /** Vector of objects */
  readonly value?: ReadonlyArray<testString$Input>,
}

/**
 * Returns the current authorization state; this is an offline request. For informational
 * purposes only. Use updateAuthorizationState instead to maintain the current authorization
 * state. Can be called before initialization
 */
export type getAuthorizationState = {
  readonly _: 'getAuthorizationState',
}

/**
 * Sets the parameters for TDLib initialization. Works only when the current authorization
 * state is authorizationStateWaitTdlibParameters
 */
export type setTdlibParameters = {
  readonly _: 'setTdlibParameters',
  /** Parameters for TDLib initialization */
  readonly parameters?: tdlibParameters$Input,
}

/**
 * Checks the database encryption key for correctness. Works only when the current authorization
 * state is authorizationStateWaitEncryptionKey
 */
export type checkDatabaseEncryptionKey = {
  readonly _: 'checkDatabaseEncryptionKey',
  /** Encryption key to check or set up */
  readonly encryption_key?: string,
}

/**
 * Sets the phone number of the user and sends an authentication code to the user. Works
 * only when the current authorization state is authorizationStateWaitPhoneNumber, or
 * if there is no pending authentication query and the current authorization state is
 * authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
 */
export type setAuthenticationPhoneNumber = {
  readonly _: 'setAuthenticationPhoneNumber',
  /** The phone number of the user, in international format */
  readonly phone_number?: string,
  /**
   * Settings for the authentication of the user's phone number; pass null to use default
   * settings
   */
  readonly settings?: phoneNumberAuthenticationSettings$Input,
}

/**
 * Re-sends an authentication code to the user. Works only when the current authorization
 * state is authorizationStateWaitCode, the next_code_type of the result is not null
 * and the server-specified timeout has passed
 */
export type resendAuthenticationCode = {
  readonly _: 'resendAuthenticationCode',
}

/**
 * Checks the authentication code. Works only when the current authorization state is
 * authorizationStateWaitCode
 */
export type checkAuthenticationCode = {
  readonly _: 'checkAuthenticationCode',
  /** Authentication code to check */
  readonly code?: string,
}

/**
 * Requests QR code authentication by scanning a QR code on another logged in device.
 * Works only when the current authorization state is authorizationStateWaitPhoneNumber,
 * or if there is no pending authentication query and the current authorization state
 * is authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
 */
export type requestQrCodeAuthentication = {
  readonly _: 'requestQrCodeAuthentication',
  /** List of user identifiers of other users currently using the application */
  readonly other_user_ids?: ReadonlyArray<number>,
}

/** Finishes user registration. Works only when the current authorization state is authorizationStateWaitRegistration */
export type registerUser = {
  readonly _: 'registerUser',
  /** The first name of the user; 1-64 characters */
  readonly first_name?: string,
  /** The last name of the user; 0-64 characters */
  readonly last_name?: string,
}

/**
 * Checks the authentication password for correctness. Works only when the current authorization
 * state is authorizationStateWaitPassword
 */
export type checkAuthenticationPassword = {
  readonly _: 'checkAuthenticationPassword',
  /** The password to check */
  readonly password?: string,
}

/**
 * Requests to send a password recovery code to an email address that was previously
 * set up. Works only when the current authorization state is authorizationStateWaitPassword
 */
export type requestAuthenticationPasswordRecovery = {
  readonly _: 'requestAuthenticationPasswordRecovery',
}

/**
 * Checks whether a password recovery code sent to an email address is valid. Works
 * only when the current authorization state is authorizationStateWaitPassword
 */
export type checkAuthenticationPasswordRecoveryCode = {
  readonly _: 'checkAuthenticationPasswordRecoveryCode',
  /** Recovery code to check */
  readonly recovery_code?: string,
}

/**
 * Recovers the password with a password recovery code sent to an email address that
 * was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
 */
export type recoverAuthenticationPassword = {
  readonly _: 'recoverAuthenticationPassword',
  /** Recovery code to check */
  readonly recovery_code?: string,
  /** New password of the user; may be empty to remove the password */
  readonly new_password?: string,
  /** New password hint; may be empty */
  readonly new_hint?: string,
}

/**
 * Checks the authentication token of a bot; to log in as a bot. Works only when the
 * current authorization state is authorizationStateWaitPhoneNumber. Can be used instead
 * of setAuthenticationPhoneNumber and checkAuthenticationCode to log in
 */
export type checkAuthenticationBotToken = {
  readonly _: 'checkAuthenticationBotToken',
  /** The bot token */
  readonly token?: string,
}

/**
 * Closes the TDLib instance after a proper logout. Requires an available network connection.
 * All local data will be destroyed. After the logout completes, updateAuthorizationState
 * with authorizationStateClosed will be sent
 */
export type logOut = {
  readonly _: 'logOut',
}

/**
 * Closes the TDLib instance. All databases will be flushed to disk and properly closed.
 * After the close completes, updateAuthorizationState with authorizationStateClosed
 * will be sent. Can be called before initialization
 */
export type close = {
  readonly _: 'close',
}

/**
 * Closes the TDLib instance, destroying all local data without a proper logout. The
 * current user session will remain in the list of all active sessions. All local data
 * will be destroyed. After the destruction completes updateAuthorizationState with
 * authorizationStateClosed will be sent. Can be called before authorization
 */
export type destroy = {
  readonly _: 'destroy',
}

/** Confirms QR code authentication on another device. Returns created session on success */
export type confirmQrCodeAuthentication = {
  readonly _: 'confirmQrCodeAuthentication',
  /** A link from a QR code. The link must be scanned by the in-app camera */
  readonly link?: string,
}

/**
 * Returns all updates needed to restore current TDLib state, i.e. all actual UpdateAuthorizationState/UpdateUser/UpdateNewChat
 * and others. This is especially useful if TDLib is run in a separate process. Can
 * be called before initialization
 */
export type getCurrentState = {
  readonly _: 'getCurrentState',
}

/**
 * Changes the database encryption key. Usually the encryption key is never changed
 * and is stored in some OS keychain
 */
export type setDatabaseEncryptionKey = {
  readonly _: 'setDatabaseEncryptionKey',
  /** New encryption key */
  readonly new_encryption_key?: string,
}

/** Returns the current state of 2-step verification */
export type getPasswordState = {
  readonly _: 'getPasswordState',
}

/**
 * Changes the password for the current user. If a new recovery email address is specified,
 * then the change will not be applied until the new recovery email address is confirmed
 */
export type setPassword = {
  readonly _: 'setPassword',
  /** Previous password of the user */
  readonly old_password?: string,
  /** New password of the user; may be empty to remove the password */
  readonly new_password?: string,
  /** New password hint; may be empty */
  readonly new_hint?: string,
  /** Pass true if the recovery email address must be changed */
  readonly set_recovery_email_address?: boolean,
  /** New recovery email address; may be empty */
  readonly new_recovery_email_address?: string,
}

/**
 * Returns a 2-step verification recovery email address that was previously set up.
 * This method can be used to verify a password provided by the user
 */
export type getRecoveryEmailAddress = {
  readonly _: 'getRecoveryEmailAddress',
  /** The password for the current user */
  readonly password?: string,
}

/**
 * Changes the 2-step verification recovery email address of the user. If a new recovery
 * email address is specified, then the change will not be applied until the new recovery
 * email address is confirmed. If new_recovery_email_address is the same as the email
 * address that is currently set up, this call succeeds immediately and aborts all other
 * requests waiting for an email confirmation
 */
export type setRecoveryEmailAddress = {
  readonly _: 'setRecoveryEmailAddress',
  /** Password of the current user */
  readonly password?: string,
  /** New recovery email address */
  readonly new_recovery_email_address?: string,
}

/** Checks the 2-step verification recovery email address verification code */
export type checkRecoveryEmailAddressCode = {
  readonly _: 'checkRecoveryEmailAddressCode',
  /** Verification code to check */
  readonly code?: string,
}

/** Resends the 2-step verification recovery email address verification code */
export type resendRecoveryEmailAddressCode = {
  readonly _: 'resendRecoveryEmailAddressCode',
}

/**
 * Requests to send a 2-step verification password recovery code to an email address
 * that was previously set up
 */
export type requestPasswordRecovery = {
  readonly _: 'requestPasswordRecovery',
}

/**
 * Checks whether a 2-step verification password recovery code sent to an email address
 * is valid
 */
export type checkPasswordRecoveryCode = {
  readonly _: 'checkPasswordRecoveryCode',
  /** Recovery code to check */
  readonly recovery_code?: string,
}

/**
 * Recovers the 2-step verification password using a recovery code sent to an email
 * address that was previously set up
 */
export type recoverPassword = {
  readonly _: 'recoverPassword',
  /** Recovery code to check */
  readonly recovery_code?: string,
  /** New password of the user; may be empty to remove the password */
  readonly new_password?: string,
  /** New password hint; may be empty */
  readonly new_hint?: string,
}

/**
 * Removes 2-step verification password without previous password and access to recovery
 * email address. The password can't be reset immediately and the request needs to be
 * repeated after the specified time
 */
export type resetPassword = {
  readonly _: 'resetPassword',
}

/**
 * Cancels reset of 2-step verification password. The method can be called if passwordState.pending_reset_date
 * > 0
 */
export type cancelPasswordReset = {
  readonly _: 'cancelPasswordReset',
}

/** Creates a new temporary password for processing payments */
export type createTemporaryPassword = {
  readonly _: 'createTemporaryPassword',
  /** Persistent user password */
  readonly password?: string,
  /**
   * Time during which the temporary password will be valid, in seconds; must be between
   * 60 and 86400
   */
  readonly valid_for?: number,
}

/** Returns information about the current temporary password */
export type getTemporaryPasswordState = {
  readonly _: 'getTemporaryPasswordState',
}

/** Returns the current user */
export type getMe = {
  readonly _: 'getMe',
}

/**
 * Returns information about a user by their identifier. This is an offline request
 * if the current user is not a bot
 */
export type getUser = {
  readonly _: 'getUser',
  /** User identifier */
  readonly user_id?: number,
}

/** Returns full information about a user by their identifier */
export type getUserFullInfo = {
  readonly _: 'getUserFullInfo',
  /** User identifier */
  readonly user_id?: number,
}

/**
 * Returns information about a basic group by its identifier. This is an offline request
 * if the current user is not a bot
 */
export type getBasicGroup = {
  readonly _: 'getBasicGroup',
  /** Basic group identifier */
  readonly basic_group_id?: number,
}

/** Returns full information about a basic group by its identifier */
export type getBasicGroupFullInfo = {
  readonly _: 'getBasicGroupFullInfo',
  /** Basic group identifier */
  readonly basic_group_id?: number,
}

/**
 * Returns information about a supergroup or a channel by its identifier. This is an
 * offline request if the current user is not a bot
 */
export type getSupergroup = {
  readonly _: 'getSupergroup',
  /** Supergroup or channel identifier */
  readonly supergroup_id?: number,
}

/**
 * Returns full information about a supergroup or a channel by its identifier, cached
 * for up to 1 minute
 */
export type getSupergroupFullInfo = {
  readonly _: 'getSupergroupFullInfo',
  /** Supergroup or channel identifier */
  readonly supergroup_id?: number,
}

/** Returns information about a secret chat by its identifier. This is an offline request */
export type getSecretChat = {
  readonly _: 'getSecretChat',
  /** Secret chat identifier */
  readonly secret_chat_id?: number,
}

/**
 * Returns information about a chat by its identifier, this is an offline request if
 * the current user is not a bot
 */
export type getChat = {
  readonly _: 'getChat',
  /** Chat identifier */
  readonly chat_id?: number,
}

/** Returns information about a message */
export type getMessage = {
  readonly _: 'getMessage',
  /** Identifier of the chat the message belongs to */
  readonly chat_id?: number,
  /** Identifier of the message to get */
  readonly message_id?: number,
}

/**
 * Returns information about a message, if it is available locally without sending network
 * request. This is an offline request
 */
export type getMessageLocally = {
  readonly _: 'getMessageLocally',
  /** Identifier of the chat the message belongs to */
  readonly chat_id?: number,
  /** Identifier of the message to get */
  readonly message_id?: number,
}

/**
 * Returns information about a message that is replied by a given message. Also returns
 * the pinned message, the game message, and the invoice message for messages of the
 * types messagePinMessage, messageGameScore, and messagePaymentSuccessful respectively
 */
export type getRepliedMessage = {
  readonly _: 'getRepliedMessage',
  /** Identifier of the chat the message belongs to */
  readonly chat_id?: number,
  /** Identifier of the reply message */
  readonly message_id?: number,
}

/** Returns information about a newest pinned message in the chat */
export type getChatPinnedMessage = {
  readonly _: 'getChatPinnedMessage',
  /** Identifier of the chat the message belongs to */
  readonly chat_id?: number,
}

/**
 * Returns information about a message with the callback button that originated a callback
 * query; for bots only
 */
export type getCallbackQueryMessage = {
  readonly _: 'getCallbackQueryMessage',
  /** Identifier of the chat the message belongs to */
  readonly chat_id?: number,
  /** Message identifier */
  readonly message_id?: number,
  /** Identifier of the callback query */
  readonly callback_query_id?: number | string,
}

/**
 * Returns information about messages. If a message is not found, returns null on the
 * corresponding position of the result
 */
export type getMessages = {
  readonly _: 'getMessages',
  /** Identifier of the chat the messages belong to */
  readonly chat_id?: number,
  /** Identifiers of the messages to get */
  readonly message_ids?: ReadonlyArray<number>,
}

/**
 * Returns information about a message thread. Can be used only if message.can_get_message_thread
 * == true
 */
export type getMessageThread = {
  readonly _: 'getMessageThread',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Identifier of the message */
  readonly message_id?: number,
}

/**
 * Returns viewers of a recent outgoing message in a basic group or a supergroup chat.
 * For video notes and voice notes only users, opened content of the message, are returned.
 * The method can be called if message.can_get_viewers == true
 */
export type getMessageViewers = {
  readonly _: 'getMessageViewers',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Identifier of the message */
  readonly message_id?: number,
}

/** Returns information about a file; this is an offline request */
export type getFile = {
  readonly _: 'getFile',
  /** Identifier of the file to get */
  readonly file_id?: number,
}

/**
 * Returns information about a file by its remote ID; this is an offline request. Can
 * be used to register a URL as a file for further uploading, or sending as a message.
 * Even the request succeeds, the file can be used only if it is still accessible to
 * the user. For example, if the file is from a message, then the message must be not
 * deleted and accessible to the user. If the file database is disabled, then the corresponding
 * object with the file must be preloaded by the application
 */
export type getRemoteFile = {
  readonly _: 'getRemoteFile',
  /** Remote identifier of the file to get */
  readonly remote_file_id?: string,
  /** File type; pass null if unknown */
  readonly file_type?: FileType$Input,
}

/**
 * Loads more chats from a chat list. The loaded chats and their positions in the chat
 * list will be sent through updates. Chats are sorted by the pair (chat.position.order,
 * chat.id) in descending order. Returns a 404 error if all chats have been loaded
 */
export type loadChats = {
  readonly _: 'loadChats',
  /**
   * The chat list in which to load chats; pass null to load chats from the main chat
   * list
   */
  readonly chat_list?: ChatList$Input,
  /**
   * The maximum number of chats to be loaded. For optimal performance, the number of
   * loaded chats is chosen by TDLib and can be smaller than the specified limit, even
   * if the end of the list is not reached
   */
  readonly limit?: number,
}

/**
 * Returns an ordered list of chats from the beginning of a chat list. For informational
 * purposes only. Use loadChats and updates processing instead to maintain chat lists
 * in a consistent state
 */
export type getChats = {
  readonly _: 'getChats',
  /**
   * The chat list in which to return chats; pass null to get chats from the main chat
   * list
   */
  readonly chat_list?: ChatList$Input,
  /** The maximum number of chats to be returned */
  readonly limit?: number,
}

/**
 * Searches a public chat by its username. Currently, only private chats, supergroups
 * and channels can be public. Returns the chat if found; otherwise an error is returned
 */
export type searchPublicChat = {
  readonly _: 'searchPublicChat',
  /** Username to be resolved */
  readonly username?: string,
}

/**
 * Searches public chats by looking for specified query in their username and title.
 * Currently, only private chats, supergroups and channels can be public. Returns a
 * meaningful number of results. Excludes private chats with contacts and chats from
 * the chat list from the results
 */
export type searchPublicChats = {
  readonly _: 'searchPublicChats',
  /** Query to search for */
  readonly query?: string,
}

/**
 * Searches for the specified query in the title and username of already known chats,
 * this is an offline request. Returns chats in the order seen in the main chat list
 */
export type searchChats = {
  readonly _: 'searchChats',
  /** Query to search for. If the query is empty, returns up to 50 recently found chats */
  readonly query?: string,
  /** The maximum number of chats to be returned */
  readonly limit?: number,
}

/**
 * Searches for the specified query in the title and username of already known chats
 * via request to the server. Returns chats in the order seen in the main chat list
 */
export type searchChatsOnServer = {
  readonly _: 'searchChatsOnServer',
  /** Query to search for */
  readonly query?: string,
  /** The maximum number of chats to be returned */
  readonly limit?: number,
}

/**
 * Returns a list of users and location-based supergroups nearby. The list of users
 * nearby will be updated for 60 seconds after the request by the updates updateUsersNearby.
 * The request must be sent again every 25 seconds with adjusted location to not miss
 * new chats
 */
export type searchChatsNearby = {
  readonly _: 'searchChatsNearby',
  /** Current user location */
  readonly location?: location$Input,
}

/**
 * Returns a list of frequently used chats. Supported only if the chat info database
 * is enabled
 */
export type getTopChats = {
  readonly _: 'getTopChats',
  /** Category of chats to be returned */
  readonly category?: TopChatCategory$Input,
  /** The maximum number of chats to be returned; up to 30 */
  readonly limit?: number,
}

/**
 * Removes a chat from the list of frequently used chats. Supported only if the chat
 * info database is enabled
 */
export type removeTopChat = {
  readonly _: 'removeTopChat',
  /** Category of frequently used chats */
  readonly category?: TopChatCategory$Input,
  /** Chat identifier */
  readonly chat_id?: number,
}

/**
 * Adds a chat to the list of recently found chats. The chat is added to the beginning
 * of the list. If the chat is already in the list, it will be removed from the list
 * first
 */
export type addRecentlyFoundChat = {
  readonly _: 'addRecentlyFoundChat',
  /** Identifier of the chat to add */
  readonly chat_id?: number,
}

/** Removes a chat from the list of recently found chats */
export type removeRecentlyFoundChat = {
  readonly _: 'removeRecentlyFoundChat',
  /** Identifier of the chat to be removed */
  readonly chat_id?: number,
}

/** Clears the list of recently found chats */
export type clearRecentlyFoundChats = {
  readonly _: 'clearRecentlyFoundChats',
}

/**
 * Returns recently opened chats, this is an offline request. Returns chats in the order
 * of last opening
 */
export type getRecentlyOpenedChats = {
  readonly _: 'getRecentlyOpenedChats',
  /** The maximum number of chats to be returned */
  readonly limit?: number,
}

/** Checks whether a username can be set for a chat */
export type checkChatUsername = {
  readonly _: 'checkChatUsername',
  /**
   * Chat identifier; must be identifier of a supergroup chat, or a channel chat, or a
   * private chat with self, or zero if the chat is being created
   */
  readonly chat_id?: number,
  /** Username to be checked */
  readonly username?: string,
}

/** Returns a list of public chats of the specified type, owned by the user */
export type getCreatedPublicChats = {
  readonly _: 'getCreatedPublicChats',
  /** Type of the public chats to return */
  readonly type?: PublicChatType$Input,
}

/**
 * Checks whether the maximum number of owned public chats has been reached. Returns
 * corresponding error if the limit was reached
 */
export type checkCreatedPublicChatsLimit = {
  readonly _: 'checkCreatedPublicChatsLimit',
  /** Type of the public chats, for which to check the limit */
  readonly type?: PublicChatType$Input,
}

/**
 * Returns a list of basic group and supergroup chats, which can be used as a discussion
 * group for a channel. Returned basic group chats must be first upgraded to supergroups
 * before they can be set as a discussion group. To set a returned supergroup as a discussion
 * group, access to its old messages must be enabled using toggleSupergroupIsAllHistoryAvailable
 * first
 */
export type getSuitableDiscussionChats = {
  readonly _: 'getSuitableDiscussionChats',
}

/**
 * Returns a list of recently inactive supergroups and channels. Can be used when user
 * reaches limit on the number of joined supergroups and channels and receives CHANNELS_TOO_MUCH
 * error
 */
export type getInactiveSupergroupChats = {
  readonly _: 'getInactiveSupergroupChats',
}

/**
 * Returns a list of common group chats with a given user. Chats are sorted by their
 * type and creation date
 */
export type getGroupsInCommon = {
  readonly _: 'getGroupsInCommon',
  /** User identifier */
  readonly user_id?: number,
  /** Chat identifier starting from which to return chats; use 0 for the first request */
  readonly offset_chat_id?: number,
  /** The maximum number of chats to be returned; up to 100 */
  readonly limit?: number,
}

/**
 * Returns messages in a chat. The messages are returned in a reverse chronological
 * order (i.e., in order of decreasing message_id). For optimal performance, the number
 * of returned messages is chosen by TDLib. This is an offline request if only_local
 * is true
 */
export type getChatHistory = {
  readonly _: 'getChatHistory',
  /** Chat identifier */
  readonly chat_id?: number,
  /**
   * Identifier of the message starting from which history must be fetched; use 0 to get
   * results from the last message
   */
  readonly from_message_id?: number,
  /**
   * Specify 0 to get results from exactly the from_message_id or a negative offset up
   * to 99 to get additionally some newer messages
   */
  readonly offset?: number,
  /**
   * The maximum number of messages to be returned; must be positive and can't be greater
   * than 100. If the offset is negative, the limit must be greater than or equal to -offset.
   * For optimal performance, the number of returned messages is chosen by TDLib and can
   * be smaller than the specified limit
   */
  readonly limit?: number,
  /**
   * If true, returns only messages that are available locally without sending network
   * requests
   */
  readonly only_local?: boolean,
}

/**
 * Returns messages in a message thread of a message. Can be used only if message.can_get_message_thread
 * == true. Message thread of a channel message is in the channel's linked supergroup.
 * The messages are returned in a reverse chronological order (i.e., in order of decreasing
 * message_id). For optimal performance, the number of returned messages is chosen by
 * TDLib
 */
export type getMessageThreadHistory = {
  readonly _: 'getMessageThreadHistory',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Message identifier, which thread history needs to be returned */
  readonly message_id?: number,
  /**
   * Identifier of the message starting from which history must be fetched; use 0 to get
   * results from the last message
   */
  readonly from_message_id?: number,
  /**
   * Specify 0 to get results from exactly the from_message_id or a negative offset up
   * to 99 to get additionally some newer messages
   */
  readonly offset?: number,
  /**
   * The maximum number of messages to be returned; must be positive and can't be greater
   * than 100. If the offset is negative, the limit must be greater than or equal to -offset.
   * For optimal performance, the number of returned messages is chosen by TDLib and can
   * be smaller than the specified limit
   */
  readonly limit?: number,
}

/**
 * Deletes all messages in the chat. Use chat.can_be_deleted_only_for_self and chat.can_be_deleted_for_all_users
 * fields to find whether and how the method can be applied to the chat
 */
export type deleteChatHistory = {
  readonly _: 'deleteChatHistory',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Pass true if the chat needs to be removed from the chat list */
  readonly remove_from_chat_list?: boolean,
  /** Pass true to delete chat history for all users */
  readonly revoke?: boolean,
}

/**
 * Deletes a chat along with all messages in the corresponding chat for all chat members;
 * requires owner privileges. For group chats this will release the username and remove
 * all members. Chats with more than 1000 members can't be deleted using this method
 */
export type deleteChat = {
  readonly _: 'deleteChat',
  /** Chat identifier */
  readonly chat_id?: number,
}

/**
 * Searches for messages with given words in the chat. Returns the results in reverse
 * chronological order, i.e. in order of decreasing message_id. Cannot be used in secret
 * chats with a non-empty query (searchSecretMessages must be used instead), or without
 * an enabled message database. For optimal performance, the number of returned messages
 * is chosen by TDLib and can be smaller than the specified limit
 */
export type searchChatMessages = {
  readonly _: 'searchChatMessages',
  /** Identifier of the chat in which to search messages */
  readonly chat_id?: number,
  /** Query to search for */
  readonly query?: string,
  /**
   * Identifier of the sender of messages to search for; pass null to search for messages
   * from any sender. Not supported in secret chats
   */
  readonly sender_id?: MessageSender$Input,
  /**
   * Identifier of the message starting from which history must be fetched; use 0 to get
   * results from the last message
   */
  readonly from_message_id?: number,
  /**
   * Specify 0 to get results from exactly the from_message_id or a negative offset to
   * get the specified message and some newer messages
   */
  readonly offset?: number,
  /**
   * The maximum number of messages to be returned; must be positive and can't be greater
   * than 100. If the offset is negative, the limit must be greater than -offset. For
   * optimal performance, the number of returned messages is chosen by TDLib and can be
   * smaller than the specified limit
   */
  readonly limit?: number,
  /** Additional filter for messages to search; pass null to search for all messages */
  readonly filter?: SearchMessagesFilter$Input,
  /** If not 0, only messages in the specified thread will be returned; supergroups only */
  readonly message_thread_id?: number,
}

/**
 * Searches for messages in all chats except secret chats. Returns the results in reverse
 * chronological order (i.e., in order of decreasing (date, chat_id, message_id)). For
 * optimal performance, the number of returned messages is chosen by TDLib and can be
 * smaller than the specified limit
 */
export type searchMessages = {
  readonly _: 'searchMessages',
  /**
   * Chat list in which to search messages; pass null to search in all chats regardless
   * of their chat list. Only Main and Archive chat lists are supported
   */
  readonly chat_list?: ChatList$Input,
  /** Query to search for */
  readonly query?: string,
  /**
   * The date of the message starting from which the results need to be fetched. Use 0
   * or any date in the future to get results from the last message
   */
  readonly offset_date?: number,
  /** The chat identifier of the last found message, or 0 for the first request */
  readonly offset_chat_id?: number,
  /** The message identifier of the last found message, or 0 for the first request */
  readonly offset_message_id?: number,
  /**
   * The maximum number of messages to be returned; up to 100. For optimal performance,
   * the number of returned messages is chosen by TDLib and can be smaller than the specified
   * limit
   */
  readonly limit?: number,
  /**
   * Additional filter for messages to search; pass null to search for all messages. Filters
   * searchMessagesFilterMention, searchMessagesFilterUnreadMention, searchMessagesFilterFailedToSend
   * and searchMessagesFilterPinned are unsupported in this function
   */
  readonly filter?: SearchMessagesFilter$Input,
  /** If not 0, the minimum date of the messages to return */
  readonly min_date?: number,
  /** If not 0, the maximum date of the messages to return */
  readonly max_date?: number,
}

/**
 * Searches for messages in secret chats. Returns the results in reverse chronological
 * order. For optimal performance, the number of returned messages is chosen by TDLib
 */
export type searchSecretMessages = {
  readonly _: 'searchSecretMessages',
  /** Identifier of the chat in which to search. Specify 0 to search in all secret chats */
  readonly chat_id?: number,
  /** Query to search for. If empty, searchChatMessages must be used instead */
  readonly query?: string,
  /**
   * Offset of the first entry to return as received from the previous request; use empty
   * string to get first chunk of results
   */
  readonly offset?: string,
  /**
   * The maximum number of messages to be returned; up to 100. For optimal performance,
   * the number of returned messages is chosen by TDLib and can be smaller than the specified
   * limit
   */
  readonly limit?: number,
  /** Additional filter for messages to search; pass null to search for all messages */
  readonly filter?: SearchMessagesFilter$Input,
}

/**
 * Searches for call messages. Returns the results in reverse chronological order (i.
 * e., in order of decreasing message_id). For optimal performance, the number of returned
 * messages is chosen by TDLib
 */
export type searchCallMessages = {
  readonly _: 'searchCallMessages',
  /**
   * Identifier of the message from which to search; use 0 to get results from the last
   * message
   */
  readonly from_message_id?: number,
  /**
   * The maximum number of messages to be returned; up to 100. For optimal performance,
   * the number of returned messages is chosen by TDLib and can be smaller than the specified
   * limit
   */
  readonly limit?: number,
  /** If true, returns only messages with missed/declined calls */
  readonly only_missed?: boolean,
}

/** Deletes all call messages */
export type deleteAllCallMessages = {
  readonly _: 'deleteAllCallMessages',
  /** Pass true to delete the messages for all users */
  readonly revoke?: boolean,
}

/**
 * Returns information about the recent locations of chat members that were sent to
 * the chat. Returns up to 1 location message per user
 */
export type searchChatRecentLocationMessages = {
  readonly _: 'searchChatRecentLocationMessages',
  /** Chat identifier */
  readonly chat_id?: number,
  /** The maximum number of messages to be returned */
  readonly limit?: number,
}

/**
 * Returns all active live locations that need to be updated by the application. The
 * list is persistent across application restarts only if the message database is used
 */
export type getActiveLiveLocationMessages = {
  readonly _: 'getActiveLiveLocationMessages',
}

/** Returns the last message sent in a chat no later than the specified date */
export type getChatMessageByDate = {
  readonly _: 'getChatMessageByDate',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Point in time (Unix timestamp) relative to which to search for messages */
  readonly date?: number,
}

/**
 * Returns sparse positions of messages of the specified type in the chat to be used
 * for shared media scroll implementation. Returns the results in reverse chronological
 * order (i.e., in order of decreasing message_id). Cannot be used in secret chats or
 * with searchMessagesFilterFailedToSend filter without an enabled message database
 */
export type getChatSparseMessagePositions = {
  readonly _: 'getChatSparseMessagePositions',
  /** Identifier of the chat in which to return information about message positions */
  readonly chat_id?: number,
  /**
   * Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterMention
   * and searchMessagesFilterUnreadMention are unsupported in this function
   */
  readonly filter?: SearchMessagesFilter$Input,
  /** The message identifier from which to return information about message positions */
  readonly from_message_id?: number,
  /**
   * The expected number of message positions to be returned; 50-2000. A smaller number
   * of positions can be returned, if there are not enough appropriate messages
   */
  readonly limit?: number,
}

/**
 * Returns information about the next messages of the specified type in the chat split
 * by days. Returns the results in reverse chronological order. Can return partial result
 * for the last returned day. Behavior of this method depends on the value of the option
 * "utc_time_offset"
 */
export type getChatMessageCalendar = {
  readonly _: 'getChatMessageCalendar',
  /** Identifier of the chat in which to return information about messages */
  readonly chat_id?: number,
  /**
   * Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterMention
   * and searchMessagesFilterUnreadMention are unsupported in this function
   */
  readonly filter?: SearchMessagesFilter$Input,
  /**
   * The message identifier from which to return information about messages; use 0 to
   * get results from the last message
   */
  readonly from_message_id?: number,
}

/** Returns approximate number of messages of the specified type in the chat */
export type getChatMessageCount = {
  readonly _: 'getChatMessageCount',
  /** Identifier of the chat in which to count messages */
  readonly chat_id?: number,
  /** Filter for message content; searchMessagesFilterEmpty is unsupported in this function */
  readonly filter?: SearchMessagesFilter$Input,
  /**
   * If true, returns count that is available locally without sending network requests,
   * returning -1 if the number of messages is unknown
   */
  readonly return_local?: boolean,
}

/**
 * Returns all scheduled messages in a chat. The messages are returned in a reverse
 * chronological order (i.e., in order of decreasing message_id)
 */
export type getChatScheduledMessages = {
  readonly _: 'getChatScheduledMessages',
  /** Chat identifier */
  readonly chat_id?: number,
}

/**
 * Returns forwarded copies of a channel message to different public channels. For optimal
 * performance, the number of returned messages is chosen by TDLib
 */
export type getMessagePublicForwards = {
  readonly _: 'getMessagePublicForwards',
  /** Chat identifier of the message */
  readonly chat_id?: number,
  /** Message identifier */
  readonly message_id?: number,
  /**
   * Offset of the first entry to return as received from the previous request; use empty
   * string to get first chunk of results
   */
  readonly offset?: string,
  /**
   * The maximum number of messages to be returned; must be positive and can't be greater
   * than 100. For optimal performance, the number of returned messages is chosen by TDLib
   * and can be smaller than the specified limit
   */
  readonly limit?: number,
}

/**
 * Returns sponsored message to be shown in a chat; for channel chats only. Returns
 * a 404 error if there is no sponsored message in the chat
 */
export type getChatSponsoredMessage = {
  readonly _: 'getChatSponsoredMessage',
  /** Identifier of the chat */
  readonly chat_id?: number,
}

/**
 * Removes an active notification from notification list. Needs to be called only if
 * the notification is removed by the current user
 */
export type removeNotification = {
  readonly _: 'removeNotification',
  /** Identifier of notification group to which the notification belongs */
  readonly notification_group_id?: number,
  /** Identifier of removed notification */
  readonly notification_id?: number,
}

/**
 * Removes a group of active notifications. Needs to be called only if the notification
 * group is removed by the current user
 */
export type removeNotificationGroup = {
  readonly _: 'removeNotificationGroup',
  /** Notification group identifier */
  readonly notification_group_id?: number,
  /** The maximum identifier of removed notifications */
  readonly max_notification_id?: number,
}

/**
 * Returns an HTTPS link to a message in a chat. Available only for already sent messages
 * in supergroups and channels, or if message.can_get_media_timestamp_links and a media
 * timestamp link is generated. This is an offline request
 */
export type getMessageLink = {
  readonly _: 'getMessageLink',
  /** Identifier of the chat to which the message belongs */
  readonly chat_id?: number,
  /** Identifier of the message */
  readonly message_id?: number,
  /**
   * If not 0, timestamp from which the video/audio/video note/voice note playing must
   * start, in seconds. The media can be in the message content or in its web page preview
   */
  readonly media_timestamp?: number,
  /** Pass true to create a link for the whole media album */
  readonly for_album?: boolean,
  /**
   * Pass true to create a link to the message as a channel post comment, or from a message
   * thread
   */
  readonly for_comment?: boolean,
}

/**
 * Returns an HTML code for embedding the message. Available only for messages in supergroups
 * and channels with a username
 */
export type getMessageEmbeddingCode = {
  readonly _: 'getMessageEmbeddingCode',
  /** Identifier of the chat to which the message belongs */
  readonly chat_id?: number,
  /** Identifier of the message */
  readonly message_id?: number,
  /** Pass true to return an HTML code for embedding of the whole media album */
  readonly for_album?: boolean,
}

/**
 * Returns information about a public or private message link. Can be called for any
 * internal link of the type internalLinkTypeMessage
 */
export type getMessageLinkInfo = {
  readonly _: 'getMessageLinkInfo',
  /** The message link */
  readonly url?: string,
}

/**
 * Returns list of message sender identifiers, which can be used to send messages in
 * a chat
 */
export type getChatAvailableMessageSenders = {
  readonly _: 'getChatAvailableMessageSenders',
  /** Chat identifier */
  readonly chat_id?: number,
}

/** Selects a message sender to send messages in a chat */
export type setChatMessageSender = {
  readonly _: 'setChatMessageSender',
  /** Chat identifier */
  readonly chat_id?: number,
  /** New message sender for the chat */
  readonly message_sender_id?: MessageSender$Input,
}

/** Sends a message. Returns the sent message */
export type sendMessage = {
  readonly _: 'sendMessage',
  /** Target chat */
  readonly chat_id?: number,
  /** If not 0, a message thread identifier in which the message will be sent */
  readonly message_thread_id?: number,
  /** Identifier of the message to reply to or 0 */
  readonly reply_to_message_id?: number,
  /** Options to be used to send the message; pass null to use default options */
  readonly options?: messageSendOptions$Input,
  /** Markup for replying to the message; pass null if none; for bots only */
  readonly reply_markup?: ReplyMarkup$Input,
  /** The content of the message to be sent */
  readonly input_message_content?: InputMessageContent$Input,
}

/**
 * Sends 2-10 messages grouped together into an album. Currently, only audio, document,
 * photo and video messages can be grouped into an album. Documents and audio files
 * can be only grouped in an album with messages of the same type. Returns sent messages
 */
export type sendMessageAlbum = {
  readonly _: 'sendMessageAlbum',
  /** Target chat */
  readonly chat_id?: number,
  /** If not 0, a message thread identifier in which the messages will be sent */
  readonly message_thread_id?: number,
  /** Identifier of a message to reply to or 0 */
  readonly reply_to_message_id?: number,
  /** Options to be used to send the messages; pass null to use default options */
  readonly options?: messageSendOptions$Input,
  /** Contents of messages to be sent. At most 10 messages can be added to an album */
  readonly input_message_contents?: ReadonlyArray<InputMessageContent$Input>,
}

/**
 * Invites a bot to a chat (if it is not yet a member) and sends it the /start command.
 * Bots can't be invited to a private chat other than the chat with the bot. Bots can't
 * be invited to channels (although they can be added as admins) and secret chats. Returns
 * the sent message
 */
export type sendBotStartMessage = {
  readonly _: 'sendBotStartMessage',
  /** Identifier of the bot */
  readonly bot_user_id?: number,
  /** Identifier of the target chat */
  readonly chat_id?: number,
  /** A hidden parameter sent to the bot for deep linking purposes (https://core.telegram.org/bots#deep-linking) */
  readonly parameter?: string,
}

/**
 * Sends the result of an inline query as a message. Returns the sent message. Always
 * clears a chat draft message
 */
export type sendInlineQueryResultMessage = {
  readonly _: 'sendInlineQueryResultMessage',
  /** Target chat */
  readonly chat_id?: number,
  /** If not 0, a message thread identifier in which the message will be sent */
  readonly message_thread_id?: number,
  /** Identifier of a message to reply to or 0 */
  readonly reply_to_message_id?: number,
  /** Options to be used to send the message; pass null to use default options */
  readonly options?: messageSendOptions$Input,
  /** Identifier of the inline query */
  readonly query_id?: number | string,
  /** Identifier of the inline result */
  readonly result_id?: string,
  /**
   * If true, there will be no mention of a bot, via which the message is sent. Can be
   * used only for bots GetOption("animation_search_bot_username"), GetOption("photo_search_bot_username")
   * and GetOption("venue_search_bot_username")
   */
  readonly hide_via_bot?: boolean,
}

/**
 * Forwards previously sent messages. Returns the forwarded messages in the same order
 * as the message identifiers passed in message_ids. If a message can't be forwarded,
 * null will be returned instead of the message
 */
export type forwardMessages = {
  readonly _: 'forwardMessages',
  /** Identifier of the chat to which to forward messages */
  readonly chat_id?: number,
  /** Identifier of the chat from which to forward messages */
  readonly from_chat_id?: number,
  /**
   * Identifiers of the messages to forward. Message identifiers must be in a strictly
   * increasing order. At most 100 messages can be forwarded simultaneously
   */
  readonly message_ids?: ReadonlyArray<number>,
  /** Options to be used to send the messages; pass null to use default options */
  readonly options?: messageSendOptions$Input,
  /**
   * If true, content of the messages will be copied without reference to the original
   * sender. Always true if the messages are forwarded to a secret chat or are local
   */
  readonly send_copy?: boolean,
  /**
   * If true, media caption of message copies will be removed. Ignored if send_copy is
   * false
   */
  readonly remove_caption?: boolean,
  /** If true, messages will not be forwarded and instead fake messages will be returned */
  readonly only_preview?: boolean,
}

/**
 * Resends messages which failed to send. Can be called only for messages for which
 * messageSendingStateFailed.can_retry is true and after specified in messageSendingStateFailed.retry_after
 * time passed. If a message is re-sent, the corresponding failed to send message is
 * deleted. Returns the sent messages in the same order as the message identifiers passed
 * in message_ids. If a message can't be re-sent, null will be returned instead of the
 * message
 */
export type resendMessages = {
  readonly _: 'resendMessages',
  /** Identifier of the chat to send messages */
  readonly chat_id?: number,
  /**
   * Identifiers of the messages to resend. Message identifiers must be in a strictly
   * increasing order
   */
  readonly message_ids?: ReadonlyArray<number>,
}

/**
 * Sends a notification about a screenshot taken in a chat. Supported only in private
 * and secret chats
 */
export type sendChatScreenshotTakenNotification = {
  readonly _: 'sendChatScreenshotTakenNotification',
  /** Chat identifier */
  readonly chat_id?: number,
}

/**
 * Adds a local message to a chat. The message is persistent across application restarts
 * only if the message database is used. Returns the added message
 */
export type addLocalMessage = {
  readonly _: 'addLocalMessage',
  /** Target chat */
  readonly chat_id?: number,
  /** Identifier of the sender of the message */
  readonly sender_id?: MessageSender$Input,
  /** Identifier of the message to reply to or 0 */
  readonly reply_to_message_id?: number,
  /** Pass true to disable notification for the message */
  readonly disable_notification?: boolean,
  /** The content of the message to be added */
  readonly input_message_content?: InputMessageContent$Input,
}

/** Deletes messages */
export type deleteMessages = {
  readonly _: 'deleteMessages',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Identifiers of the messages to be deleted */
  readonly message_ids?: ReadonlyArray<number>,
  /**
   * Pass true to delete messages for all chat members. Always true for supergroups, channels
   * and secret chats
   */
  readonly revoke?: boolean,
}

/**
 * Deletes all messages sent by the specified message sender in a chat. Supported only
 * for supergroups; requires can_delete_messages administrator privileges
 */
export type deleteChatMessagesBySender = {
  readonly _: 'deleteChatMessagesBySender',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Identifier of the sender of messages to delete */
  readonly sender_id?: MessageSender$Input,
}

/**
 * Deletes all messages between the specified dates in a chat. Supported only for private
 * chats and basic groups. Messages sent in the last 30 seconds will not be deleted
 */
export type deleteChatMessagesByDate = {
  readonly _: 'deleteChatMessagesByDate',
  /** Chat identifier */
  readonly chat_id?: number,
  /** The minimum date of the messages to delete */
  readonly min_date?: number,
  /** The maximum date of the messages to delete */
  readonly max_date?: number,
  /** Pass true to delete chat messages for all users; private chats only */
  readonly revoke?: boolean,
}

/**
 * Edits the text of a message (or a text of a game message). Returns the edited message
 * after the edit is completed on the server side
 */
export type editMessageText = {
  readonly _: 'editMessageText',
  /** The chat the message belongs to */
  readonly chat_id?: number,
  /** Identifier of the message */
  readonly message_id?: number,
  /** The new message reply markup; pass null if none; for bots only */
  readonly reply_markup?: ReplyMarkup$Input,
  /** New text content of the message. Must be of type inputMessageText */
  readonly input_message_content?: InputMessageContent$Input,
}

/**
 * Edits the message content of a live location. Messages can be edited for a limited
 * period of time specified in the live location. Returns the edited message after the
 * edit is completed on the server side
 */
export type editMessageLiveLocation = {
  readonly _: 'editMessageLiveLocation',
  /** The chat the message belongs to */
  readonly chat_id?: number,
  /** Identifier of the message */
  readonly message_id?: number,
  /** The new message reply markup; pass null if none; for bots only */
  readonly reply_markup?: ReplyMarkup$Input,
  /** New location content of the message; pass null to stop sharing the live location */
  readonly location?: location$Input,
  /** The new direction in which the location moves, in degrees; 1-360. Pass 0 if unknown */
  readonly heading?: number,
  /**
   * The new maximum distance for proximity alerts, in meters (0-100000). Pass 0 if the
   * notification is disabled
   */
  readonly proximity_alert_radius?: number,
}

/**
 * Edits the content of a message with an animation, an audio, a document, a photo or
 * a video, including message caption. If only the caption needs to be edited, use editMessageCaption
 * instead. The media can't be edited if the message was set to self-destruct or to
 * a self-destructing media. The type of message content in an album can't be changed
 * with exception of replacing a photo with a video or vice versa. Returns the edited
 * message after the edit is completed on the server side
 */
export type editMessageMedia = {
  readonly _: 'editMessageMedia',
  /** The chat the message belongs to */
  readonly chat_id?: number,
  /** Identifier of the message */
  readonly message_id?: number,
  /** The new message reply markup; pass null if none; for bots only */
  readonly reply_markup?: ReplyMarkup$Input,
  /**
   * New content of the message. Must be one of the following types: inputMessageAnimation,
   * inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
   */
  readonly input_message_content?: InputMessageContent$Input,
}

/**
 * Edits the message content caption. Returns the edited message after the edit is completed
 * on the server side
 */
export type editMessageCaption = {
  readonly _: 'editMessageCaption',
  /** The chat the message belongs to */
  readonly chat_id?: number,
  /** Identifier of the message */
  readonly message_id?: number,
  /** The new message reply markup; pass null if none; for bots only */
  readonly reply_markup?: ReplyMarkup$Input,
  /**
   * New message content caption; 0-GetOption("message_caption_length_max") characters;
   * pass null to remove caption
   */
  readonly caption?: formattedText$Input,
}

/**
 * Edits the message reply markup; for bots only. Returns the edited message after the
 * edit is completed on the server side
 */
export type editMessageReplyMarkup = {
  readonly _: 'editMessageReplyMarkup',
  /** The chat the message belongs to */
  readonly chat_id?: number,
  /** Identifier of the message */
  readonly message_id?: number,
  /** The new message reply markup; pass null if none */
  readonly reply_markup?: ReplyMarkup$Input,
}

/** Edits the text of an inline text or game message sent via a bot; for bots only */
export type editInlineMessageText = {
  readonly _: 'editInlineMessageText',
  /** Inline message identifier */
  readonly inline_message_id?: string,
  /** The new message reply markup; pass null if none */
  readonly reply_markup?: ReplyMarkup$Input,
  /** New text content of the message. Must be of type inputMessageText */
  readonly input_message_content?: InputMessageContent$Input,
}

/**
 * Edits the content of a live location in an inline message sent via a bot; for bots
 * only
 */
export type editInlineMessageLiveLocation = {
  readonly _: 'editInlineMessageLiveLocation',
  /** Inline message identifier */
  readonly inline_message_id?: string,
  /** The new message reply markup; pass null if none */
  readonly reply_markup?: ReplyMarkup$Input,
  /** New location content of the message; pass null to stop sharing the live location */
  readonly location?: location$Input,
  /** The new direction in which the location moves, in degrees; 1-360. Pass 0 if unknown */
  readonly heading?: number,
  /**
   * The new maximum distance for proximity alerts, in meters (0-100000). Pass 0 if the
   * notification is disabled
   */
  readonly proximity_alert_radius?: number,
}

/**
 * Edits the content of a message with an animation, an audio, a document, a photo or
 * a video in an inline message sent via a bot; for bots only
 */
export type editInlineMessageMedia = {
  readonly _: 'editInlineMessageMedia',
  /** Inline message identifier */
  readonly inline_message_id?: string,
  /** The new message reply markup; pass null if none; for bots only */
  readonly reply_markup?: ReplyMarkup$Input,
  /**
   * New content of the message. Must be one of the following types: inputMessageAnimation,
   * inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
   */
  readonly input_message_content?: InputMessageContent$Input,
}

/** Edits the caption of an inline message sent via a bot; for bots only */
export type editInlineMessageCaption = {
  readonly _: 'editInlineMessageCaption',
  /** Inline message identifier */
  readonly inline_message_id?: string,
  /** The new message reply markup; pass null if none */
  readonly reply_markup?: ReplyMarkup$Input,
  /**
   * New message content caption; pass null to remove caption; 0-GetOption("message_caption_length_max")
   * characters
   */
  readonly caption?: formattedText$Input,
}

/** Edits the reply markup of an inline message sent via a bot; for bots only */
export type editInlineMessageReplyMarkup = {
  readonly _: 'editInlineMessageReplyMarkup',
  /** Inline message identifier */
  readonly inline_message_id?: string,
  /** The new message reply markup; pass null if none */
  readonly reply_markup?: ReplyMarkup$Input,
}

/**
 * Edits the time when a scheduled message will be sent. Scheduling state of all messages
 * in the same album or forwarded together with the message will be also changed
 */
export type editMessageSchedulingState = {
  readonly _: 'editMessageSchedulingState',
  /** The chat the message belongs to */
  readonly chat_id?: number,
  /** Identifier of the message */
  readonly message_id?: number,
  /** The new message scheduling state; pass null to send the message immediately */
  readonly scheduling_state?: MessageSchedulingState$Input,
}

/**
 * Returns all entities (mentions, hashtags, cashtags, bot commands, bank card numbers,
 * URLs, and email addresses) contained in the text. Can be called synchronously
 */
export type getTextEntities = {
  readonly _: 'getTextEntities',
  /** The text in which to look for entites */
  readonly text?: string,
}

/**
 * Parses Bold, Italic, Underline, Strikethrough, Code, Pre, PreCode, TextUrl and MentionName
 * entities contained in the text. Can be called synchronously
 */
export type parseTextEntities = {
  readonly _: 'parseTextEntities',
  /** The text to parse */
  readonly text?: string,
  /** Text parse mode */
  readonly parse_mode?: TextParseMode$Input,
}

/**
 * Parses Markdown entities in a human-friendly format, ignoring markup errors. Can
 * be called synchronously
 */
export type parseMarkdown = {
  readonly _: 'parseMarkdown',
  /**
   * The text to parse. For example, "__italic__ ~~strikethrough~~ **bold** `code` ```pre```
   * __[italic__ text_url](telegram.org) __italic**bold italic__bold**"
   */
  readonly text?: formattedText$Input,
}

/**
 * Replaces text entities with Markdown formatting in a human-friendly format. Entities
 * that can't be represented in Markdown unambiguously are kept as is. Can be called
 * synchronously
 */
export type getMarkdownText = {
  readonly _: 'getMarkdownText',
  /** The text */
  readonly text?: formattedText$Input,
}

/**
 * Returns the MIME type of a file, guessed by its extension. Returns an empty string
 * on failure. Can be called synchronously
 */
export type getFileMimeType = {
  readonly _: 'getFileMimeType',
  /** The name of the file or path to the file */
  readonly file_name?: string,
}

/**
 * Returns the extension of a file, guessed by its MIME type. Returns an empty string
 * on failure. Can be called synchronously
 */
export type getFileExtension = {
  readonly _: 'getFileExtension',
  /** The MIME type of the file */
  readonly mime_type?: string,
}

/**
 * Removes potentially dangerous characters from the name of a file. The encoding of
 * the file name is supposed to be UTF-8. Returns an empty string on failure. Can be
 * called synchronously
 */
export type cleanFileName = {
  readonly _: 'cleanFileName',
  /** File name or path to the file */
  readonly file_name?: string,
}

/**
 * Returns a string stored in the local database from the specified localization target
 * and language pack by its key. Returns a 404 error if the string is not found. Can
 * be called synchronously
 */
export type getLanguagePackString = {
  readonly _: 'getLanguagePackString',
  /** Path to the language pack database in which strings are stored */
  readonly language_pack_database_path?: string,
  /** Localization target to which the language pack belongs */
  readonly localization_target?: string,
  /** Language pack identifier */
  readonly language_pack_id?: string,
  /** Language pack key of the string to be returned */
  readonly key?: string,
}

/**
 * Converts a JSON-serialized string to corresponding JsonValue object. Can be called
 * synchronously
 */
export type getJsonValue = {
  readonly _: 'getJsonValue',
  /** The JSON-serialized string */
  readonly json?: string,
}

/**
 * Converts a JsonValue object to corresponding JSON-serialized string. Can be called
 * synchronously
 */
export type getJsonString = {
  readonly _: 'getJsonString',
  /** The JsonValue object */
  readonly json_value?: JsonValue$Input,
}

/** Changes the user answer to a poll. A poll in quiz mode can be answered only once */
export type setPollAnswer = {
  readonly _: 'setPollAnswer',
  /** Identifier of the chat to which the poll belongs */
  readonly chat_id?: number,
  /** Identifier of the message containing the poll */
  readonly message_id?: number,
  /**
   * 0-based identifiers of answer options, chosen by the user. User can choose more than
   * 1 answer option only is the poll allows multiple answers
   */
  readonly option_ids?: ReadonlyArray<number>,
}

/**
 * Returns users voted for the specified option in a non-anonymous polls. For optimal
 * performance, the number of returned users is chosen by TDLib
 */
export type getPollVoters = {
  readonly _: 'getPollVoters',
  /** Identifier of the chat to which the poll belongs */
  readonly chat_id?: number,
  /** Identifier of the message containing the poll */
  readonly message_id?: number,
  /** 0-based identifier of the answer option */
  readonly option_id?: number,
  /** Number of users to skip in the result; must be non-negative */
  readonly offset?: number,
  /**
   * The maximum number of users to be returned; must be positive and can't be greater
   * than 50. For optimal performance, the number of returned users is chosen by TDLib
   * and can be smaller than the specified limit, even if the end of the voter list has
   * not been reached
   */
  readonly limit?: number,
}

/**
 * Stops a poll. A poll in a message can be stopped when the message has can_be_edited
 * flag set
 */
export type stopPoll = {
  readonly _: 'stopPoll',
  /** Identifier of the chat to which the poll belongs */
  readonly chat_id?: number,
  /** Identifier of the message containing the poll */
  readonly message_id?: number,
  /** The new message reply markup; pass null if none; for bots only */
  readonly reply_markup?: ReplyMarkup$Input,
}

/** Hides a suggested action */
export type hideSuggestedAction = {
  readonly _: 'hideSuggestedAction',
  /** Suggested action to hide */
  readonly action?: SuggestedAction$Input,
}

/**
 * Returns information about a button of type inlineKeyboardButtonTypeLoginUrl. The
 * method needs to be called when the user presses the button
 */
export type getLoginUrlInfo = {
  readonly _: 'getLoginUrlInfo',
  /** Chat identifier of the message with the button */
  readonly chat_id?: number,
  /** Message identifier of the message with the button */
  readonly message_id?: number,
  /** Button identifier */
  readonly button_id?: number,
}

/**
 * Returns an HTTP URL which can be used to automatically authorize the user on a website
 * after clicking an inline button of type inlineKeyboardButtonTypeLoginUrl. Use the
 * method getLoginUrlInfo to find whether a prior user confirmation is needed. If an
 * error is returned, then the button must be handled as an ordinary URL button
 */
export type getLoginUrl = {
  readonly _: 'getLoginUrl',
  /** Chat identifier of the message with the button */
  readonly chat_id?: number,
  /** Message identifier of the message with the button */
  readonly message_id?: number,
  /** Button identifier */
  readonly button_id?: number,
  /** True, if the user allowed the bot to send them messages */
  readonly allow_write_access?: boolean,
}

/**
 * Sends an inline query to a bot and returns its results. Returns an error with code
 * 502 if the bot fails to answer the query before the query timeout expires
 */
export type getInlineQueryResults = {
  readonly _: 'getInlineQueryResults',
  /** The identifier of the target bot */
  readonly bot_user_id?: number,
  /** Identifier of the chat where the query was sent */
  readonly chat_id?: number,
  /** Location of the user; pass null if unknown or the bot doesn't need user's location */
  readonly user_location?: location$Input,
  /** Text of the query */
  readonly query?: string,
  /** Offset of the first entry to return */
  readonly offset?: string,
}

/** Sets the result of an inline query; for bots only */
export type answerInlineQuery = {
  readonly _: 'answerInlineQuery',
  /** Identifier of the inline query */
  readonly inline_query_id?: number | string,
  /** True, if the result of the query can be cached for the specified user */
  readonly is_personal?: boolean,
  /** The results of the query */
  readonly results?: ReadonlyArray<InputInlineQueryResult$Input>,
  /** Allowed time to cache the results of the query, in seconds */
  readonly cache_time?: number,
  /** Offset for the next inline query; pass an empty string if there are no more results */
  readonly next_offset?: string,
  /**
   * If non-empty, this text must be shown on the button that opens a private chat with
   * the bot and sends a start message to the bot with the parameter switch_pm_parameter
   */
  readonly switch_pm_text?: string,
  /** The parameter for the bot start message */
  readonly switch_pm_parameter?: string,
}

/**
 * Sends a callback query to a bot and returns an answer. Returns an error with code
 * 502 if the bot fails to answer the query before the query timeout expires
 */
export type getCallbackQueryAnswer = {
  readonly _: 'getCallbackQueryAnswer',
  /** Identifier of the chat with the message */
  readonly chat_id?: number,
  /** Identifier of the message from which the query originated */
  readonly message_id?: number,
  /** Query payload */
  readonly payload?: CallbackQueryPayload$Input,
}

/** Sets the result of a callback query; for bots only */
export type answerCallbackQuery = {
  readonly _: 'answerCallbackQuery',
  /** Identifier of the callback query */
  readonly callback_query_id?: number | string,
  /** Text of the answer */
  readonly text?: string,
  /** If true, an alert must be shown to the user instead of a toast notification */
  readonly show_alert?: boolean,
  /** URL to be opened */
  readonly url?: string,
  /** Time during which the result of the query can be cached, in seconds */
  readonly cache_time?: number,
}

/** Sets the result of a shipping query; for bots only */
export type answerShippingQuery = {
  readonly _: 'answerShippingQuery',
  /** Identifier of the shipping query */
  readonly shipping_query_id?: number | string,
  /** Available shipping options */
  readonly shipping_options?: ReadonlyArray<shippingOption$Input>,
  /** An error message, empty on success */
  readonly error_message?: string,
}

/** Sets the result of a pre-checkout query; for bots only */
export type answerPreCheckoutQuery = {
  readonly _: 'answerPreCheckoutQuery',
  /** Identifier of the pre-checkout query */
  readonly pre_checkout_query_id?: number | string,
  /** An error message, empty on success */
  readonly error_message?: string,
}

/** Updates the game score of the specified user in the game; for bots only */
export type setGameScore = {
  readonly _: 'setGameScore',
  /** The chat to which the message with the game belongs */
  readonly chat_id?: number,
  /** Identifier of the message */
  readonly message_id?: number,
  /** True, if the message needs to be edited */
  readonly edit_message?: boolean,
  /** User identifier */
  readonly user_id?: number,
  /** The new score */
  readonly score?: number,
  /**
   * Pass true to update the score even if it decreases. If the score is 0, the user will
   * be deleted from the high score table
   */
  readonly force?: boolean,
}

/** Updates the game score of the specified user in a game; for bots only */
export type setInlineGameScore = {
  readonly _: 'setInlineGameScore',
  /** Inline message identifier */
  readonly inline_message_id?: string,
  /** True, if the message needs to be edited */
  readonly edit_message?: boolean,
  /** User identifier */
  readonly user_id?: number,
  /** The new score */
  readonly score?: number,
  /**
   * Pass true to update the score even if it decreases. If the score is 0, the user will
   * be deleted from the high score table
   */
  readonly force?: boolean,
}

/**
 * Returns the high scores for a game and some part of the high score table in the range
 * of the specified user; for bots only
 */
export type getGameHighScores = {
  readonly _: 'getGameHighScores',
  /** The chat that contains the message with the game */
  readonly chat_id?: number,
  /** Identifier of the message */
  readonly message_id?: number,
  /** User identifier */
  readonly user_id?: number,
}

/**
 * Returns game high scores and some part of the high score table in the range of the
 * specified user; for bots only
 */
export type getInlineGameHighScores = {
  readonly _: 'getInlineGameHighScores',
  /** Inline message identifier */
  readonly inline_message_id?: string,
  /** User identifier */
  readonly user_id?: number,
}

/**
 * Deletes the default reply markup from a chat. Must be called after a one-time keyboard
 * or a ForceReply reply markup has been used. UpdateChatReplyMarkup will be sent if
 * the reply markup is changed
 */
export type deleteChatReplyMarkup = {
  readonly _: 'deleteChatReplyMarkup',
  /** Chat identifier */
  readonly chat_id?: number,
  /** The message identifier of the used keyboard */
  readonly message_id?: number,
}

/** Sends a notification about user activity in a chat */
export type sendChatAction = {
  readonly _: 'sendChatAction',
  /** Chat identifier */
  readonly chat_id?: number,
  /** If not 0, a message thread identifier in which the action was performed */
  readonly message_thread_id?: number,
  /** The action description; pass null to cancel the currently active action */
  readonly action?: ChatAction$Input,
}

/**
 * Informs TDLib that the chat is opened by the user. Many useful activities depend
 * on the chat being opened or closed (e.g., in supergroups and channels all updates
 * are received only for opened chats)
 */
export type openChat = {
  readonly _: 'openChat',
  /** Chat identifier */
  readonly chat_id?: number,
}

/**
 * Informs TDLib that the chat is closed by the user. Many useful activities depend
 * on the chat being opened or closed
 */
export type closeChat = {
  readonly _: 'closeChat',
  /** Chat identifier */
  readonly chat_id?: number,
}

/**
 * Informs TDLib that messages are being viewed by the user. Sponsored messages must
 * be marked as viewed only when the entire text of the message is shown on the screen
 * (excluding the button). Many useful activities depend on whether the messages are
 * currently being viewed or not (e.g., marking messages as read, incrementing a view
 * counter, updating a view counter, removing deleted messages in supergroups and channels)
 */
export type viewMessages = {
  readonly _: 'viewMessages',
  /** Chat identifier */
  readonly chat_id?: number,
  /** If not 0, a message thread identifier in which the messages are being viewed */
  readonly message_thread_id?: number,
  /** The identifiers of the messages being viewed */
  readonly message_ids?: ReadonlyArray<number>,
  /** True, if messages in closed chats must be marked as read by the request */
  readonly force_read?: boolean,
}

/**
 * Informs TDLib that the message content has been opened (e.g., the user has opened
 * a photo, video, document, location or venue, or has listened to an audio file or
 * voice note message). An updateMessageContentOpened update will be generated if something
 * has changed
 */
export type openMessageContent = {
  readonly _: 'openMessageContent',
  /** Chat identifier of the message */
  readonly chat_id?: number,
  /** Identifier of the message with the opened content */
  readonly message_id?: number,
}

/**
 * Informs TDLib that a message with an animated emoji was clicked by the user. Returns
 * a big animated sticker to be played or a 404 error if usual animation needs to be
 * played
 */
export type clickAnimatedEmojiMessage = {
  readonly _: 'clickAnimatedEmojiMessage',
  /** Chat identifier of the message */
  readonly chat_id?: number,
  /** Identifier of the clicked message */
  readonly message_id?: number,
}

/**
 * Returns information about the type of an internal link. Returns a 404 error if the
 * link is not internal. Can be called before authorization
 */
export type getInternalLinkType = {
  readonly _: 'getInternalLinkType',
  /** The link */
  readonly link?: string,
}

/**
 * Returns information about an action to be done when the current user clicks an external
 * link. Don't use this method for links from secret chats if web page preview is disabled
 * in secret chats
 */
export type getExternalLinkInfo = {
  readonly _: 'getExternalLinkInfo',
  /** The link */
  readonly link?: string,
}

/**
 * Returns an HTTP URL which can be used to automatically authorize the current user
 * on a website after clicking an HTTP link. Use the method getExternalLinkInfo to find
 * whether a prior user confirmation is needed
 */
export type getExternalLink = {
  readonly _: 'getExternalLink',
  /** The HTTP link */
  readonly link?: string,
  /**
   * True, if the current user allowed the bot, returned in getExternalLinkInfo, to send
   * them messages
   */
  readonly allow_write_access?: boolean,
}

/** Marks all mentions in a chat as read */
export type readAllChatMentions = {
  readonly _: 'readAllChatMentions',
  /** Chat identifier */
  readonly chat_id?: number,
}

/** Returns an existing chat corresponding to a given user */
export type createPrivateChat = {
  readonly _: 'createPrivateChat',
  /** User identifier */
  readonly user_id?: number,
  /**
   * If true, the chat will be created without network request. In this case all information
   * about the chat except its type, title and photo can be incorrect
   */
  readonly force?: boolean,
}

/** Returns an existing chat corresponding to a known basic group */
export type createBasicGroupChat = {
  readonly _: 'createBasicGroupChat',
  /** Basic group identifier */
  readonly basic_group_id?: number,
  /**
   * If true, the chat will be created without network request. In this case all information
   * about the chat except its type, title and photo can be incorrect
   */
  readonly force?: boolean,
}

/** Returns an existing chat corresponding to a known supergroup or channel */
export type createSupergroupChat = {
  readonly _: 'createSupergroupChat',
  /** Supergroup or channel identifier */
  readonly supergroup_id?: number,
  /**
   * If true, the chat will be created without network request. In this case all information
   * about the chat except its type, title and photo can be incorrect
   */
  readonly force?: boolean,
}

/** Returns an existing chat corresponding to a known secret chat */
export type createSecretChat = {
  readonly _: 'createSecretChat',
  /** Secret chat identifier */
  readonly secret_chat_id?: number,
}

/**
 * Creates a new basic group and sends a corresponding messageBasicGroupChatCreate.
 * Returns the newly created chat
 */
export type createNewBasicGroupChat = {
  readonly _: 'createNewBasicGroupChat',
  /** Identifiers of users to be added to the basic group */
  readonly user_ids?: ReadonlyArray<number>,
  /** Title of the new basic group; 1-128 characters */
  readonly title?: string,
}

/**
 * Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate.
 * Returns the newly created chat
 */
export type createNewSupergroupChat = {
  readonly _: 'createNewSupergroupChat',
  /** Title of the new chat; 1-128 characters */
  readonly title?: string,
  /** True, if a channel chat needs to be created */
  readonly is_channel?: boolean,
  /** Chat description; 0-255 characters */
  readonly description?: string,
  /**
   * Chat location if a location-based supergroup is being created; pass null to create
   * an ordinary supergroup chat
   */
  readonly location?: chatLocation$Input,
  /** True, if the supergroup is created for importing messages using importMessage */
  readonly for_import?: boolean,
}

/** Creates a new secret chat. Returns the newly created chat */
export type createNewSecretChat = {
  readonly _: 'createNewSecretChat',
  /** Identifier of the target user */
  readonly user_id?: number,
}

/**
 * Creates a new supergroup from an existing basic group and sends a corresponding messageChatUpgradeTo
 * and messageChatUpgradeFrom; requires creator privileges. Deactivates the original
 * basic group
 */
export type upgradeBasicGroupChatToSupergroupChat = {
  readonly _: 'upgradeBasicGroupChatToSupergroupChat',
  /** Identifier of the chat to upgrade */
  readonly chat_id?: number,
}

/** Returns chat lists to which the chat can be added. This is an offline request */
export type getChatListsToAddChat = {
  readonly _: 'getChatListsToAddChat',
  /** Chat identifier */
  readonly chat_id?: number,
}

/**
 * Adds a chat to a chat list. A chat can't be simultaneously in Main and Archive chat
 * lists, so it is automatically removed from another one if needed
 */
export type addChatToList = {
  readonly _: 'addChatToList',
  /** Chat identifier */
  readonly chat_id?: number,
  /** The chat list. Use getChatListsToAddChat to get suitable chat lists */
  readonly chat_list?: ChatList$Input,
}

/** Returns information about a chat filter by its identifier */
export type getChatFilter = {
  readonly _: 'getChatFilter',
  /** Chat filter identifier */
  readonly chat_filter_id?: number,
}

/** Creates new chat filter. Returns information about the created chat filter */
export type createChatFilter = {
  readonly _: 'createChatFilter',
  /** Chat filter */
  readonly filter?: chatFilter$Input,
}

/** Edits existing chat filter. Returns information about the edited chat filter */
export type editChatFilter = {
  readonly _: 'editChatFilter',
  /** Chat filter identifier */
  readonly chat_filter_id?: number,
  /** The edited chat filter */
  readonly filter?: chatFilter$Input,
}

/** Deletes existing chat filter */
export type deleteChatFilter = {
  readonly _: 'deleteChatFilter',
  /** Chat filter identifier */
  readonly chat_filter_id?: number,
}

/** Changes the order of chat filters */
export type reorderChatFilters = {
  readonly _: 'reorderChatFilters',
  /** Identifiers of chat filters in the new correct order */
  readonly chat_filter_ids?: ReadonlyArray<number>,
}

/** Returns recommended chat filters for the current user */
export type getRecommendedChatFilters = {
  readonly _: 'getRecommendedChatFilters',
}

/** Returns default icon name for a filter. Can be called synchronously */
export type getChatFilterDefaultIconName = {
  readonly _: 'getChatFilterDefaultIconName',
  /** Chat filter */
  readonly filter?: chatFilter$Input,
}

/**
 * Changes the chat title. Supported only for basic groups, supergroups and channels.
 * Requires can_change_info administrator right
 */
export type setChatTitle = {
  readonly _: 'setChatTitle',
  /** Chat identifier */
  readonly chat_id?: number,
  /** New title of the chat; 1-128 characters */
  readonly title?: string,
}

/**
 * Changes the photo of a chat. Supported only for basic groups, supergroups and channels.
 * Requires can_change_info administrator right
 */
export type setChatPhoto = {
  readonly _: 'setChatPhoto',
  /** Chat identifier */
  readonly chat_id?: number,
  /** New chat photo; pass null to delete the chat photo */
  readonly photo?: InputChatPhoto$Input,
}

/**
 * Changes the message TTL in a chat. Requires can_delete_messages administrator right
 * in basic groups, supergroups and channels Message TTL can't be changed in a chat
 * with the current user (Saved Messages) and the chat 777000 (Telegram)
 */
export type setChatMessageTtl = {
  readonly _: 'setChatMessageTtl',
  /** Chat identifier */
  readonly chat_id?: number,
  /**
   * New TTL value, in seconds; must be one of 0, 86400, 7 * 86400, or 31 * 86400 unless
   * the chat is secret
   */
  readonly ttl?: number,
}

/**
 * Changes the chat members permissions. Supported only for basic groups and supergroups.
 * Requires can_restrict_members administrator right
 */
export type setChatPermissions = {
  readonly _: 'setChatPermissions',
  /** Chat identifier */
  readonly chat_id?: number,
  /** New non-administrator members permissions in the chat */
  readonly permissions?: chatPermissions$Input,
}

/** Changes the chat theme. Supported only in private and secret chats */
export type setChatTheme = {
  readonly _: 'setChatTheme',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Name of the new chat theme; pass an empty string to return the default theme */
  readonly theme_name?: string,
}

/** Changes the draft message in a chat */
export type setChatDraftMessage = {
  readonly _: 'setChatDraftMessage',
  /** Chat identifier */
  readonly chat_id?: number,
  /** If not 0, a message thread identifier in which the draft was changed */
  readonly message_thread_id?: number,
  /** New draft message; pass null to remove the draft */
  readonly draft_message?: draftMessage$Input,
}

/**
 * Changes the notification settings of a chat. Notification settings of a chat with
 * the current user (Saved Messages) can't be changed
 */
export type setChatNotificationSettings = {
  readonly _: 'setChatNotificationSettings',
  /** Chat identifier */
  readonly chat_id?: number,
  /**
   * New notification settings for the chat. If the chat is muted for more than 1 week,
   * it is considered to be muted forever
   */
  readonly notification_settings?: chatNotificationSettings$Input,
}

/**
 * Changes the ability of users to save, forward, or copy chat content. Supported only
 * for basic groups, supergroups and channels. Requires owner privileges
 */
export type toggleChatHasProtectedContent = {
  readonly _: 'toggleChatHasProtectedContent',
  /** Chat identifier */
  readonly chat_id?: number,
  /** True, if chat content can't be saved locally, forwarded, or copied */
  readonly has_protected_content?: boolean,
}

/** Changes the marked as unread state of a chat */
export type toggleChatIsMarkedAsUnread = {
  readonly _: 'toggleChatIsMarkedAsUnread',
  /** Chat identifier */
  readonly chat_id?: number,
  /** New value of is_marked_as_unread */
  readonly is_marked_as_unread?: boolean,
}

/**
 * Changes the value of the default disable_notification parameter, used when a message
 * is sent to a chat
 */
export type toggleChatDefaultDisableNotification = {
  readonly _: 'toggleChatDefaultDisableNotification',
  /** Chat identifier */
  readonly chat_id?: number,
  /** New value of default_disable_notification */
  readonly default_disable_notification?: boolean,
}

/** Changes application-specific data associated with a chat */
export type setChatClientData = {
  readonly _: 'setChatClientData',
  /** Chat identifier */
  readonly chat_id?: number,
  /** New value of client_data */
  readonly client_data?: string,
}

/**
 * Changes information about a chat. Available for basic groups, supergroups, and channels.
 * Requires can_change_info administrator right
 */
export type setChatDescription = {
  readonly _: 'setChatDescription',
  /** Identifier of the chat */
  readonly chat_id?: number,
  /** New chat description; 0-255 characters */
  readonly description?: string,
}

/**
 * Changes the discussion group of a channel chat; requires can_change_info administrator
 * right in the channel if it is specified
 */
export type setChatDiscussionGroup = {
  readonly _: 'setChatDiscussionGroup',
  /**
   * Identifier of the channel chat. Pass 0 to remove a link from the supergroup passed
   * in the second argument to a linked channel chat (requires can_pin_messages rights
   * in the supergroup)
   */
  readonly chat_id?: number,
  /**
   * Identifier of a new channel's discussion group. Use 0 to remove the discussion group.
   * Use the method getSuitableDiscussionChats to find all suitable groups. Basic group
   * chats must be first upgraded to supergroup chats. If new chat members don't have
   * access to old messages in the supergroup, then toggleSupergroupIsAllHistoryAvailable
   * must be used first to change that
   */
  readonly discussion_chat_id?: number,
}

/**
 * Changes the location of a chat. Available only for some location-based supergroups,
 * use supergroupFullInfo.can_set_location to check whether the method is allowed to
 * use
 */
export type setChatLocation = {
  readonly _: 'setChatLocation',
  /** Chat identifier */
  readonly chat_id?: number,
  /** New location for the chat; must be valid and not null */
  readonly location?: chatLocation$Input,
}

/**
 * Changes the slow mode delay of a chat. Available only for supergroups; requires can_restrict_members
 * rights
 */
export type setChatSlowModeDelay = {
  readonly _: 'setChatSlowModeDelay',
  /** Chat identifier */
  readonly chat_id?: number,
  /**
   * New slow mode delay for the chat, in seconds; must be one of 0, 10, 30, 60, 300,
   * 900, 3600
   */
  readonly slow_mode_delay?: number,
}

/**
 * Pins a message in a chat; requires can_pin_messages rights or can_edit_messages rights
 * in the channel
 */
export type pinChatMessage = {
  readonly _: 'pinChatMessage',
  /** Identifier of the chat */
  readonly chat_id?: number,
  /** Identifier of the new pinned message */
  readonly message_id?: number,
  /**
   * True, if there must be no notification about the pinned message. Notifications are
   * always disabled in channels and private chats
   */
  readonly disable_notification?: boolean,
  /** True, if the message needs to be pinned for one side only; private chats only */
  readonly only_for_self?: boolean,
}

/**
 * Removes a pinned message from a chat; requires can_pin_messages rights in the group
 * or can_edit_messages rights in the channel
 */
export type unpinChatMessage = {
  readonly _: 'unpinChatMessage',
  /** Identifier of the chat */
  readonly chat_id?: number,
  /** Identifier of the removed pinned message */
  readonly message_id?: number,
}

/**
 * Removes all pinned messages from a chat; requires can_pin_messages rights in the
 * group or can_edit_messages rights in the channel
 */
export type unpinAllChatMessages = {
  readonly _: 'unpinAllChatMessages',
  /** Identifier of the chat */
  readonly chat_id?: number,
}

/**
 * Adds the current user as a new member to a chat. Private and secret chats can't be
 * joined using this method
 */
export type joinChat = {
  readonly _: 'joinChat',
  /** Chat identifier */
  readonly chat_id?: number,
}

/**
 * Removes the current user from chat members. Private and secret chats can't be left
 * using this method
 */
export type leaveChat = {
  readonly _: 'leaveChat',
  /** Chat identifier */
  readonly chat_id?: number,
}

/** Adds a new member to a chat. Members can't be added to private or secret chats */
export type addChatMember = {
  readonly _: 'addChatMember',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Identifier of the user */
  readonly user_id?: number,
  /**
   * The number of earlier messages from the chat to be forwarded to the new member; up
   * to 100. Ignored for supergroups and channels, or if the added user is a bot
   */
  readonly forward_limit?: number,
}

/**
 * Adds multiple new members to a chat. Currently, this method is only available for
 * supergroups and channels. This method can't be used to join a chat. Members can't
 * be added to a channel if it has more than 200 members
 */
export type addChatMembers = {
  readonly _: 'addChatMembers',
  /** Chat identifier */
  readonly chat_id?: number,
  /**
   * Identifiers of the users to be added to the chat. The maximum number of added users
   * is 20 for supergroups and 100 for channels
   */
  readonly user_ids?: ReadonlyArray<number>,
}

/**
 * Changes the status of a chat member, needs appropriate privileges. This function
 * is currently not suitable for transferring chat ownership; use transferChatOwnership
 * instead. Use addChatMember or banChatMember if some additional parameters needs to
 * be passed
 */
export type setChatMemberStatus = {
  readonly _: 'setChatMemberStatus',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Member identifier. Chats can be only banned and unbanned in supergroups and channels */
  readonly member_id?: MessageSender$Input,
  /** The new status of the member in the chat */
  readonly status?: ChatMemberStatus$Input,
}

/**
 * Bans a member in a chat. Members can't be banned in private or secret chats. In supergroups
 * and channels, the user will not be able to return to the group on their own using
 * invite links, etc., unless unbanned first
 */
export type banChatMember = {
  readonly _: 'banChatMember',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Member identifier */
  readonly member_id?: MessageSender$Input,
  /**
   * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the
   * user is banned for more than 366 days or for less than 30 seconds from the current
   * time, the user is considered to be banned forever. Ignored in basic groups and if
   * a chat is banned
   */
  readonly banned_until_date?: number,
  /**
   * Pass true to delete all messages in the chat for the user that is being removed.
   * Always true for supergroups and channels
   */
  readonly revoke_messages?: boolean,
}

/**
 * Checks whether the current session can be used to transfer a chat ownership to another
 * user
 */
export type canTransferOwnership = {
  readonly _: 'canTransferOwnership',
}

/**
 * Changes the owner of a chat. The current user must be a current owner of the chat.
 * Use the method canTransferOwnership to check whether the ownership can be transferred
 * from the current session. Available only for supergroups and channel chats
 */
export type transferChatOwnership = {
  readonly _: 'transferChatOwnership',
  /** Chat identifier */
  readonly chat_id?: number,
  /**
   * Identifier of the user to which transfer the ownership. The ownership can't be transferred
   * to a bot or to a deleted user
   */
  readonly user_id?: number,
  /** The password of the current user */
  readonly password?: string,
}

/** Returns information about a single member of a chat */
export type getChatMember = {
  readonly _: 'getChatMember',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Member identifier */
  readonly member_id?: MessageSender$Input,
}

/**
 * Searches for a specified query in the first name, last name and username of the members
 * of a specified chat. Requires administrator rights in channels
 */
export type searchChatMembers = {
  readonly _: 'searchChatMembers',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Query to search for */
  readonly query?: string,
  /** The maximum number of users to be returned; up to 200 */
  readonly limit?: number,
  /** The type of users to search for; pass null to search among all chat members */
  readonly filter?: ChatMembersFilter$Input,
}

/** Returns a list of administrators of the chat with their custom titles */
export type getChatAdministrators = {
  readonly _: 'getChatAdministrators',
  /** Chat identifier */
  readonly chat_id?: number,
}

/** Clears draft messages in all chats */
export type clearAllDraftMessages = {
  readonly _: 'clearAllDraftMessages',
  /** If true, local draft messages in secret chats will not be cleared */
  readonly exclude_secret_chats?: boolean,
}

/** Returns list of chats with non-default notification settings */
export type getChatNotificationSettingsExceptions = {
  readonly _: 'getChatNotificationSettingsExceptions',
  /**
   * If specified, only chats from the scope will be returned; pass null to return chats
   * from all scopes
   */
  readonly scope?: NotificationSettingsScope$Input,
  /** If true, also chats with non-default sound will be returned */
  readonly compare_sound?: boolean,
}

/** Returns the notification settings for chats of a given type */
export type getScopeNotificationSettings = {
  readonly _: 'getScopeNotificationSettings',
  /** Types of chats for which to return the notification settings information */
  readonly scope?: NotificationSettingsScope$Input,
}

/** Changes notification settings for chats of a given type */
export type setScopeNotificationSettings = {
  readonly _: 'setScopeNotificationSettings',
  /** Types of chats for which to change the notification settings */
  readonly scope?: NotificationSettingsScope$Input,
  /** The new notification settings for the given scope */
  readonly notification_settings?: scopeNotificationSettings$Input,
}

/**
 * Resets all notification settings to their default values. By default, all chats are
 * unmuted, the sound is set to "default" and message previews are shown
 */
export type resetAllNotificationSettings = {
  readonly _: 'resetAllNotificationSettings',
}

/**
 * Changes the pinned state of a chat. There can be up to GetOption("pinned_chat_count_max")/GetOption("pinned_archived_chat_count_max")
 * pinned non-secret chats and the same number of secret chats in the main/arhive chat
 * list
 */
export type toggleChatIsPinned = {
  readonly _: 'toggleChatIsPinned',
  /** Chat list in which to change the pinned state of the chat */
  readonly chat_list?: ChatList$Input,
  /** Chat identifier */
  readonly chat_id?: number,
  /** True, if the chat is pinned */
  readonly is_pinned?: boolean,
}

/** Changes the order of pinned chats */
export type setPinnedChats = {
  readonly _: 'setPinnedChats',
  /** Chat list in which to change the order of pinned chats */
  readonly chat_list?: ChatList$Input,
  /** The new list of pinned chats */
  readonly chat_ids?: ReadonlyArray<number>,
}

/**
 * Downloads a file from the cloud. Download progress and completion of the download
 * will be notified through updateFile updates
 */
export type downloadFile = {
  readonly _: 'downloadFile',
  /** Identifier of the file to download */
  readonly file_id?: number,
  /**
   * Priority of the download (1-32). The higher the priority, the earlier the file will
   * be downloaded. If the priorities of two files are equal, then the last one for which
   * downloadFile was called will be downloaded first
   */
  readonly priority?: number,
  /** The starting position from which the file needs to be downloaded */
  readonly offset?: number,
  /**
   * Number of bytes which need to be downloaded starting from the "offset" position before
   * the download will automatically be canceled; use 0 to download without a limit
   */
  readonly limit?: number,
  /**
   * If false, this request returns file state just after the download has been started.
   * If true, this request returns file state only after the download has succeeded, has
   * failed, has been canceled or a new downloadFile request with different offset/limit
   * parameters was sent
   */
  readonly synchronous?: boolean,
}

/** Returns file downloaded prefix size from a given offset, in bytes */
export type getFileDownloadedPrefixSize = {
  readonly _: 'getFileDownloadedPrefixSize',
  /** Identifier of the file */
  readonly file_id?: number,
  /** Offset from which downloaded prefix size needs to be calculated */
  readonly offset?: number,
}

/** Stops the downloading of a file. If a file has already been downloaded, does nothing */
export type cancelDownloadFile = {
  readonly _: 'cancelDownloadFile',
  /** Identifier of a file to stop downloading */
  readonly file_id?: number,
  /**
   * Pass true to stop downloading only if it hasn't been started, i.e. request hasn't
   * been sent to server
   */
  readonly only_if_pending?: boolean,
}

/** Returns suggested name for saving a file in a given directory */
export type getSuggestedFileName = {
  readonly _: 'getSuggestedFileName',
  /** Identifier of the file */
  readonly file_id?: number,
  /** Directory in which the file is supposed to be saved */
  readonly directory?: string,
}

/**
 * Asynchronously uploads a file to the cloud without sending it in a message. updateFile
 * will be used to notify about upload progress and successful completion of the upload.
 * The file will not have a persistent remote identifier until it will be sent in a
 * message
 */
export type uploadFile = {
  readonly _: 'uploadFile',
  /** File to upload */
  readonly file?: InputFile$Input,
  /** File type; pass null if unknown */
  readonly file_type?: FileType$Input,
  /**
   * Priority of the upload (1-32). The higher the priority, the earlier the file will
   * be uploaded. If the priorities of two files are equal, then the first one for which
   * uploadFile was called will be uploaded first
   */
  readonly priority?: number,
}

/**
 * Stops the uploading of a file. Supported only for files uploaded by using uploadFile.
 * For other files the behavior is undefined
 */
export type cancelUploadFile = {
  readonly _: 'cancelUploadFile',
  /** Identifier of the file to stop uploading */
  readonly file_id?: number,
}

/**
 * Writes a part of a generated file. This method is intended to be used only if the
 * application has no direct access to TDLib's file system, because it is usually slower
 * than a direct write to the destination file
 */
export type writeGeneratedFilePart = {
  readonly _: 'writeGeneratedFilePart',
  /** The identifier of the generation process */
  readonly generation_id?: number | string,
  /** The offset from which to write the data to the file */
  readonly offset?: number,
  /** The data to write */
  readonly data?: string,
}

/** Informs TDLib on a file generation progress */
export type setFileGenerationProgress = {
  readonly _: 'setFileGenerationProgress',
  /** The identifier of the generation process */
  readonly generation_id?: number | string,
  /** Expected size of the generated file, in bytes; 0 if unknown */
  readonly expected_size?: number,
  /** The number of bytes already generated */
  readonly local_prefix_size?: number,
}

/** Finishes the file generation */
export type finishFileGeneration = {
  readonly _: 'finishFileGeneration',
  /** The identifier of the generation process */
  readonly generation_id?: number | string,
  /**
   * If passed, the file generation has failed and must be terminated; pass null if the
   * file generation succeeded
   */
  readonly error?: error$Input,
}

/**
 * Reads a part of a file from the TDLib file cache and returns read bytes. This method
 * is intended to be used only if the application has no direct access to TDLib's file
 * system, because it is usually slower than a direct read from the file
 */
export type readFilePart = {
  readonly _: 'readFilePart',
  /** Identifier of the file. The file must be located in the TDLib file cache */
  readonly file_id?: number,
  /** The offset from which to read the file */
  readonly offset?: number,
  /**
   * Number of bytes to read. An error will be returned if there are not enough bytes
   * available in the file from the specified position. Pass 0 to read all available data
   * from the specified position
   */
  readonly count?: number,
}

/** Deletes a file from the TDLib file cache */
export type deleteFile = {
  readonly _: 'deleteFile',
  /** Identifier of the file to delete */
  readonly file_id?: number,
}

/** Returns information about a file with messages exported from another app */
export type getMessageFileType = {
  readonly _: 'getMessageFileType',
  /** Beginning of the message file; up to 100 first lines */
  readonly message_file_head?: string,
}

/** Returns a confirmation text to be shown to the user before starting message import */
export type getMessageImportConfirmationText = {
  readonly _: 'getMessageImportConfirmationText',
  /**
   * Identifier of a chat to which the messages will be imported. It must be an identifier
   * of a private chat with a mutual contact or an identifier of a supergroup chat with
   * can_change_info administrator right
   */
  readonly chat_id?: number,
}

/** Imports messages exported from another app */
export type importMessages = {
  readonly _: 'importMessages',
  /**
   * Identifier of a chat to which the messages will be imported. It must be an identifier
   * of a private chat with a mutual contact or an identifier of a supergroup chat with
   * can_change_info administrator right
   */
  readonly chat_id?: number,
  /**
   * File with messages to import. Only inputFileLocal and inputFileGenerated are supported.
   * The file must not be previously uploaded
   */
  readonly message_file?: InputFile$Input,
  /**
   * Files used in the imported messages. Only inputFileLocal and inputFileGenerated are
   * supported. The files must not be previously uploaded
   */
  readonly attached_files?: ReadonlyArray<InputFile$Input>,
}

/**
 * Replaces current primary invite link for a chat with a new primary invite link. Available
 * for basic groups, supergroups, and channels. Requires administrator privileges and
 * can_invite_users right
 */
export type replacePrimaryChatInviteLink = {
  readonly _: 'replacePrimaryChatInviteLink',
  /** Chat identifier */
  readonly chat_id?: number,
}

/**
 * Creates a new invite link for a chat. Available for basic groups, supergroups, and
 * channels. Requires administrator privileges and can_invite_users right in the chat
 */
export type createChatInviteLink = {
  readonly _: 'createChatInviteLink',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Invite link name; 0-32 characters */
  readonly name?: string,
  /** Point in time (Unix timestamp) when the link will expire; pass 0 if never */
  readonly expiration_date?: number,
  /**
   * The maximum number of chat members that can join the chat via the link simultaneously;
   * 0-99999; pass 0 if not limited
   */
  readonly member_limit?: number,
  /** True, if the link only creates join request. If true, member_limit must not be specified */
  readonly creates_join_request?: boolean,
}

/**
 * Edits a non-primary invite link for a chat. Available for basic groups, supergroups,
 * and channels. Requires administrator privileges and can_invite_users right in the
 * chat for own links and owner privileges for other links
 */
export type editChatInviteLink = {
  readonly _: 'editChatInviteLink',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Invite link to be edited */
  readonly invite_link?: string,
  /** Invite link name; 0-32 characters */
  readonly name?: string,
  /** Point in time (Unix timestamp) when the link will expire; pass 0 if never */
  readonly expiration_date?: number,
  /**
   * The maximum number of chat members that can join the chat via the link simultaneously;
   * 0-99999; pass 0 if not limited
   */
  readonly member_limit?: number,
  /** True, if the link only creates join request. If true, member_limit must not be specified */
  readonly creates_join_request?: boolean,
}

/**
 * Returns information about an invite link. Requires administrator privileges and can_invite_users
 * right in the chat to get own links and owner privileges to get other links
 */
export type getChatInviteLink = {
  readonly _: 'getChatInviteLink',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Invite link to get */
  readonly invite_link?: string,
}

/**
 * Returns list of chat administrators with number of their invite links. Requires owner
 * privileges in the chat
 */
export type getChatInviteLinkCounts = {
  readonly _: 'getChatInviteLinkCounts',
  /** Chat identifier */
  readonly chat_id?: number,
}

/**
 * Returns invite links for a chat created by specified administrator. Requires administrator
 * privileges and can_invite_users right in the chat to get own links and owner privileges
 * to get other links
 */
export type getChatInviteLinks = {
  readonly _: 'getChatInviteLinks',
  /** Chat identifier */
  readonly chat_id?: number,
  /**
   * User identifier of a chat administrator. Must be an identifier of the current user
   * for non-owner
   */
  readonly creator_user_id?: number,
  /** Pass true if revoked links needs to be returned instead of active or expired */
  readonly is_revoked?: boolean,
  /**
   * Creation date of an invite link starting after which to return invite links; use
   * 0 to get results from the beginning
   */
  readonly offset_date?: number,
  /**
   * Invite link starting after which to return invite links; use empty string to get
   * results from the beginning
   */
  readonly offset_invite_link?: string,
  /** The maximum number of invite links to return; up to 100 */
  readonly limit?: number,
}

/**
 * Returns chat members joined a chat via an invite link. Requires administrator privileges
 * and can_invite_users right in the chat for own links and owner privileges for other
 * links
 */
export type getChatInviteLinkMembers = {
  readonly _: 'getChatInviteLinkMembers',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Invite link for which to return chat members */
  readonly invite_link?: string,
  /**
   * A chat member from which to return next chat members; pass null to get results from
   * the beginning
   */
  readonly offset_member?: chatInviteLinkMember$Input,
  /** The maximum number of chat members to return; up to 100 */
  readonly limit?: number,
}

/**
 * Revokes invite link for a chat. Available for basic groups, supergroups, and channels.
 * Requires administrator privileges and can_invite_users right in the chat for own
 * links and owner privileges for other links. If a primary link is revoked, then additionally
 * to the revoked link returns new primary link
 */
export type revokeChatInviteLink = {
  readonly _: 'revokeChatInviteLink',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Invite link to be revoked */
  readonly invite_link?: string,
}

/**
 * Deletes revoked chat invite links. Requires administrator privileges and can_invite_users
 * right in the chat for own links and owner privileges for other links
 */
export type deleteRevokedChatInviteLink = {
  readonly _: 'deleteRevokedChatInviteLink',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Invite link to revoke */
  readonly invite_link?: string,
}

/**
 * Deletes all revoked chat invite links created by a given chat administrator. Requires
 * administrator privileges and can_invite_users right in the chat for own links and
 * owner privileges for other links
 */
export type deleteAllRevokedChatInviteLinks = {
  readonly _: 'deleteAllRevokedChatInviteLinks',
  /** Chat identifier */
  readonly chat_id?: number,
  /**
   * User identifier of a chat administrator, which links will be deleted. Must be an
   * identifier of the current user for non-owner
   */
  readonly creator_user_id?: number,
}

/**
 * Checks the validity of an invite link for a chat and returns information about the
 * corresponding chat
 */
export type checkChatInviteLink = {
  readonly _: 'checkChatInviteLink',
  /** Invite link to be checked */
  readonly invite_link?: string,
}

/** Uses an invite link to add the current user to the chat if possible */
export type joinChatByInviteLink = {
  readonly _: 'joinChatByInviteLink',
  /** Invite link to use */
  readonly invite_link?: string,
}

/** Returns pending join requests in a chat */
export type getChatJoinRequests = {
  readonly _: 'getChatJoinRequests',
  /** Chat identifier */
  readonly chat_id?: number,
  /**
   * Invite link for which to return join requests. If empty, all join requests will be
   * returned. Requires administrator privileges and can_invite_users right in the chat
   * for own links and owner privileges for other links
   */
  readonly invite_link?: string,
  /**
   * A query to search for in the first names, last names and usernames of the users to
   * return
   */
  readonly query?: string,
  /**
   * A chat join request from which to return next requests; pass null to get results
   * from the beginning
   */
  readonly offset_request?: chatJoinRequest$Input,
  /** The maximum number of requests to join the chat to return */
  readonly limit?: number,
}

/** Handles a pending join request in a chat */
export type processChatJoinRequest = {
  readonly _: 'processChatJoinRequest',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Identifier of the user that sent the request */
  readonly user_id?: number,
  /** True, if the request is approved. Otherwise the request is declived */
  readonly approve?: boolean,
}

/** Handles all pending join requests for a given link in a chat */
export type processChatJoinRequests = {
  readonly _: 'processChatJoinRequests',
  /** Chat identifier */
  readonly chat_id?: number,
  /**
   * Invite link for which to process join requests. If empty, all join requests will
   * be processed. Requires administrator privileges and can_invite_users right in the
   * chat for own links and owner privileges for other links
   */
  readonly invite_link?: string,
  /** True, if the requests are approved. Otherwise the requests are declived */
  readonly approve?: boolean,
}

/** Creates a new call */
export type createCall = {
  readonly _: 'createCall',
  /** Identifier of the user to be called */
  readonly user_id?: number,
  /** The call protocols supported by the application */
  readonly protocol?: callProtocol$Input,
  /** True, if a video call needs to be created */
  readonly is_video?: boolean,
}

/** Accepts an incoming call */
export type acceptCall = {
  readonly _: 'acceptCall',
  /** Call identifier */
  readonly call_id?: number,
  /** The call protocols supported by the application */
  readonly protocol?: callProtocol$Input,
}

/** Sends call signaling data */
export type sendCallSignalingData = {
  readonly _: 'sendCallSignalingData',
  /** Call identifier */
  readonly call_id?: number,
  /** The data */
  readonly data?: string,
}

/** Discards a call */
export type discardCall = {
  readonly _: 'discardCall',
  /** Call identifier */
  readonly call_id?: number,
  /** True, if the user was disconnected */
  readonly is_disconnected?: boolean,
  /** The call duration, in seconds */
  readonly duration?: number,
  /** True, if the call was a video call */
  readonly is_video?: boolean,
  /** Identifier of the connection used during the call */
  readonly connection_id?: number | string,
}

/** Sends a call rating */
export type sendCallRating = {
  readonly _: 'sendCallRating',
  /** Call identifier */
  readonly call_id?: number,
  /** Call rating; 1-5 */
  readonly rating?: number,
  /** An optional user comment if the rating is less than 5 */
  readonly comment?: string,
  /** List of the exact types of problems with the call, specified by the user */
  readonly problems?: ReadonlyArray<CallProblem$Input>,
}

/** Sends debug information for a call */
export type sendCallDebugInformation = {
  readonly _: 'sendCallDebugInformation',
  /** Call identifier */
  readonly call_id?: number,
  /** Debug information in application-specific format */
  readonly debug_information?: string,
}

/**
 * Returns list of participant identifiers, on whose behalf a video chat in the chat
 * can be joined
 */
export type getVideoChatAvailableParticipants = {
  readonly _: 'getVideoChatAvailableParticipants',
  /** Chat identifier */
  readonly chat_id?: number,
}

/**
 * Changes default participant identifier, on whose behalf a video chat in the chat
 * will be joined
 */
export type setVideoChatDefaultParticipant = {
  readonly _: 'setVideoChatDefaultParticipant',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Default group call participant identifier to join the video chats */
  readonly default_participant_id?: MessageSender$Input,
}

/**
 * Creates a video chat (a group call bound to a chat). Available only for basic groups,
 * supergroups and channels; requires can_manage_video_chats rights
 */
export type createVideoChat = {
  readonly _: 'createVideoChat',
  /** Chat identifier, in which the video chat will be created */
  readonly chat_id?: number,
  /** Group call title; if empty, chat title will be used */
  readonly title?: string,
  /**
   * Point in time (Unix timestamp) when the group call is supposed to be started by an
   * administrator; 0 to start the video chat immediately. The date must be at least 10
   * seconds and at most 8 days in the future
   */
  readonly start_date?: number,
}

/** Returns information about a group call */
export type getGroupCall = {
  readonly _: 'getGroupCall',
  /** Group call identifier */
  readonly group_call_id?: number,
}

/** Starts a scheduled group call */
export type startScheduledGroupCall = {
  readonly _: 'startScheduledGroupCall',
  /** Group call identifier */
  readonly group_call_id?: number,
}

/**
 * Toggles whether the current user will receive a notification when the group call
 * will start; scheduled group calls only
 */
export type toggleGroupCallEnabledStartNotification = {
  readonly _: 'toggleGroupCallEnabledStartNotification',
  /** Group call identifier */
  readonly group_call_id?: number,
  /** New value of the enabled_start_notification setting */
  readonly enabled_start_notification?: boolean,
}

/** Joins an active group call. Returns join response payload for tgcalls */
export type joinGroupCall = {
  readonly _: 'joinGroupCall',
  /** Group call identifier */
  readonly group_call_id?: number,
  /**
   * Identifier of a group call participant, which will be used to join the call; pass
   * null to join as self; video chats only
   */
  readonly participant_id?: MessageSender$Input,
  /** Caller audio channel synchronization source identifier; received from tgcalls */
  readonly audio_source_id?: number,
  /** Group call join payload; received from tgcalls */
  readonly payload?: string,
  /** True, if the user's microphone is muted */
  readonly is_muted?: boolean,
  /** True, if the user's video is enabled */
  readonly is_my_video_enabled?: boolean,
  /**
   * If non-empty, invite hash to be used to join the group call without being muted by
   * administrators
   */
  readonly invite_hash?: string,
}

/** Starts screen sharing in a joined group call. Returns join response payload for tgcalls */
export type startGroupCallScreenSharing = {
  readonly _: 'startGroupCallScreenSharing',
  /** Group call identifier */
  readonly group_call_id?: number,
  /** Screen sharing audio channel synchronization source identifier; received from tgcalls */
  readonly audio_source_id?: number,
  /** Group call join payload; received from tgcalls */
  readonly payload?: string,
}

/** Pauses or unpauses screen sharing in a joined group call */
export type toggleGroupCallScreenSharingIsPaused = {
  readonly _: 'toggleGroupCallScreenSharingIsPaused',
  /** Group call identifier */
  readonly group_call_id?: number,
  /** True if screen sharing is paused */
  readonly is_paused?: boolean,
}

/** Ends screen sharing in a joined group call */
export type endGroupCallScreenSharing = {
  readonly _: 'endGroupCallScreenSharing',
  /** Group call identifier */
  readonly group_call_id?: number,
}

/** Sets group call title. Requires groupCall.can_be_managed group call flag */
export type setGroupCallTitle = {
  readonly _: 'setGroupCallTitle',
  /** Group call identifier */
  readonly group_call_id?: number,
  /** New group call title; 1-64 characters */
  readonly title?: string,
}

/**
 * Toggles whether new participants of a group call can be unmuted only by administrators
 * of the group call. Requires groupCall.can_toggle_mute_new_participants group call
 * flag
 */
export type toggleGroupCallMuteNewParticipants = {
  readonly _: 'toggleGroupCallMuteNewParticipants',
  /** Group call identifier */
  readonly group_call_id?: number,
  /** New value of the mute_new_participants setting */
  readonly mute_new_participants?: boolean,
}

/**
 * Invites users to an active group call. Sends a service message of type messageInviteToGroupCall
 * for video chats
 */
export type inviteGroupCallParticipants = {
  readonly _: 'inviteGroupCallParticipants',
  /** Group call identifier */
  readonly group_call_id?: number,
  /** User identifiers. At most 10 users can be invited simultaneously */
  readonly user_ids?: ReadonlyArray<number>,
}

/** Returns invite link to a video chat in a public chat */
export type getGroupCallInviteLink = {
  readonly _: 'getGroupCallInviteLink',
  /** Group call identifier */
  readonly group_call_id?: number,
  /**
   * Pass true if the invite link needs to contain an invite hash, passing which to joinGroupCall
   * would allow the invited user to unmute themselves. Requires groupCall.can_be_managed
   * group call flag
   */
  readonly can_self_unmute?: boolean,
}

/**
 * Revokes invite link for a group call. Requires groupCall.can_be_managed group call
 * flag
 */
export type revokeGroupCallInviteLink = {
  readonly _: 'revokeGroupCallInviteLink',
  /** Group call identifier */
  readonly group_call_id?: number,
}

/**
 * Starts recording of an active group call. Requires groupCall.can_be_managed group
 * call flag
 */
export type startGroupCallRecording = {
  readonly _: 'startGroupCallRecording',
  /** Group call identifier */
  readonly group_call_id?: number,
  /** Group call recording title; 0-64 characters */
  readonly title?: string,
  /** Pass true to record a video file instead of an audio file */
  readonly record_video?: boolean,
  /** Pass true to use portrait orientation for video instead of landscape one */
  readonly use_portrait_orientation?: boolean,
}

/**
 * Ends recording of an active group call. Requires groupCall.can_be_managed group call
 * flag
 */
export type endGroupCallRecording = {
  readonly _: 'endGroupCallRecording',
  /** Group call identifier */
  readonly group_call_id?: number,
}

/** Toggles whether current user's video is paused */
export type toggleGroupCallIsMyVideoPaused = {
  readonly _: 'toggleGroupCallIsMyVideoPaused',
  /** Group call identifier */
  readonly group_call_id?: number,
  /** Pass true if the current user's video is paused */
  readonly is_my_video_paused?: boolean,
}

/** Toggles whether current user's video is enabled */
export type toggleGroupCallIsMyVideoEnabled = {
  readonly _: 'toggleGroupCallIsMyVideoEnabled',
  /** Group call identifier */
  readonly group_call_id?: number,
  /** Pass true if the current user's video is enabled */
  readonly is_my_video_enabled?: boolean,
}

/** Informs TDLib that speaking state of a participant of an active group has changed */
export type setGroupCallParticipantIsSpeaking = {
  readonly _: 'setGroupCallParticipantIsSpeaking',
  /** Group call identifier */
  readonly group_call_id?: number,
  /**
   * Group call participant's synchronization audio source identifier, or 0 for the current
   * user
   */
  readonly audio_source?: number,
  /** True, if the user is speaking */
  readonly is_speaking?: boolean,
}

/**
 * Toggles whether a participant of an active group call is muted, unmuted, or allowed
 * to unmute themselves
 */
export type toggleGroupCallParticipantIsMuted = {
  readonly _: 'toggleGroupCallParticipantIsMuted',
  /** Group call identifier */
  readonly group_call_id?: number,
  /** Participant identifier */
  readonly participant_id?: MessageSender$Input,
  /** Pass true if the user must be muted and false otherwise */
  readonly is_muted?: boolean,
}

/**
 * Changes volume level of a participant of an active group call. If the current user
 * can manage the group call, then the participant's volume level will be changed for
 * all users with the default volume level
 */
export type setGroupCallParticipantVolumeLevel = {
  readonly _: 'setGroupCallParticipantVolumeLevel',
  /** Group call identifier */
  readonly group_call_id?: number,
  /** Participant identifier */
  readonly participant_id?: MessageSender$Input,
  /** New participant's volume level; 1-20000 in hundreds of percents */
  readonly volume_level?: number,
}

/** Toggles whether a group call participant hand is rased */
export type toggleGroupCallParticipantIsHandRaised = {
  readonly _: 'toggleGroupCallParticipantIsHandRaised',
  /** Group call identifier */
  readonly group_call_id?: number,
  /** Participant identifier */
  readonly participant_id?: MessageSender$Input,
  /**
   * Pass true if the user's hand needs to be raised. Only self hand can be raised. Requires
   * groupCall.can_be_managed group call flag to lower other's hand
   */
  readonly is_hand_raised?: boolean,
}

/**
 * Loads more participants of a group call. The loaded participants will be received
 * through updates. Use the field groupCall.loaded_all_participants to check whether
 * all participants have already been loaded
 */
export type loadGroupCallParticipants = {
  readonly _: 'loadGroupCallParticipants',
  /**
   * Group call identifier. The group call must be previously received through getGroupCall
   * and must be joined or being joined
   */
  readonly group_call_id?: number,
  /** The maximum number of participants to load; up to 100 */
  readonly limit?: number,
}

/** Leaves a group call */
export type leaveGroupCall = {
  readonly _: 'leaveGroupCall',
  /** Group call identifier */
  readonly group_call_id?: number,
}

/** Ends a group call. Requires groupCall.can_be_managed */
export type endGroupCall = {
  readonly _: 'endGroupCall',
  /** Group call identifier */
  readonly group_call_id?: number,
}

/**
 * Returns a file with a segment of a group call stream in a modified OGG format for
 * audio or MPEG-4 format for video
 */
export type getGroupCallStreamSegment = {
  readonly _: 'getGroupCallStreamSegment',
  /** Group call identifier */
  readonly group_call_id?: number,
  /** Point in time when the stream segment begins; Unix timestamp in milliseconds */
  readonly time_offset?: number,
  /** Segment duration scale; 0-1. Segment's duration is 1000/(2**scale) milliseconds */
  readonly scale?: number,
  /** Identifier of an audio/video channel to get as received from tgcalls */
  readonly channel_id?: number,
  /** Video quality as received from tgcalls; pass null to get the worst available quality */
  readonly video_quality?: GroupCallVideoQuality$Input,
}

/**
 * Changes the block state of a message sender. Currently, only users and supergroup
 * chats can be blocked
 */
export type toggleMessageSenderIsBlocked = {
  readonly _: 'toggleMessageSenderIsBlocked',
  /** Identifier of a message sender to block/unblock */
  readonly sender_id?: MessageSender$Input,
  /** New value of is_blocked */
  readonly is_blocked?: boolean,
}

/** Blocks an original sender of a message in the Replies chat */
export type blockMessageSenderFromReplies = {
  readonly _: 'blockMessageSenderFromReplies',
  /** The identifier of an incoming message in the Replies chat */
  readonly message_id?: number,
  /** Pass true if the message must be deleted */
  readonly delete_message?: boolean,
  /** Pass true if all messages from the same sender must be deleted */
  readonly delete_all_messages?: boolean,
  /** Pass true if the sender must be reported to the Telegram moderators */
  readonly report_spam?: boolean,
}

/** Returns users and chats that were blocked by the current user */
export type getBlockedMessageSenders = {
  readonly _: 'getBlockedMessageSenders',
  /** Number of users and chats to skip in the result; must be non-negative */
  readonly offset?: number,
  /** The maximum number of users and chats to return; up to 100 */
  readonly limit?: number,
}

/** Adds a user to the contact list or edits an existing contact by their user identifier */
export type addContact = {
  readonly _: 'addContact',
  /**
   * The contact to add or edit; phone number can be empty and needs to be specified only
   * if known, vCard is ignored
   */
  readonly contact?: contact$Input,
  /**
   * True, if the new contact needs to be allowed to see current user's phone number.
   * A corresponding rule to userPrivacySettingShowPhoneNumber will be added if needed.
   * Use the field userFullInfo.need_phone_number_privacy_exception to check whether the
   * current user needs to be asked to share their phone number
   */
  readonly share_phone_number?: boolean,
}

/**
 * Adds new contacts or edits existing contacts by their phone numbers; contacts' user
 * identifiers are ignored
 */
export type importContacts = {
  readonly _: 'importContacts',
  /** The list of contacts to import or edit; contacts' vCard are ignored and are not imported */
  readonly contacts?: ReadonlyArray<contact$Input>,
}

/** Returns all user contacts */
export type getContacts = {
  readonly _: 'getContacts',
}

/**
 * Searches for the specified query in the first names, last names and usernames of
 * the known user contacts
 */
export type searchContacts = {
  readonly _: 'searchContacts',
  /** Query to search for; may be empty to return all contacts */
  readonly query?: string,
  /** The maximum number of users to be returned */
  readonly limit?: number,
}

/** Removes users from the contact list */
export type removeContacts = {
  readonly _: 'removeContacts',
  /** Identifiers of users to be deleted */
  readonly user_ids?: ReadonlyArray<number>,
}

/** Returns the total number of imported contacts */
export type getImportedContactCount = {
  readonly _: 'getImportedContactCount',
}

/**
 * Changes imported contacts using the list of contacts saved on the device. Imports
 * newly added contacts and, if at least the file database is enabled, deletes recently
 * deleted contacts. Query result depends on the result of the previous query, so only
 * one query is possible at the same time
 */
export type changeImportedContacts = {
  readonly _: 'changeImportedContacts',
  /** The new list of contacts, contact's vCard are ignored and are not imported */
  readonly contacts?: ReadonlyArray<contact$Input>,
}

/** Clears all imported contacts, contact list remains unchanged */
export type clearImportedContacts = {
  readonly _: 'clearImportedContacts',
}

/**
 * Shares the phone number of the current user with a mutual contact. Supposed to be
 * called when the user clicks on chatActionBarSharePhoneNumber
 */
export type sharePhoneNumber = {
  readonly _: 'sharePhoneNumber',
  /**
   * Identifier of the user with whom to share the phone number. The user must be a mutual
   * contact
   */
  readonly user_id?: number,
}

/**
 * Returns the profile photos of a user. The result of this query may be outdated: some
 * photos might have been deleted already
 */
export type getUserProfilePhotos = {
  readonly _: 'getUserProfilePhotos',
  /** User identifier */
  readonly user_id?: number,
  /** The number of photos to skip; must be non-negative */
  readonly offset?: number,
  /** The maximum number of photos to be returned; up to 100 */
  readonly limit?: number,
}

/**
 * Returns stickers from the installed sticker sets that correspond to a given emoji.
 * If the emoji is non-empty, favorite and recently used stickers may also be returned
 */
export type getStickers = {
  readonly _: 'getStickers',
  /** String representation of emoji. If empty, returns all known installed stickers */
  readonly emoji?: string,
  /** The maximum number of stickers to be returned */
  readonly limit?: number,
}

/** Searches for stickers from public sticker sets that correspond to a given emoji */
export type searchStickers = {
  readonly _: 'searchStickers',
  /** String representation of emoji; must be non-empty */
  readonly emoji?: string,
  /** The maximum number of stickers to be returned */
  readonly limit?: number,
}

/** Returns a list of installed sticker sets */
export type getInstalledStickerSets = {
  readonly _: 'getInstalledStickerSets',
  /** Pass true to return mask sticker sets; pass false to return ordinary sticker sets */
  readonly is_masks?: boolean,
}

/** Returns a list of archived sticker sets */
export type getArchivedStickerSets = {
  readonly _: 'getArchivedStickerSets',
  /** Pass true to return mask stickers sets; pass false to return ordinary sticker sets */
  readonly is_masks?: boolean,
  /** Identifier of the sticker set from which to return the result */
  readonly offset_sticker_set_id?: number | string,
  /** The maximum number of sticker sets to return; up to 100 */
  readonly limit?: number,
}

/**
 * Returns a list of trending sticker sets. For optimal performance, the number of returned
 * sticker sets is chosen by TDLib
 */
export type getTrendingStickerSets = {
  readonly _: 'getTrendingStickerSets',
  /** The offset from which to return the sticker sets; must be non-negative */
  readonly offset?: number,
  /**
   * The maximum number of sticker sets to be returned; up to 100. For optimal performance,
   * the number of returned sticker sets is chosen by TDLib and can be smaller than the
   * specified limit, even if the end of the list has not been reached
   */
  readonly limit?: number,
}

/**
 * Returns a list of sticker sets attached to a file. Currently, only photos and videos
 * can have attached sticker sets
 */
export type getAttachedStickerSets = {
  readonly _: 'getAttachedStickerSets',
  /** File identifier */
  readonly file_id?: number,
}

/** Returns information about a sticker set by its identifier */
export type getStickerSet = {
  readonly _: 'getStickerSet',
  /** Identifier of the sticker set */
  readonly set_id?: number | string,
}

/** Searches for a sticker set by its name */
export type searchStickerSet = {
  readonly _: 'searchStickerSet',
  /** Name of the sticker set */
  readonly name?: string,
}

/**
 * Searches for installed sticker sets by looking for specified query in their title
 * and name
 */
export type searchInstalledStickerSets = {
  readonly _: 'searchInstalledStickerSets',
  /** Pass true to return mask sticker sets; pass false to return ordinary sticker sets */
  readonly is_masks?: boolean,
  /** Query to search for */
  readonly query?: string,
  /** The maximum number of sticker sets to return */
  readonly limit?: number,
}

/**
 * Searches for ordinary sticker sets by looking for specified query in their title
 * and name. Excludes installed sticker sets from the results
 */
export type searchStickerSets = {
  readonly _: 'searchStickerSets',
  /** Query to search for */
  readonly query?: string,
}

/** Installs/uninstalls or activates/archives a sticker set */
export type changeStickerSet = {
  readonly _: 'changeStickerSet',
  /** Identifier of the sticker set */
  readonly set_id?: number | string,
  /** The new value of is_installed */
  readonly is_installed?: boolean,
  /** The new value of is_archived. A sticker set can't be installed and archived simultaneously */
  readonly is_archived?: boolean,
}

/** Informs the server that some trending sticker sets have been viewed by the user */
export type viewTrendingStickerSets = {
  readonly _: 'viewTrendingStickerSets',
  /** Identifiers of viewed trending sticker sets */
  readonly sticker_set_ids?: ReadonlyArray<number | string>,
}

/** Changes the order of installed sticker sets */
export type reorderInstalledStickerSets = {
  readonly _: 'reorderInstalledStickerSets',
  /**
   * Pass true to change the order of mask sticker sets; pass false to change the order
   * of ordinary sticker sets
   */
  readonly is_masks?: boolean,
  /** Identifiers of installed sticker sets in the new correct order */
  readonly sticker_set_ids?: ReadonlyArray<number | string>,
}

/** Returns a list of recently used stickers */
export type getRecentStickers = {
  readonly _: 'getRecentStickers',
  /**
   * Pass true to return stickers and masks that were recently attached to photos or video
   * files; pass false to return recently sent stickers
   */
  readonly is_attached?: boolean,
}

/**
 * Manually adds a new sticker to the list of recently used stickers. The new sticker
 * is added to the top of the list. If the sticker was already in the list, it is removed
 * from the list first. Only stickers belonging to a sticker set can be added to this
 * list
 */
export type addRecentSticker = {
  readonly _: 'addRecentSticker',
  /**
   * Pass true to add the sticker to the list of stickers recently attached to photo or
   * video files; pass false to add the sticker to the list of recently sent stickers
   */
  readonly is_attached?: boolean,
  /** Sticker file to add */
  readonly sticker?: InputFile$Input,
}

/** Removes a sticker from the list of recently used stickers */
export type removeRecentSticker = {
  readonly _: 'removeRecentSticker',
  /**
   * Pass true to remove the sticker from the list of stickers recently attached to photo
   * or video files; pass false to remove the sticker from the list of recently sent stickers
   */
  readonly is_attached?: boolean,
  /** Sticker file to delete */
  readonly sticker?: InputFile$Input,
}

/** Clears the list of recently used stickers */
export type clearRecentStickers = {
  readonly _: 'clearRecentStickers',
  /**
   * Pass true to clear the list of stickers recently attached to photo or video files;
   * pass false to clear the list of recently sent stickers
   */
  readonly is_attached?: boolean,
}

/** Returns favorite stickers */
export type getFavoriteStickers = {
  readonly _: 'getFavoriteStickers',
}

/**
 * Adds a new sticker to the list of favorite stickers. The new sticker is added to
 * the top of the list. If the sticker was already in the list, it is removed from the
 * list first. Only stickers belonging to a sticker set can be added to this list
 */
export type addFavoriteSticker = {
  readonly _: 'addFavoriteSticker',
  /** Sticker file to add */
  readonly sticker?: InputFile$Input,
}

/** Removes a sticker from the list of favorite stickers */
export type removeFavoriteSticker = {
  readonly _: 'removeFavoriteSticker',
  /** Sticker file to delete from the list */
  readonly sticker?: InputFile$Input,
}

/**
 * Returns emoji corresponding to a sticker. The list is only for informational purposes,
 * because a sticker is always sent with a fixed emoji from the corresponding Sticker
 * object
 */
export type getStickerEmojis = {
  readonly _: 'getStickerEmojis',
  /** Sticker file identifier */
  readonly sticker?: InputFile$Input,
}

/** Searches for emojis by keywords. Supported only if the file database is enabled */
export type searchEmojis = {
  readonly _: 'searchEmojis',
  /** Text to search for */
  readonly text?: string,
  /** True, if only emojis, which exactly match text needs to be returned */
  readonly exact_match?: boolean,
  /**
   * List of possible IETF language tags of the user's input language; may be empty if
   * unknown
   */
  readonly input_language_codes?: ReadonlyArray<string>,
}

/**
 * Returns an animated emoji corresponding to a given emoji. Returns a 404 error if
 * the emoji has no animated emoji
 */
export type getAnimatedEmoji = {
  readonly _: 'getAnimatedEmoji',
  /** The emoji */
  readonly emoji?: string,
}

/**
 * Returns an HTTP URL which can be used to automatically log in to the translation
 * platform and suggest new emoji replacements. The URL will be valid for 30 seconds
 * after generation
 */
export type getEmojiSuggestionsUrl = {
  readonly _: 'getEmojiSuggestionsUrl',
  /** Language code for which the emoji replacements will be suggested */
  readonly language_code?: string,
}

/** Returns saved animations */
export type getSavedAnimations = {
  readonly _: 'getSavedAnimations',
}

/**
 * Manually adds a new animation to the list of saved animations. The new animation
 * is added to the beginning of the list. If the animation was already in the list,
 * it is removed first. Only non-secret video animations with MIME type "video/mp4"
 * can be added to the list
 */
export type addSavedAnimation = {
  readonly _: 'addSavedAnimation',
  /**
   * The animation file to be added. Only animations known to the server (i.e., successfully
   * sent via a message) can be added to the list
   */
  readonly animation?: InputFile$Input,
}

/** Removes an animation from the list of saved animations */
export type removeSavedAnimation = {
  readonly _: 'removeSavedAnimation',
  /** Animation file to be removed */
  readonly animation?: InputFile$Input,
}

/** Returns up to 20 recently used inline bots in the order of their last usage */
export type getRecentInlineBots = {
  readonly _: 'getRecentInlineBots',
}

/** Searches for recently used hashtags by their prefix */
export type searchHashtags = {
  readonly _: 'searchHashtags',
  /** Hashtag prefix to search for */
  readonly prefix?: string,
  /** The maximum number of hashtags to be returned */
  readonly limit?: number,
}

/** Removes a hashtag from the list of recently used hashtags */
export type removeRecentHashtag = {
  readonly _: 'removeRecentHashtag',
  /** Hashtag to delete */
  readonly hashtag?: string,
}

/**
 * Returns a web page preview by the text of the message. Do not call this function
 * too often. Returns a 404 error if the web page has no preview
 */
export type getWebPagePreview = {
  readonly _: 'getWebPagePreview',
  /** Message text with formatting */
  readonly text?: formattedText$Input,
}

/**
 * Returns an instant view version of a web page if available. Returns a 404 error if
 * the web page has no instant view page
 */
export type getWebPageInstantView = {
  readonly _: 'getWebPageInstantView',
  /** The web page URL */
  readonly url?: string,
  /** If true, the full instant view for the web page will be returned */
  readonly force_full?: boolean,
}

/** Changes a profile photo for the current user */
export type setProfilePhoto = {
  readonly _: 'setProfilePhoto',
  /** Profile photo to set */
  readonly photo?: InputChatPhoto$Input,
}

/** Deletes a profile photo */
export type deleteProfilePhoto = {
  readonly _: 'deleteProfilePhoto',
  /** Identifier of the profile photo to delete */
  readonly profile_photo_id?: number | string,
}

/** Changes the first and last name of the current user */
export type setName = {
  readonly _: 'setName',
  /** The new value of the first name for the current user; 1-64 characters */
  readonly first_name?: string,
  /** The new value of the optional last name for the current user; 0-64 characters */
  readonly last_name?: string,
}

/** Changes the bio of the current user */
export type setBio = {
  readonly _: 'setBio',
  /** The new value of the user bio; 0-70 characters without line feeds */
  readonly bio?: string,
}

/** Changes the username of the current user */
export type setUsername = {
  readonly _: 'setUsername',
  /** The new value of the username. Use an empty string to remove the username */
  readonly username?: string,
}

/**
 * Changes the location of the current user. Needs to be called if GetOption("is_location_visible")
 * is true and location changes for more than 1 kilometer
 */
export type setLocation = {
  readonly _: 'setLocation',
  /** The new location of the user */
  readonly location?: location$Input,
}

/**
 * Changes the phone number of the user and sends an authentication code to the user's
 * new phone number. On success, returns information about the sent code
 */
export type changePhoneNumber = {
  readonly _: 'changePhoneNumber',
  /** The new phone number of the user in international format */
  readonly phone_number?: string,
  /**
   * Settings for the authentication of the user's phone number; pass null to use default
   * settings
   */
  readonly settings?: phoneNumberAuthenticationSettings$Input,
}

/**
 * Re-sends the authentication code sent to confirm a new phone number for the current
 * user. Works only if the previously received authenticationCodeInfo next_code_type
 * was not null and the server-specified timeout has passed
 */
export type resendChangePhoneNumberCode = {
  readonly _: 'resendChangePhoneNumberCode',
}

/** Checks the authentication code sent to confirm a new phone number of the user */
export type checkChangePhoneNumberCode = {
  readonly _: 'checkChangePhoneNumberCode',
  /** Authentication code to check */
  readonly code?: string,
}

/**
 * Sets the list of commands supported by the bot for the given user scope and language;
 * for bots only
 */
export type setCommands = {
  readonly _: 'setCommands',
  /**
   * The scope to which the commands are relevant; pass null to change commands in the
   * default bot command scope
   */
  readonly scope?: BotCommandScope$Input,
  /**
   * A two-letter ISO 639-1 country code. If empty, the commands will be applied to all
   * users from the given scope, for which language there are no dedicated commands
   */
  readonly language_code?: string,
  /** List of the bot's commands */
  readonly commands?: ReadonlyArray<botCommand$Input>,
}

/**
 * Deletes commands supported by the bot for the given user scope and language; for
 * bots only
 */
export type deleteCommands = {
  readonly _: 'deleteCommands',
  /**
   * The scope to which the commands are relevant; pass null to delete commands in the
   * default bot command scope
   */
  readonly scope?: BotCommandScope$Input,
  /** A two-letter ISO 639-1 country code or an empty string */
  readonly language_code?: string,
}

/**
 * Returns the list of commands supported by the bot for the given user scope and language;
 * for bots only
 */
export type getCommands = {
  readonly _: 'getCommands',
  /**
   * The scope to which the commands are relevant; pass null to get commands in the default
   * bot command scope
   */
  readonly scope?: BotCommandScope$Input,
  /** A two-letter ISO 639-1 country code or an empty string */
  readonly language_code?: string,
}

/** Returns all active sessions of the current user */
export type getActiveSessions = {
  readonly _: 'getActiveSessions',
}

/** Terminates a session of the current user */
export type terminateSession = {
  readonly _: 'terminateSession',
  /** Session identifier */
  readonly session_id?: number | string,
}

/** Terminates all other sessions of the current user */
export type terminateAllOtherSessions = {
  readonly _: 'terminateAllOtherSessions',
}

/** Toggles whether a session can accept incoming calls */
export type toggleSessionCanAcceptCalls = {
  readonly _: 'toggleSessionCanAcceptCalls',
  /** Session identifier */
  readonly session_id?: number | string,
  /** True, if incoming calls can be accepted by the session */
  readonly can_accept_calls?: boolean,
}

/** Toggles whether a session can accept incoming secret chats */
export type toggleSessionCanAcceptSecretChats = {
  readonly _: 'toggleSessionCanAcceptSecretChats',
  /** Session identifier */
  readonly session_id?: number | string,
  /** True, if incoming secret chats can be accepted by the session */
  readonly can_accept_secret_chats?: boolean,
}

/** Changes the period of inactivity after which sessions will automatically be terminated */
export type setInactiveSessionTtl = {
  readonly _: 'setInactiveSessionTtl',
  /**
   * New number of days of inactivity before sessions will be automatically terminated;
   * 1-366 days
   */
  readonly inactive_session_ttl_days?: number,
}

/** Returns all website where the current user used Telegram to log in */
export type getConnectedWebsites = {
  readonly _: 'getConnectedWebsites',
}

/** Disconnects website from the current user's Telegram account */
export type disconnectWebsite = {
  readonly _: 'disconnectWebsite',
  /** Website identifier */
  readonly website_id?: number | string,
}

/** Disconnects all websites from the current user's Telegram account */
export type disconnectAllWebsites = {
  readonly _: 'disconnectAllWebsites',
}

/**
 * Changes the username of a supergroup or channel, requires owner privileges in the
 * supergroup or channel
 */
export type setSupergroupUsername = {
  readonly _: 'setSupergroupUsername',
  /** Identifier of the supergroup or channel */
  readonly supergroup_id?: number,
  /** New value of the username. Use an empty string to remove the username */
  readonly username?: string,
}

/** Changes the sticker set of a supergroup; requires can_change_info administrator right */
export type setSupergroupStickerSet = {
  readonly _: 'setSupergroupStickerSet',
  /** Identifier of the supergroup */
  readonly supergroup_id?: number,
  /**
   * New value of the supergroup sticker set identifier. Use 0 to remove the supergroup
   * sticker set
   */
  readonly sticker_set_id?: number | string,
}

/**
 * Toggles whether sender signature is added to sent messages in a channel; requires
 * can_change_info administrator right
 */
export type toggleSupergroupSignMessages = {
  readonly _: 'toggleSupergroupSignMessages',
  /** Identifier of the channel */
  readonly supergroup_id?: number,
  /** New value of sign_messages */
  readonly sign_messages?: boolean,
}

/**
 * Toggles whether the message history of a supergroup is available to new members;
 * requires can_change_info administrator right
 */
export type toggleSupergroupIsAllHistoryAvailable = {
  readonly _: 'toggleSupergroupIsAllHistoryAvailable',
  /** The identifier of the supergroup */
  readonly supergroup_id?: number,
  /** The new value of is_all_history_available */
  readonly is_all_history_available?: boolean,
}

/** Upgrades supergroup to a broadcast group; requires owner privileges in the supergroup */
export type toggleSupergroupIsBroadcastGroup = {
  readonly _: 'toggleSupergroupIsBroadcastGroup',
  /** Identifier of the supergroup */
  readonly supergroup_id?: number,
}

/** Reports messages in a supergroup as spam; requires administrator rights in the supergroup */
export type reportSupergroupSpam = {
  readonly _: 'reportSupergroupSpam',
  /** Supergroup identifier */
  readonly supergroup_id?: number,
  /** Identifiers of messages to report */
  readonly message_ids?: ReadonlyArray<number>,
}

/**
 * Returns information about members or banned users in a supergroup or channel. Can
 * be used only if supergroupFullInfo.can_get_members == true; additionally, administrator
 * privileges may be required for some filters
 */
export type getSupergroupMembers = {
  readonly _: 'getSupergroupMembers',
  /** Identifier of the supergroup or channel */
  readonly supergroup_id?: number,
  /** The type of users to return; pass null to use supergroupMembersFilterRecent */
  readonly filter?: SupergroupMembersFilter$Input,
  /** Number of users to skip */
  readonly offset?: number,
  /** The maximum number of users be returned; up to 200 */
  readonly limit?: number,
}

/** Closes a secret chat, effectively transferring its state to secretChatStateClosed */
export type closeSecretChat = {
  readonly _: 'closeSecretChat',
  /** Secret chat identifier */
  readonly secret_chat_id?: number,
}

/**
 * Returns a list of service actions taken by chat members and administrators in the
 * last 48 hours. Available only for supergroups and channels. Requires administrator
 * rights. Returns results in reverse chronological order (i. e., in order of decreasing
 * event_id)
 */
export type getChatEventLog = {
  readonly _: 'getChatEventLog',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Search query by which to filter events */
  readonly query?: string,
  /**
   * Identifier of an event from which to return results. Use 0 to get results from the
   * latest events
   */
  readonly from_event_id?: number | string,
  /** The maximum number of events to return; up to 100 */
  readonly limit?: number,
  /** The types of events to return; pass null to get chat events of all types */
  readonly filters?: chatEventLogFilters$Input,
  /**
   * User identifiers by which to filter events. By default, events relating to all users
   * will be returned
   */
  readonly user_ids?: ReadonlyArray<number>,
}

/**
 * Returns an invoice payment form. This method must be called when the user presses
 * inlineKeyboardButtonBuy
 */
export type getPaymentForm = {
  readonly _: 'getPaymentForm',
  /** Chat identifier of the Invoice message */
  readonly chat_id?: number,
  /** Message identifier */
  readonly message_id?: number,
  /** Preferred payment form theme; pass null to use the default theme */
  readonly theme?: paymentFormTheme$Input,
}

/**
 * Validates the order information provided by a user and returns the available shipping
 * options for a flexible invoice
 */
export type validateOrderInfo = {
  readonly _: 'validateOrderInfo',
  /** Chat identifier of the Invoice message */
  readonly chat_id?: number,
  /** Message identifier */
  readonly message_id?: number,
  /** The order information, provided by the user; pass null if empty */
  readonly order_info?: orderInfo$Input,
  /** True, if the order information can be saved */
  readonly allow_save?: boolean,
}

/** Sends a filled-out payment form to the bot for final verification */
export type sendPaymentForm = {
  readonly _: 'sendPaymentForm',
  /** Chat identifier of the Invoice message */
  readonly chat_id?: number,
  /** Message identifier */
  readonly message_id?: number,
  /** Payment form identifier returned by getPaymentForm */
  readonly payment_form_id?: number | string,
  /** Identifier returned by validateOrderInfo, or an empty string */
  readonly order_info_id?: string,
  /** Identifier of a chosen shipping option, if applicable */
  readonly shipping_option_id?: string,
  /** The credentials chosen by user for payment */
  readonly credentials?: InputCredentials$Input,
  /** Chosen by the user amount of tip in the smallest units of the currency */
  readonly tip_amount?: number,
}

/** Returns information about a successful payment */
export type getPaymentReceipt = {
  readonly _: 'getPaymentReceipt',
  /** Chat identifier of the PaymentSuccessful message */
  readonly chat_id?: number,
  /** Message identifier */
  readonly message_id?: number,
}

/** Returns saved order info, if any */
export type getSavedOrderInfo = {
  readonly _: 'getSavedOrderInfo',
}

/** Deletes saved order info */
export type deleteSavedOrderInfo = {
  readonly _: 'deleteSavedOrderInfo',
}

/** Deletes saved credentials for all payment provider bots */
export type deleteSavedCredentials = {
  readonly _: 'deleteSavedCredentials',
}

/** Returns a user that can be contacted to get support */
export type getSupportUser = {
  readonly _: 'getSupportUser',
}

/** Returns backgrounds installed by the user */
export type getBackgrounds = {
  readonly _: 'getBackgrounds',
  /** True, if the backgrounds must be ordered for dark theme */
  readonly for_dark_theme?: boolean,
}

/** Constructs a persistent HTTP URL for a background */
export type getBackgroundUrl = {
  readonly _: 'getBackgroundUrl',
  /** Background name */
  readonly name?: string,
  /** Background type */
  readonly type?: BackgroundType$Input,
}

/** Searches for a background by its name */
export type searchBackground = {
  readonly _: 'searchBackground',
  /** The name of the background */
  readonly name?: string,
}

/**
 * Changes the background selected by the user; adds background to the list of installed
 * backgrounds
 */
export type setBackground = {
  readonly _: 'setBackground',
  /**
   * The input background to use; pass null to create a new filled backgrounds or to remove
   * the current background
   */
  readonly background?: InputBackground$Input,
  /**
   * Background type; pass null to use the default type of the remote background or to
   * remove the current background
   */
  readonly type?: BackgroundType$Input,
  /** True, if the background is chosen for dark theme */
  readonly for_dark_theme?: boolean,
}

/** Removes background from the list of installed backgrounds */
export type removeBackground = {
  readonly _: 'removeBackground',
  /** The background identifier */
  readonly background_id?: number | string,
}

/** Resets list of installed backgrounds to its default value */
export type resetBackgrounds = {
  readonly _: 'resetBackgrounds',
}

/**
 * Returns information about the current localization target. This is an offline request
 * if only_local is true. Can be called before authorization
 */
export type getLocalizationTargetInfo = {
  readonly _: 'getLocalizationTargetInfo',
  /** If true, returns only locally available information without sending network requests */
  readonly only_local?: boolean,
}

/**
 * Returns information about a language pack. Returned language pack identifier may
 * be different from a provided one. Can be called before authorization
 */
export type getLanguagePackInfo = {
  readonly _: 'getLanguagePackInfo',
  /** Language pack identifier */
  readonly language_pack_id?: string,
}

/**
 * Returns strings from a language pack in the current localization target by their
 * keys. Can be called before authorization
 */
export type getLanguagePackStrings = {
  readonly _: 'getLanguagePackStrings',
  /** Language pack identifier of the strings to be returned */
  readonly language_pack_id?: string,
  /**
   * Language pack keys of the strings to be returned; leave empty to request all available
   * strings
   */
  readonly keys?: ReadonlyArray<string>,
}

/**
 * Fetches the latest versions of all strings from a language pack in the current localization
 * target from the server. This method doesn't need to be called explicitly for the
 * current used/base language packs. Can be called before authorization
 */
export type synchronizeLanguagePack = {
  readonly _: 'synchronizeLanguagePack',
  /** Language pack identifier */
  readonly language_pack_id?: string,
}

/**
 * Adds a custom server language pack to the list of installed language packs in current
 * localization target. Can be called before authorization
 */
export type addCustomServerLanguagePack = {
  readonly _: 'addCustomServerLanguagePack',
  /**
   * Identifier of a language pack to be added; may be different from a name that is used
   * in an "https://t.me/setlanguage/" link
   */
  readonly language_pack_id?: string,
}

/** Adds or changes a custom local language pack to the current localization target */
export type setCustomLanguagePack = {
  readonly _: 'setCustomLanguagePack',
  /**
   * Information about the language pack. Language pack ID must start with 'X', consist
   * only of English letters, digits and hyphens, and must not exceed 64 characters. Can
   * be called before authorization
   */
  readonly info?: languagePackInfo$Input,
  /** Strings of the new language pack */
  readonly strings?: ReadonlyArray<languagePackString$Input>,
}

/**
 * Edits information about a custom local language pack in the current localization
 * target. Can be called before authorization
 */
export type editCustomLanguagePackInfo = {
  readonly _: 'editCustomLanguagePackInfo',
  /** New information about the custom local language pack */
  readonly info?: languagePackInfo$Input,
}

/**
 * Adds, edits or deletes a string in a custom local language pack. Can be called before
 * authorization
 */
export type setCustomLanguagePackString = {
  readonly _: 'setCustomLanguagePackString',
  /**
   * Identifier of a previously added custom local language pack in the current localization
   * target
   */
  readonly language_pack_id?: string,
  /** New language pack string */
  readonly new_string?: languagePackString$Input,
}

/**
 * Deletes all information about a language pack in the current localization target.
 * The language pack which is currently in use (including base language pack) or is
 * being synchronized can't be deleted. Can be called before authorization
 */
export type deleteLanguagePack = {
  readonly _: 'deleteLanguagePack',
  /** Identifier of the language pack to delete */
  readonly language_pack_id?: string,
}

/**
 * Registers the currently used device for receiving push notifications. Returns a globally
 * unique identifier of the push notification subscription
 */
export type registerDevice = {
  readonly _: 'registerDevice',
  /** Device token */
  readonly device_token?: DeviceToken$Input,
  /** List of user identifiers of other users currently using the application */
  readonly other_user_ids?: ReadonlyArray<number>,
}

/**
 * Handles a push notification. Returns error with code 406 if the push notification
 * is not supported and connection to the server is required to fetch new data. Can
 * be called before authorization
 */
export type processPushNotification = {
  readonly _: 'processPushNotification',
  /**
   * JSON-encoded push notification payload with all fields sent by the server, and "google.sent_time"
   * and "google.notification.sound" fields added
   */
  readonly payload?: string,
}

/**
 * Returns a globally unique push notification subscription identifier for identification
 * of an account, which has received a push notification. Can be called synchronously
 */
export type getPushReceiverId = {
  readonly _: 'getPushReceiverId',
  /** JSON-encoded push notification payload */
  readonly payload?: string,
}

/** Returns t.me URLs recently visited by a newly registered user */
export type getRecentlyVisitedTMeUrls = {
  readonly _: 'getRecentlyVisitedTMeUrls',
  /** Google Play referrer to identify the user */
  readonly referrer?: string,
}

/** Changes user privacy settings */
export type setUserPrivacySettingRules = {
  readonly _: 'setUserPrivacySettingRules',
  /** The privacy setting */
  readonly setting?: UserPrivacySetting$Input,
  /** The new privacy rules */
  readonly rules?: userPrivacySettingRules$Input,
}

/** Returns the current privacy settings */
export type getUserPrivacySettingRules = {
  readonly _: 'getUserPrivacySettingRules',
  /** The privacy setting */
  readonly setting?: UserPrivacySetting$Input,
}

/**
 * Returns the value of an option by its name. (Check the list of available options
 * on https://core.telegram.org/tdlib/options.) Can be called before authorization
 */
export type getOption = {
  readonly _: 'getOption',
  /** The name of the option */
  readonly name?: string,
}

/**
 * Sets the value of an option. (Check the list of available options on https://core.telegram.org/tdlib/options.)
 * Only writable options can be set. Can be called before authorization
 */
export type setOption = {
  readonly _: 'setOption',
  /** The name of the option */
  readonly name?: string,
  /** The new value of the option; pass null to reset option value to a default value */
  readonly value?: OptionValue$Input,
}

/**
 * Changes the period of inactivity after which the account of the current user will
 * automatically be deleted
 */
export type setAccountTtl = {
  readonly _: 'setAccountTtl',
  /** New account TTL */
  readonly ttl?: accountTtl$Input,
}

/**
 * Returns the period of inactivity after which the account of the current user will
 * automatically be deleted
 */
export type getAccountTtl = {
  readonly _: 'getAccountTtl',
}

/**
 * Deletes the account of the current user, deleting all information associated with
 * the user from the server. The phone number of the account can be used to create a
 * new account. Can be called before authorization when the current authorization state
 * is authorizationStateWaitPassword
 */
export type deleteAccount = {
  readonly _: 'deleteAccount',
  /** The reason why the account was deleted; optional */
  readonly reason?: string,
}

/** Removes a chat action bar without any other action */
export type removeChatActionBar = {
  readonly _: 'removeChatActionBar',
  /** Chat identifier */
  readonly chat_id?: number,
}

/**
 * Reports a chat to the Telegram moderators. A chat can be reported only from the chat
 * action bar, or if chat.can_be_reported
 */
export type reportChat = {
  readonly _: 'reportChat',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Identifiers of reported messages, if any */
  readonly message_ids?: ReadonlyArray<number>,
  /** The reason for reporting the chat */
  readonly reason?: ChatReportReason$Input,
  /** Additional report details; 0-1024 characters */
  readonly text?: string,
}

/**
 * Reports a chat photo to the Telegram moderators. A chat photo can be reported only
 * if chat.can_be_reported
 */
export type reportChatPhoto = {
  readonly _: 'reportChatPhoto',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Identifier of the photo to report. Only full photos from chatPhoto can be reported */
  readonly file_id?: number,
  /** The reason for reporting the chat photo */
  readonly reason?: ChatReportReason$Input,
  /** Additional report details; 0-1024 characters */
  readonly text?: string,
}

/**
 * Returns detailed statistics about a chat. Currently, this method can be used only
 * for supergroups and channels. Can be used only if supergroupFullInfo.can_get_statistics
 * == true
 */
export type getChatStatistics = {
  readonly _: 'getChatStatistics',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Pass true if a dark theme is used by the application */
  readonly is_dark?: boolean,
}

/**
 * Returns detailed statistics about a message. Can be used only if message.can_get_statistics
 * == true
 */
export type getMessageStatistics = {
  readonly _: 'getMessageStatistics',
  /** Chat identifier */
  readonly chat_id?: number,
  /** Message identifier */
  readonly message_id?: number,
  /** Pass true if a dark theme is used by the application */
  readonly is_dark?: boolean,
}

/** Loads an asynchronous or a zoomed in statistical graph */
export type getStatisticalGraph = {
  readonly _: 'getStatisticalGraph',
  /** Chat identifier */
  readonly chat_id?: number,
  /** The token for graph loading */
  readonly token?: string,
  /** X-value for zoomed in graph or 0 otherwise */
  readonly x?: number,
}

/** Returns storage usage statistics. Can be called before authorization */
export type getStorageStatistics = {
  readonly _: 'getStorageStatistics',
  /**
   * The maximum number of chats with the largest storage usage for which separate statistics
   * need to be returned. All other chats will be grouped in entries with chat_id == 0.
   * If the chat info database is not used, the chat_limit is ignored and is always set
   * to 0
   */
  readonly chat_limit?: number,
}

/** Quickly returns approximate storage usage statistics. Can be called before authorization */
export type getStorageStatisticsFast = {
  readonly _: 'getStorageStatisticsFast',
}

/** Returns database statistics */
export type getDatabaseStatistics = {
  readonly _: 'getDatabaseStatistics',
}

/**
 * Optimizes storage usage, i.e. deletes some files and returns new storage usage statistics.
 * Secret thumbnails can't be deleted
 */
export type optimizeStorage = {
  readonly _: 'optimizeStorage',
  /**
   * Limit on the total size of files after deletion, in bytes. Pass -1 to use the default
   * limit
   */
  readonly size?: number,
  /**
   * Limit on the time that has passed since the last time a file was accessed (or creation
   * time for some filesystems). Pass -1 to use the default limit
   */
  readonly ttl?: number,
  /** Limit on the total count of files after deletion. Pass -1 to use the default limit */
  readonly count?: number,
  /**
   * The amount of time after the creation of a file during which it can't be deleted,
   * in seconds. Pass -1 to use the default value
   */
  readonly immunity_delay?: number,
  /**
   * If non-empty, only files with the given types are considered. By default, all types
   * except thumbnails, profile photos, stickers and wallpapers are deleted
   */
  readonly file_types?: ReadonlyArray<FileType$Input>,
  /**
   * If non-empty, only files from the given chats are considered. Use 0 as chat identifier
   * to delete files not belonging to any chat (e.g., profile photos)
   */
  readonly chat_ids?: ReadonlyArray<number>,
  /**
   * If non-empty, files from the given chats are excluded. Use 0 as chat identifier to
   * exclude all files not belonging to any chat (e.g., profile photos)
   */
  readonly exclude_chat_ids?: ReadonlyArray<number>,
  /**
   * Pass true if statistics about the files that were deleted must be returned instead
   * of the whole storage usage statistics. Affects only returned statistics
   */
  readonly return_deleted_file_statistics?: boolean,
  /** Same as in getStorageStatistics. Affects only returned statistics */
  readonly chat_limit?: number,
}

/**
 * Sets the current network type. Can be called before authorization. Calling this method
 * forces all network connections to reopen, mitigating the delay in switching between
 * different networks, so it must be called whenever the network is changed, even if
 * the network type remains the same. Network type is used to check whether the library
 * can use the network at all and also for collecting detailed network data usage statistics
 */
export type setNetworkType = {
  readonly _: 'setNetworkType',
  /** The new network type; pass null to set network type to networkTypeOther */
  readonly type?: NetworkType$Input,
}

/** Returns network data usage statistics. Can be called before authorization */
export type getNetworkStatistics = {
  readonly _: 'getNetworkStatistics',
  /** If true, returns only data for the current library launch */
  readonly only_current?: boolean,
}

/** Adds the specified data to data usage statistics. Can be called before authorization */
export type addNetworkStatistics = {
  readonly _: 'addNetworkStatistics',
  /** The network statistics entry with the data to be added to statistics */
  readonly entry?: NetworkStatisticsEntry$Input,
}

/** Resets all network data usage statistics to zero. Can be called before authorization */
export type resetNetworkStatistics = {
  readonly _: 'resetNetworkStatistics',
}

/** Returns auto-download settings presets for the current user */
export type getAutoDownloadSettingsPresets = {
  readonly _: 'getAutoDownloadSettingsPresets',
}

/** Sets auto-download settings */
export type setAutoDownloadSettings = {
  readonly _: 'setAutoDownloadSettings',
  /** New user auto-download settings */
  readonly settings?: autoDownloadSettings$Input,
  /** Type of the network for which the new settings are relevant */
  readonly type?: NetworkType$Input,
}

/** Returns information about a bank card */
export type getBankCardInfo = {
  readonly _: 'getBankCardInfo',
  /** The bank card number */
  readonly bank_card_number?: string,
}

/** Returns one of the available Telegram Passport elements */
export type getPassportElement = {
  readonly _: 'getPassportElement',
  /** Telegram Passport element type */
  readonly type?: PassportElementType$Input,
  /** Password of the current user */
  readonly password?: string,
}

/** Returns all available Telegram Passport elements */
export type getAllPassportElements = {
  readonly _: 'getAllPassportElements',
  /** Password of the current user */
  readonly password?: string,
}

/**
 * Adds an element to the user's Telegram Passport. May return an error with a message
 * "PHONE_VERIFICATION_NEEDED" or "EMAIL_VERIFICATION_NEEDED" if the chosen phone number
 * or the chosen email address must be verified first
 */
export type setPassportElement = {
  readonly _: 'setPassportElement',
  /** Input Telegram Passport element */
  readonly element?: InputPassportElement$Input,
  /** Password of the current user */
  readonly password?: string,
}

/** Deletes a Telegram Passport element */
export type deletePassportElement = {
  readonly _: 'deletePassportElement',
  /** Element type */
  readonly type?: PassportElementType$Input,
}

/**
 * Informs the user that some of the elements in their Telegram Passport contain errors;
 * for bots only. The user will not be able to resend the elements, until the errors
 * are fixed
 */
export type setPassportElementErrors = {
  readonly _: 'setPassportElementErrors',
  /** User identifier */
  readonly user_id?: number,
  /** The errors */
  readonly errors?: ReadonlyArray<inputPassportElementError$Input>,
}

/**
 * Returns an IETF language tag of the language preferred in the country, which must
 * be used to fill native fields in Telegram Passport personal details. Returns a 404
 * error if unknown
 */
export type getPreferredCountryLanguage = {
  readonly _: 'getPreferredCountryLanguage',
  /** A two-letter ISO 3166-1 alpha-2 country code */
  readonly country_code?: string,
}

/** Sends a code to verify a phone number to be added to a user's Telegram Passport */
export type sendPhoneNumberVerificationCode = {
  readonly _: 'sendPhoneNumberVerificationCode',
  /** The phone number of the user, in international format */
  readonly phone_number?: string,
  /**
   * Settings for the authentication of the user's phone number; pass null to use default
   * settings
   */
  readonly settings?: phoneNumberAuthenticationSettings$Input,
}

/** Re-sends the code to verify a phone number to be added to a user's Telegram Passport */
export type resendPhoneNumberVerificationCode = {
  readonly _: 'resendPhoneNumberVerificationCode',
}

/** Checks the phone number verification code for Telegram Passport */
export type checkPhoneNumberVerificationCode = {
  readonly _: 'checkPhoneNumberVerificationCode',
  /** Verification code to check */
  readonly code?: string,
}

/** Sends a code to verify an email address to be added to a user's Telegram Passport */
export type sendEmailAddressVerificationCode = {
  readonly _: 'sendEmailAddressVerificationCode',
  /** Email address */
  readonly email_address?: string,
}

/** Re-sends the code to verify an email address to be added to a user's Telegram Passport */
export type resendEmailAddressVerificationCode = {
  readonly _: 'resendEmailAddressVerificationCode',
}

/** Checks the email address verification code for Telegram Passport */
export type checkEmailAddressVerificationCode = {
  readonly _: 'checkEmailAddressVerificationCode',
  /** Verification code to check */
  readonly code?: string,
}

/** Returns a Telegram Passport authorization form for sharing data with a service */
export type getPassportAuthorizationForm = {
  readonly _: 'getPassportAuthorizationForm',
  /** User identifier of the service's bot */
  readonly bot_user_id?: number,
  /** Telegram Passport element types requested by the service */
  readonly scope?: string,
  /** Service's public key */
  readonly public_key?: string,
  /** Unique request identifier provided by the service */
  readonly nonce?: string,
}

/**
 * Returns already available Telegram Passport elements suitable for completing a Telegram
 * Passport authorization form. Result can be received only once for each authorization
 * form
 */
export type getPassportAuthorizationFormAvailableElements = {
  readonly _: 'getPassportAuthorizationFormAvailableElements',
  /** Authorization form identifier */
  readonly autorization_form_id?: number,
  /** Password of the current user */
  readonly password?: string,
}

/**
 * Sends a Telegram Passport authorization form, effectively sharing data with the service.
 * This method must be called after getPassportAuthorizationFormAvailableElements if
 * some previously available elements are going to be reused
 */
export type sendPassportAuthorizationForm = {
  readonly _: 'sendPassportAuthorizationForm',
  /** Authorization form identifier */
  readonly autorization_form_id?: number,
  /**
   * Types of Telegram Passport elements chosen by user to complete the authorization
   * form
   */
  readonly types?: ReadonlyArray<PassportElementType$Input>,
}

/** Sends phone number confirmation code to handle links of the type internalLinkTypePhoneNumberConfirmation */
export type sendPhoneNumberConfirmationCode = {
  readonly _: 'sendPhoneNumberConfirmationCode',
  /** Hash value from the link */
  readonly hash?: string,
  /** Phone number value from the link */
  readonly phone_number?: string,
  /**
   * Settings for the authentication of the user's phone number; pass null to use default
   * settings
   */
  readonly settings?: phoneNumberAuthenticationSettings$Input,
}

/** Resends phone number confirmation code */
export type resendPhoneNumberConfirmationCode = {
  readonly _: 'resendPhoneNumberConfirmationCode',
}

/** Checks phone number confirmation code */
export type checkPhoneNumberConfirmationCode = {
  readonly _: 'checkPhoneNumberConfirmationCode',
  /** Confirmation code to check */
  readonly code?: string,
}

/**
 * Informs the server about the number of pending bot updates if they haven't been processed
 * for a long time; for bots only
 */
export type setBotUpdatesStatus = {
  readonly _: 'setBotUpdatesStatus',
  /** The number of pending updates */
  readonly pending_update_count?: number,
  /** The last error message */
  readonly error_message?: string,
}

/** Uploads a file with a sticker; returns the uploaded file */
export type uploadStickerFile = {
  readonly _: 'uploadStickerFile',
  /** Sticker file owner; ignored for regular users */
  readonly user_id?: number,
  /** Sticker file to upload */
  readonly sticker?: InputSticker$Input,
}

/** Returns a suggested name for a new sticker set with a given title */
export type getSuggestedStickerSetName = {
  readonly _: 'getSuggestedStickerSetName',
  /** Sticker set title; 1-64 characters */
  readonly title?: string,
}

/** Checks whether a name can be used for a new sticker set */
export type checkStickerSetName = {
  readonly _: 'checkStickerSetName',
  /** Name to be checked */
  readonly name?: string,
}

/** Creates a new sticker set. Returns the newly created sticker set */
export type createNewStickerSet = {
  readonly _: 'createNewStickerSet',
  /** Sticker set owner; ignored for regular users */
  readonly user_id?: number,
  /** Sticker set title; 1-64 characters */
  readonly title?: string,
  /**
   * Sticker set name. Can contain only English letters, digits and underscores. Must
   * end with *"_by_<bot username>"* (*<bot_username>* is case insensitive) for bots;
   * 1-64 characters
   */
  readonly name?: string,
  /** True, if stickers are masks. Animated stickers can't be masks */
  readonly is_masks?: boolean,
  /**
   * List of stickers to be added to the set; must be non-empty. All stickers must be
   * of the same type. For animated stickers, uploadStickerFile must be used before the
   * sticker is shown
   */
  readonly stickers?: ReadonlyArray<InputSticker$Input>,
  /** Source of the sticker set; may be empty if unknown */
  readonly source?: string,
}

/** Adds a new sticker to a set; for bots only. Returns the sticker set */
export type addStickerToSet = {
  readonly _: 'addStickerToSet',
  /** Sticker set owner */
  readonly user_id?: number,
  /** Sticker set name */
  readonly name?: string,
  /** Sticker to add to the set */
  readonly sticker?: InputSticker$Input,
}

/** Sets a sticker set thumbnail; for bots only. Returns the sticker set */
export type setStickerSetThumbnail = {
  readonly _: 'setStickerSetThumbnail',
  /** Sticker set owner */
  readonly user_id?: number,
  /** Sticker set name */
  readonly name?: string,
  /**
   * Thumbnail to set in PNG or TGS format; pass null to remove the sticker set thumbnail.
   * Animated thumbnail must be set for animated sticker sets and only for them
   */
  readonly thumbnail?: InputFile$Input,
}

/**
 * Changes the position of a sticker in the set to which it belongs; for bots only.
 * The sticker set must have been created by the bot
 */
export type setStickerPositionInSet = {
  readonly _: 'setStickerPositionInSet',
  /** Sticker */
  readonly sticker?: InputFile$Input,
  /** New position of the sticker in the set, zero-based */
  readonly position?: number,
}

/**
 * Removes a sticker from the set to which it belongs; for bots only. The sticker set
 * must have been created by the bot
 */
export type removeStickerFromSet = {
  readonly _: 'removeStickerFromSet',
  /** Sticker */
  readonly sticker?: InputFile$Input,
}

/**
 * Returns information about a file with a map thumbnail in PNG format. Only map thumbnail
 * files with size less than 1MB can be downloaded
 */
export type getMapThumbnailFile = {
  readonly _: 'getMapThumbnailFile',
  /** Location of the map center */
  readonly location?: location$Input,
  /** Map zoom level; 13-20 */
  readonly zoom?: number,
  /** Map width in pixels before applying scale; 16-1024 */
  readonly width?: number,
  /** Map height in pixels before applying scale; 16-1024 */
  readonly height?: number,
  /** Map scale; 1-3 */
  readonly scale?: number,
  /** Identifier of a chat, in which the thumbnail will be shown. Use 0 if unknown */
  readonly chat_id?: number,
}

/** Accepts Telegram terms of services */
export type acceptTermsOfService = {
  readonly _: 'acceptTermsOfService',
  /** Terms of service identifier */
  readonly terms_of_service_id?: string,
}

/** Sends a custom request; for bots only */
export type sendCustomRequest = {
  readonly _: 'sendCustomRequest',
  /** The method name */
  readonly method?: string,
  /** JSON-serialized method parameters */
  readonly parameters?: string,
}

/** Answers a custom query; for bots only */
export type answerCustomQuery = {
  readonly _: 'answerCustomQuery',
  /** Identifier of a custom query */
  readonly custom_query_id?: number | string,
  /** JSON-serialized answer to the query */
  readonly data?: string,
}

/** Succeeds after a specified amount of time has passed. Can be called before initialization */
export type setAlarm = {
  readonly _: 'setAlarm',
  /** Number of seconds before the function returns */
  readonly seconds?: number,
}

/** Returns information about existing countries. Can be called before authorization */
export type getCountries = {
  readonly _: 'getCountries',
}

/**
 * Uses the current IP address to find the current country. Returns two-letter ISO 3166-1
 * alpha-2 country code. Can be called before authorization
 */
export type getCountryCode = {
  readonly _: 'getCountryCode',
}

/** Returns information about a phone number by its prefix. Can be called before authorization */
export type getPhoneNumberInfo = {
  readonly _: 'getPhoneNumberInfo',
  /** The phone number prefix */
  readonly phone_number_prefix?: string,
}

/**
 * Returns information about a phone number by its prefix synchronously. getCountries
 * must be called at least once after changing localization to the specified language
 * if properly localized country information is expected. Can be called synchronously
 */
export type getPhoneNumberInfoSync = {
  readonly _: 'getPhoneNumberInfoSync',
  /** A two-letter ISO 639-1 country code for country information localization */
  readonly language_code?: string,
  /** The phone number prefix */
  readonly phone_number_prefix?: string,
}

/**
 * Returns the link for downloading official Telegram application to be used when the
 * current user invites friends to Telegram
 */
export type getApplicationDownloadLink = {
  readonly _: 'getApplicationDownloadLink',
}

/**
 * Returns information about a tg:// deep link. Use "tg://need_update_for_some_feature"
 * or "tg:some_unsupported_feature" for testing. Returns a 404 error for unknown links.
 * Can be called before authorization
 */
export type getDeepLinkInfo = {
  readonly _: 'getDeepLinkInfo',
  /** The link */
  readonly link?: string,
}

/** Returns application config, provided by the server. Can be called before authorization */
export type getApplicationConfig = {
  readonly _: 'getApplicationConfig',
}

/** Saves application log event on the server. Can be called before authorization */
export type saveApplicationLogEvent = {
  readonly _: 'saveApplicationLogEvent',
  /** Event type */
  readonly type?: string,
  /** Optional chat identifier, associated with the event */
  readonly chat_id?: number,
  /** The log event data */
  readonly data?: JsonValue$Input,
}

/** Adds a proxy server for network requests. Can be called before authorization */
export type addProxy = {
  readonly _: 'addProxy',
  /** Proxy server IP address */
  readonly server?: string,
  /** Proxy server port */
  readonly port?: number,
  /** True, if the proxy needs to be enabled */
  readonly enable?: boolean,
  /** Proxy type */
  readonly type?: ProxyType$Input,
}

/** Edits an existing proxy server for network requests. Can be called before authorization */
export type editProxy = {
  readonly _: 'editProxy',
  /** Proxy identifier */
  readonly proxy_id?: number,
  /** Proxy server IP address */
  readonly server?: string,
  /** Proxy server port */
  readonly port?: number,
  /** True, if the proxy needs to be enabled */
  readonly enable?: boolean,
  /** Proxy type */
  readonly type?: ProxyType$Input,
}

/** Enables a proxy. Only one proxy can be enabled at a time. Can be called before authorization */
export type enableProxy = {
  readonly _: 'enableProxy',
  /** Proxy identifier */
  readonly proxy_id?: number,
}

/** Disables the currently enabled proxy. Can be called before authorization */
export type disableProxy = {
  readonly _: 'disableProxy',
}

/** Removes a proxy server. Can be called before authorization */
export type removeProxy = {
  readonly _: 'removeProxy',
  /** Proxy identifier */
  readonly proxy_id?: number,
}

/** Returns list of proxies that are currently set up. Can be called before authorization */
export type getProxies = {
  readonly _: 'getProxies',
}

/**
 * Returns an HTTPS link, which can be used to add a proxy. Available only for SOCKS5
 * and MTProto proxies. Can be called before authorization
 */
export type getProxyLink = {
  readonly _: 'getProxyLink',
  /** Proxy identifier */
  readonly proxy_id?: number,
}

/**
 * Computes time needed to receive a response from a Telegram server through a proxy.
 * Can be called before authorization
 */
export type pingProxy = {
  readonly _: 'pingProxy',
  /** Proxy identifier. Use 0 to ping a Telegram server without a proxy */
  readonly proxy_id?: number,
}

/** Sets new log stream for internal logging of TDLib. Can be called synchronously */
export type setLogStream = {
  readonly _: 'setLogStream',
  /** New log stream */
  readonly log_stream?: LogStream$Input,
}

/**
 * Returns information about currently used log stream for internal logging of TDLib.
 * Can be called synchronously
 */
export type getLogStream = {
  readonly _: 'getLogStream',
}

/** Sets the verbosity level of the internal logging of TDLib. Can be called synchronously */
export type setLogVerbosityLevel = {
  readonly _: 'setLogVerbosityLevel',
  /**
   * New value of the verbosity level for logging. Value 0 corresponds to fatal errors,
   * value 1 corresponds to errors, value 2 corresponds to warnings and debug warnings,
   * value 3 corresponds to informational, value 4 corresponds to debug, value 5 corresponds
   * to verbose debug, value greater than 5 and up to 1023 can be used to enable even
   * more logging
   */
  readonly new_verbosity_level?: number,
}

/** Returns current verbosity level of the internal logging of TDLib. Can be called synchronously */
export type getLogVerbosityLevel = {
  readonly _: 'getLogVerbosityLevel',
}

/**
 * Returns list of available TDLib internal log tags, for example, ["actor", "binlog",
 * "connections", "notifications", "proxy"]. Can be called synchronously
 */
export type getLogTags = {
  readonly _: 'getLogTags',
}

/** Sets the verbosity level for a specified TDLib internal log tag. Can be called synchronously */
export type setLogTagVerbosityLevel = {
  readonly _: 'setLogTagVerbosityLevel',
  /** Logging tag to change verbosity level */
  readonly tag?: string,
  /** New verbosity level; 1-1024 */
  readonly new_verbosity_level?: number,
}

/**
 * Returns current verbosity level for a specified TDLib internal log tag. Can be called
 * synchronously
 */
export type getLogTagVerbosityLevel = {
  readonly _: 'getLogTagVerbosityLevel',
  /** Logging tag to change verbosity level */
  readonly tag?: string,
}

/** Adds a message to TDLib internal log. Can be called synchronously */
export type addLogMessage = {
  readonly _: 'addLogMessage',
  /** The minimum verbosity level needed for the message to be logged; 0-1023 */
  readonly verbosity_level?: number,
  /** Text of a message to log */
  readonly text?: string,
}

/** Does nothing; for testing only. This is an offline method. Can be called before authorization */
export type testCallEmpty = {
  readonly _: 'testCallEmpty',
}

/**
 * Returns the received string; for testing only. This is an offline method. Can be
 * called before authorization
 */
export type testCallString = {
  readonly _: 'testCallString',
  /** String to return */
  readonly x?: string,
}

/**
 * Returns the received bytes; for testing only. This is an offline method. Can be called
 * before authorization
 */
export type testCallBytes = {
  readonly _: 'testCallBytes',
  /** Bytes to return */
  readonly x?: string,
}

/**
 * Returns the received vector of numbers; for testing only. This is an offline method.
 * Can be called before authorization
 */
export type testCallVectorInt = {
  readonly _: 'testCallVectorInt',
  /** Vector of numbers to return */
  readonly x?: ReadonlyArray<number>,
}

/**
 * Returns the received vector of objects containing a number; for testing only. This
 * is an offline method. Can be called before authorization
 */
export type testCallVectorIntObject = {
  readonly _: 'testCallVectorIntObject',
  /** Vector of objects to return */
  readonly x?: ReadonlyArray<testInt$Input>,
}

/**
 * Returns the received vector of strings; for testing only. This is an offline method.
 * Can be called before authorization
 */
export type testCallVectorString = {
  readonly _: 'testCallVectorString',
  /** Vector of strings to return */
  readonly x?: ReadonlyArray<string>,
}

/**
 * Returns the received vector of objects containing a string; for testing only. This
 * is an offline method. Can be called before authorization
 */
export type testCallVectorStringObject = {
  readonly _: 'testCallVectorStringObject',
  /** Vector of objects to return */
  readonly x?: ReadonlyArray<testString$Input>,
}

/**
 * Returns the squared received number; for testing only. This is an offline method.
 * Can be called before authorization
 */
export type testSquareInt = {
  readonly _: 'testSquareInt',
  /** Number to square */
  readonly x?: number,
}

/**
 * Sends a simple network request to the Telegram servers; for testing only. Can be
 * called before authorization
 */
export type testNetwork = {
  readonly _: 'testNetwork',
}

/**
 * Sends a simple network request to the Telegram servers via proxy; for testing only.
 * Can be called before authorization
 */
export type testProxy = {
  readonly _: 'testProxy',
  /** Proxy server IP address */
  readonly server?: string,
  /** Proxy server port */
  readonly port?: number,
  /** Proxy type */
  readonly type?: ProxyType$Input,
  /** Identifier of a datacenter, with which to test connection */
  readonly dc_id?: number,
  /** The maximum overall timeout for the request */
  readonly timeout?: number,
}

/** Forces an updates.getDifference call to the Telegram servers; for testing only */
export type testGetDifference = {
  readonly _: 'testGetDifference',
}

/**
 * Does nothing and ensures that the Update object is used; for testing only. This is
 * an offline method. Can be called before authorization
 */
export type testUseUpdate = {
  readonly _: 'testUseUpdate',
}

/**
 * Returns the specified error and ensures that the Error object is used; for testing
 * only. Can be called synchronously
 */
export type testReturnError = {
  readonly _: 'testReturnError',
  /** The error to be returned */
  readonly error?: error$Input,
}

// ----

export type Error =
  | error

export type Error$Input =
  | error$Input

export type Ok =
  | ok

export type Ok$Input =
  | ok$Input

export type TdlibParameters =
  | tdlibParameters

export type TdlibParameters$Input =
  | tdlibParameters$Input

/**
 * Provides information about the method by which an authentication code is delivered
 * to the user
 */
export type AuthenticationCodeType =
  | authenticationCodeTypeTelegramMessage
  | authenticationCodeTypeSms
  | authenticationCodeTypeCall
  | authenticationCodeTypeFlashCall
  | authenticationCodeTypeMissedCall

/**
 * Provides information about the method by which an authentication code is delivered
 * to the user
 */
export type AuthenticationCodeType$Input =
  | authenticationCodeTypeTelegramMessage$Input
  | authenticationCodeTypeSms$Input
  | authenticationCodeTypeCall$Input
  | authenticationCodeTypeFlashCall$Input
  | authenticationCodeTypeMissedCall$Input

export type AuthenticationCodeInfo =
  | authenticationCodeInfo

export type AuthenticationCodeInfo$Input =
  | authenticationCodeInfo$Input

export type EmailAddressAuthenticationCodeInfo =
  | emailAddressAuthenticationCodeInfo

export type EmailAddressAuthenticationCodeInfo$Input =
  | emailAddressAuthenticationCodeInfo$Input

export type TextEntity =
  | textEntity

export type TextEntity$Input =
  | textEntity$Input

export type TextEntities =
  | textEntities

export type TextEntities$Input =
  | textEntities$Input

export type FormattedText =
  | formattedText

export type FormattedText$Input =
  | formattedText$Input

export type TermsOfService =
  | termsOfService

export type TermsOfService$Input =
  | termsOfService$Input

/** Represents the current authorization state of the TDLib client */
export type AuthorizationState =
  | authorizationStateWaitTdlibParameters
  | authorizationStateWaitEncryptionKey
  | authorizationStateWaitPhoneNumber
  | authorizationStateWaitCode
  | authorizationStateWaitOtherDeviceConfirmation
  | authorizationStateWaitRegistration
  | authorizationStateWaitPassword
  | authorizationStateReady
  | authorizationStateLoggingOut
  | authorizationStateClosing
  | authorizationStateClosed

/** Represents the current authorization state of the TDLib client */
export type AuthorizationState$Input =
  | authorizationStateWaitTdlibParameters$Input
  | authorizationStateWaitEncryptionKey$Input
  | authorizationStateWaitPhoneNumber$Input
  | authorizationStateWaitCode$Input
  | authorizationStateWaitOtherDeviceConfirmation$Input
  | authorizationStateWaitRegistration$Input
  | authorizationStateWaitPassword$Input
  | authorizationStateReady$Input
  | authorizationStateLoggingOut$Input
  | authorizationStateClosing$Input
  | authorizationStateClosed$Input

export type PasswordState =
  | passwordState

export type PasswordState$Input =
  | passwordState$Input

export type RecoveryEmailAddress =
  | recoveryEmailAddress

export type RecoveryEmailAddress$Input =
  | recoveryEmailAddress$Input

export type TemporaryPasswordState =
  | temporaryPasswordState

export type TemporaryPasswordState$Input =
  | temporaryPasswordState$Input

export type LocalFile =
  | localFile

export type LocalFile$Input =
  | localFile$Input

export type RemoteFile =
  | remoteFile

export type RemoteFile$Input =
  | remoteFile$Input

export type File =
  | file

export type File$Input =
  | file$Input

/** Points to a file */
export type InputFile =
  | inputFileId
  | inputFileRemote
  | inputFileLocal
  | inputFileGenerated

/** Points to a file */
export type InputFile$Input =
  | inputFileId$Input
  | inputFileRemote$Input
  | inputFileLocal$Input
  | inputFileGenerated$Input

export type PhotoSize =
  | photoSize

export type PhotoSize$Input =
  | photoSize$Input

export type Minithumbnail =
  | minithumbnail

export type Minithumbnail$Input =
  | minithumbnail$Input

/** Describes format of the thumbnail */
export type ThumbnailFormat =
  | thumbnailFormatJpeg
  | thumbnailFormatPng
  | thumbnailFormatWebp
  | thumbnailFormatGif
  | thumbnailFormatTgs
  | thumbnailFormatMpeg4

/** Describes format of the thumbnail */
export type ThumbnailFormat$Input =
  | thumbnailFormatJpeg$Input
  | thumbnailFormatPng$Input
  | thumbnailFormatWebp$Input
  | thumbnailFormatGif$Input
  | thumbnailFormatTgs$Input
  | thumbnailFormatMpeg4$Input

export type Thumbnail =
  | thumbnail

export type Thumbnail$Input =
  | thumbnail$Input

/** Part of the face, relative to which a mask is placed */
export type MaskPoint =
  | maskPointForehead
  | maskPointEyes
  | maskPointMouth
  | maskPointChin

/** Part of the face, relative to which a mask is placed */
export type MaskPoint$Input =
  | maskPointForehead$Input
  | maskPointEyes$Input
  | maskPointMouth$Input
  | maskPointChin$Input

export type MaskPosition =
  | maskPosition

export type MaskPosition$Input =
  | maskPosition$Input

export type ClosedVectorPath =
  | closedVectorPath

export type ClosedVectorPath$Input =
  | closedVectorPath$Input

export type PollOption =
  | pollOption

export type PollOption$Input =
  | pollOption$Input

/** Describes the type of a poll */
export type PollType =
  | pollTypeRegular
  | pollTypeQuiz

/** Describes the type of a poll */
export type PollType$Input =
  | pollTypeRegular$Input
  | pollTypeQuiz$Input

export type Animation =
  | animation

export type Animation$Input =
  | animation$Input

export type Audio =
  | audio

export type Audio$Input =
  | audio$Input

export type Document =
  | document

export type Document$Input =
  | document$Input

export type Photo =
  | photo

export type Photo$Input =
  | photo$Input

export type Sticker =
  | sticker

export type Sticker$Input =
  | sticker$Input

export type Video =
  | video

export type Video$Input =
  | video$Input

export type VideoNote =
  | videoNote

export type VideoNote$Input =
  | videoNote$Input

export type VoiceNote =
  | voiceNote

export type VoiceNote$Input =
  | voiceNote$Input

export type AnimatedEmoji =
  | animatedEmoji

export type AnimatedEmoji$Input =
  | animatedEmoji$Input

export type Contact =
  | contact

export type Contact$Input =
  | contact$Input

export type Location =
  | location

export type Location$Input =
  | location$Input

export type Venue =
  | venue

export type Venue$Input =
  | venue$Input

export type Game =
  | game

export type Game$Input =
  | game$Input

export type Poll =
  | poll

export type Poll$Input =
  | poll$Input

export type ProfilePhoto =
  | profilePhoto

export type ProfilePhoto$Input =
  | profilePhoto$Input

export type ChatPhotoInfo =
  | chatPhotoInfo

export type ChatPhotoInfo$Input =
  | chatPhotoInfo$Input

/**
 * Represents the type of a user. The following types are possible: regular users, deleted
 * users and bots
 */
export type UserType =
  | userTypeRegular
  | userTypeDeleted
  | userTypeBot
  | userTypeUnknown

/**
 * Represents the type of a user. The following types are possible: regular users, deleted
 * users and bots
 */
export type UserType$Input =
  | userTypeRegular$Input
  | userTypeDeleted$Input
  | userTypeBot$Input
  | userTypeUnknown$Input

export type BotCommand =
  | botCommand

export type BotCommand$Input =
  | botCommand$Input

export type BotCommands =
  | botCommands

export type BotCommands$Input =
  | botCommands$Input

export type ChatLocation =
  | chatLocation

export type ChatLocation$Input =
  | chatLocation$Input

export type AnimatedChatPhoto =
  | animatedChatPhoto

export type AnimatedChatPhoto$Input =
  | animatedChatPhoto$Input

export type ChatPhoto =
  | chatPhoto

export type ChatPhoto$Input =
  | chatPhoto$Input

export type ChatPhotos =
  | chatPhotos

export type ChatPhotos$Input =
  | chatPhotos$Input

/** Describes a photo to be set as a user profile or chat photo */
export type InputChatPhoto =
  | inputChatPhotoPrevious
  | inputChatPhotoStatic
  | inputChatPhotoAnimation

/** Describes a photo to be set as a user profile or chat photo */
export type InputChatPhoto$Input =
  | inputChatPhotoPrevious$Input
  | inputChatPhotoStatic$Input
  | inputChatPhotoAnimation$Input

export type User =
  | user

export type User$Input =
  | user$Input

export type UserFullInfo =
  | userFullInfo

export type UserFullInfo$Input =
  | userFullInfo$Input

export type Users =
  | users

export type Users$Input =
  | users$Input

export type ChatAdministrator =
  | chatAdministrator

export type ChatAdministrator$Input =
  | chatAdministrator$Input

export type ChatAdministrators =
  | chatAdministrators

export type ChatAdministrators$Input =
  | chatAdministrators$Input

export type ChatPermissions =
  | chatPermissions

export type ChatPermissions$Input =
  | chatPermissions$Input

/** Provides information about the status of a member in a chat */
export type ChatMemberStatus =
  | chatMemberStatusCreator
  | chatMemberStatusAdministrator
  | chatMemberStatusMember
  | chatMemberStatusRestricted
  | chatMemberStatusLeft
  | chatMemberStatusBanned

/** Provides information about the status of a member in a chat */
export type ChatMemberStatus$Input =
  | chatMemberStatusCreator$Input
  | chatMemberStatusAdministrator$Input
  | chatMemberStatusMember$Input
  | chatMemberStatusRestricted$Input
  | chatMemberStatusLeft$Input
  | chatMemberStatusBanned$Input

export type ChatMember =
  | chatMember

export type ChatMember$Input =
  | chatMember$Input

export type ChatMembers =
  | chatMembers

export type ChatMembers$Input =
  | chatMembers$Input

/** Specifies the kind of chat members to return in searchChatMembers */
export type ChatMembersFilter =
  | chatMembersFilterContacts
  | chatMembersFilterAdministrators
  | chatMembersFilterMembers
  | chatMembersFilterMention
  | chatMembersFilterRestricted
  | chatMembersFilterBanned
  | chatMembersFilterBots

/** Specifies the kind of chat members to return in searchChatMembers */
export type ChatMembersFilter$Input =
  | chatMembersFilterContacts$Input
  | chatMembersFilterAdministrators$Input
  | chatMembersFilterMembers$Input
  | chatMembersFilterMention$Input
  | chatMembersFilterRestricted$Input
  | chatMembersFilterBanned$Input
  | chatMembersFilterBots$Input

/** Specifies the kind of chat members to return in getSupergroupMembers */
export type SupergroupMembersFilter =
  | supergroupMembersFilterRecent
  | supergroupMembersFilterContacts
  | supergroupMembersFilterAdministrators
  | supergroupMembersFilterSearch
  | supergroupMembersFilterRestricted
  | supergroupMembersFilterBanned
  | supergroupMembersFilterMention
  | supergroupMembersFilterBots

/** Specifies the kind of chat members to return in getSupergroupMembers */
export type SupergroupMembersFilter$Input =
  | supergroupMembersFilterRecent$Input
  | supergroupMembersFilterContacts$Input
  | supergroupMembersFilterAdministrators$Input
  | supergroupMembersFilterSearch$Input
  | supergroupMembersFilterRestricted$Input
  | supergroupMembersFilterBanned$Input
  | supergroupMembersFilterMention$Input
  | supergroupMembersFilterBots$Input

export type ChatInviteLink =
  | chatInviteLink

export type ChatInviteLink$Input =
  | chatInviteLink$Input

export type ChatInviteLinks =
  | chatInviteLinks

export type ChatInviteLinks$Input =
  | chatInviteLinks$Input

export type ChatInviteLinkCount =
  | chatInviteLinkCount

export type ChatInviteLinkCount$Input =
  | chatInviteLinkCount$Input

export type ChatInviteLinkCounts =
  | chatInviteLinkCounts

export type ChatInviteLinkCounts$Input =
  | chatInviteLinkCounts$Input

export type ChatInviteLinkMember =
  | chatInviteLinkMember

export type ChatInviteLinkMember$Input =
  | chatInviteLinkMember$Input

export type ChatInviteLinkMembers =
  | chatInviteLinkMembers

export type ChatInviteLinkMembers$Input =
  | chatInviteLinkMembers$Input

export type ChatInviteLinkInfo =
  | chatInviteLinkInfo

export type ChatInviteLinkInfo$Input =
  | chatInviteLinkInfo$Input

export type ChatJoinRequest =
  | chatJoinRequest

export type ChatJoinRequest$Input =
  | chatJoinRequest$Input

export type ChatJoinRequests =
  | chatJoinRequests

export type ChatJoinRequests$Input =
  | chatJoinRequests$Input

export type ChatJoinRequestsInfo =
  | chatJoinRequestsInfo

export type ChatJoinRequestsInfo$Input =
  | chatJoinRequestsInfo$Input

export type BasicGroup =
  | basicGroup

export type BasicGroup$Input =
  | basicGroup$Input

export type BasicGroupFullInfo =
  | basicGroupFullInfo

export type BasicGroupFullInfo$Input =
  | basicGroupFullInfo$Input

export type Supergroup =
  | supergroup

export type Supergroup$Input =
  | supergroup$Input

export type SupergroupFullInfo =
  | supergroupFullInfo

export type SupergroupFullInfo$Input =
  | supergroupFullInfo$Input

/** Describes the current secret chat state */
export type SecretChatState =
  | secretChatStatePending
  | secretChatStateReady
  | secretChatStateClosed

/** Describes the current secret chat state */
export type SecretChatState$Input =
  | secretChatStatePending$Input
  | secretChatStateReady$Input
  | secretChatStateClosed$Input

export type SecretChat =
  | secretChat

export type SecretChat$Input =
  | secretChat$Input

/** Contains information about the sender of a message */
export type MessageSender =
  | messageSenderUser
  | messageSenderChat

/** Contains information about the sender of a message */
export type MessageSender$Input =
  | messageSenderUser$Input
  | messageSenderChat$Input

export type MessageSenders =
  | messageSenders

export type MessageSenders$Input =
  | messageSenders$Input

/** Contains information about the origin of a forwarded message */
export type MessageForwardOrigin =
  | messageForwardOriginUser
  | messageForwardOriginChat
  | messageForwardOriginHiddenUser
  | messageForwardOriginChannel
  | messageForwardOriginMessageImport

/** Contains information about the origin of a forwarded message */
export type MessageForwardOrigin$Input =
  | messageForwardOriginUser$Input
  | messageForwardOriginChat$Input
  | messageForwardOriginHiddenUser$Input
  | messageForwardOriginChannel$Input
  | messageForwardOriginMessageImport$Input

export type MessageForwardInfo =
  | messageForwardInfo

export type MessageForwardInfo$Input =
  | messageForwardInfo$Input

export type MessageReplyInfo =
  | messageReplyInfo

export type MessageReplyInfo$Input =
  | messageReplyInfo$Input

export type MessageInteractionInfo =
  | messageInteractionInfo

export type MessageInteractionInfo$Input =
  | messageInteractionInfo$Input

/** Contains information about the sending state of the message */
export type MessageSendingState =
  | messageSendingStatePending
  | messageSendingStateFailed

/** Contains information about the sending state of the message */
export type MessageSendingState$Input =
  | messageSendingStatePending$Input
  | messageSendingStateFailed$Input

export type Message =
  | message

export type Message$Input =
  | message$Input

export type Messages =
  | messages

export type Messages$Input =
  | messages$Input

export type FoundMessages =
  | foundMessages

export type FoundMessages$Input =
  | foundMessages$Input

export type MessagePosition =
  | messagePosition

export type MessagePosition$Input =
  | messagePosition$Input

export type MessagePositions =
  | messagePositions

export type MessagePositions$Input =
  | messagePositions$Input

export type MessageCalendarDay =
  | messageCalendarDay

export type MessageCalendarDay$Input =
  | messageCalendarDay$Input

export type MessageCalendar =
  | messageCalendar

export type MessageCalendar$Input =
  | messageCalendar$Input

export type SponsoredMessage =
  | sponsoredMessage

export type SponsoredMessage$Input =
  | sponsoredMessage$Input

/** Describes the types of chats to which notification settings are relevant */
export type NotificationSettingsScope =
  | notificationSettingsScopePrivateChats
  | notificationSettingsScopeGroupChats
  | notificationSettingsScopeChannelChats

/** Describes the types of chats to which notification settings are relevant */
export type NotificationSettingsScope$Input =
  | notificationSettingsScopePrivateChats$Input
  | notificationSettingsScopeGroupChats$Input
  | notificationSettingsScopeChannelChats$Input

export type ChatNotificationSettings =
  | chatNotificationSettings

export type ChatNotificationSettings$Input =
  | chatNotificationSettings$Input

export type ScopeNotificationSettings =
  | scopeNotificationSettings

export type ScopeNotificationSettings$Input =
  | scopeNotificationSettings$Input

export type DraftMessage =
  | draftMessage

export type DraftMessage$Input =
  | draftMessage$Input

/** Describes the type of a chat */
export type ChatType =
  | chatTypePrivate
  | chatTypeBasicGroup
  | chatTypeSupergroup
  | chatTypeSecret

/** Describes the type of a chat */
export type ChatType$Input =
  | chatTypePrivate$Input
  | chatTypeBasicGroup$Input
  | chatTypeSupergroup$Input
  | chatTypeSecret$Input

export type ChatFilter =
  | chatFilter

export type ChatFilter$Input =
  | chatFilter$Input

export type ChatFilterInfo =
  | chatFilterInfo

export type ChatFilterInfo$Input =
  | chatFilterInfo$Input

export type RecommendedChatFilter =
  | recommendedChatFilter

export type RecommendedChatFilter$Input =
  | recommendedChatFilter$Input

export type RecommendedChatFilters =
  | recommendedChatFilters

export type RecommendedChatFilters$Input =
  | recommendedChatFilters$Input

/** Describes a list of chats */
export type ChatList =
  | chatListMain
  | chatListArchive
  | chatListFilter

/** Describes a list of chats */
export type ChatList$Input =
  | chatListMain$Input
  | chatListArchive$Input
  | chatListFilter$Input

export type ChatLists =
  | chatLists

export type ChatLists$Input =
  | chatLists$Input

/** Describes a reason why an external chat is shown in a chat list */
export type ChatSource =
  | chatSourceMtprotoProxy
  | chatSourcePublicServiceAnnouncement

/** Describes a reason why an external chat is shown in a chat list */
export type ChatSource$Input =
  | chatSourceMtprotoProxy$Input
  | chatSourcePublicServiceAnnouncement$Input

export type ChatPosition =
  | chatPosition

export type ChatPosition$Input =
  | chatPosition$Input

export type VideoChat =
  | videoChat

export type VideoChat$Input =
  | videoChat$Input

export type Chat =
  | chat

export type Chat$Input =
  | chat$Input

export type Chats =
  | chats

export type Chats$Input =
  | chats$Input

export type ChatNearby =
  | chatNearby

export type ChatNearby$Input =
  | chatNearby$Input

export type ChatsNearby =
  | chatsNearby

export type ChatsNearby$Input =
  | chatsNearby$Input

/** Describes a type of public chats */
export type PublicChatType =
  | publicChatTypeHasUsername
  | publicChatTypeIsLocationBased

/** Describes a type of public chats */
export type PublicChatType$Input =
  | publicChatTypeHasUsername$Input
  | publicChatTypeIsLocationBased$Input

/** Describes actions which must be possible to do through a chat action bar */
export type ChatActionBar =
  | chatActionBarReportSpam
  | chatActionBarReportUnrelatedLocation
  | chatActionBarInviteMembers
  | chatActionBarReportAddBlock
  | chatActionBarAddContact
  | chatActionBarSharePhoneNumber
  | chatActionBarJoinRequest

/** Describes actions which must be possible to do through a chat action bar */
export type ChatActionBar$Input =
  | chatActionBarReportSpam$Input
  | chatActionBarReportUnrelatedLocation$Input
  | chatActionBarInviteMembers$Input
  | chatActionBarReportAddBlock$Input
  | chatActionBarAddContact$Input
  | chatActionBarSharePhoneNumber$Input
  | chatActionBarJoinRequest$Input

/** Describes a keyboard button type */
export type KeyboardButtonType =
  | keyboardButtonTypeText
  | keyboardButtonTypeRequestPhoneNumber
  | keyboardButtonTypeRequestLocation
  | keyboardButtonTypeRequestPoll

/** Describes a keyboard button type */
export type KeyboardButtonType$Input =
  | keyboardButtonTypeText$Input
  | keyboardButtonTypeRequestPhoneNumber$Input
  | keyboardButtonTypeRequestLocation$Input
  | keyboardButtonTypeRequestPoll$Input

export type KeyboardButton =
  | keyboardButton

export type KeyboardButton$Input =
  | keyboardButton$Input

/** Describes the type of an inline keyboard button */
export type InlineKeyboardButtonType =
  | inlineKeyboardButtonTypeUrl
  | inlineKeyboardButtonTypeLoginUrl
  | inlineKeyboardButtonTypeCallback
  | inlineKeyboardButtonTypeCallbackWithPassword
  | inlineKeyboardButtonTypeCallbackGame
  | inlineKeyboardButtonTypeSwitchInline
  | inlineKeyboardButtonTypeBuy
  | inlineKeyboardButtonTypeUser

/** Describes the type of an inline keyboard button */
export type InlineKeyboardButtonType$Input =
  | inlineKeyboardButtonTypeUrl$Input
  | inlineKeyboardButtonTypeLoginUrl$Input
  | inlineKeyboardButtonTypeCallback$Input
  | inlineKeyboardButtonTypeCallbackWithPassword$Input
  | inlineKeyboardButtonTypeCallbackGame$Input
  | inlineKeyboardButtonTypeSwitchInline$Input
  | inlineKeyboardButtonTypeBuy$Input
  | inlineKeyboardButtonTypeUser$Input

export type InlineKeyboardButton =
  | inlineKeyboardButton

export type InlineKeyboardButton$Input =
  | inlineKeyboardButton$Input

/**
 * Contains a description of a custom keyboard and actions that can be done with it
 * to quickly reply to bots
 */
export type ReplyMarkup =
  | replyMarkupRemoveKeyboard
  | replyMarkupForceReply
  | replyMarkupShowKeyboard
  | replyMarkupInlineKeyboard

/**
 * Contains a description of a custom keyboard and actions that can be done with it
 * to quickly reply to bots
 */
export type ReplyMarkup$Input =
  | replyMarkupRemoveKeyboard$Input
  | replyMarkupForceReply$Input
  | replyMarkupShowKeyboard$Input
  | replyMarkupInlineKeyboard$Input

/** Contains information about an inline button of type inlineKeyboardButtonTypeLoginUrl */
export type LoginUrlInfo =
  | loginUrlInfoOpen
  | loginUrlInfoRequestConfirmation

/** Contains information about an inline button of type inlineKeyboardButtonTypeLoginUrl */
export type LoginUrlInfo$Input =
  | loginUrlInfoOpen$Input
  | loginUrlInfoRequestConfirmation$Input

export type MessageThreadInfo =
  | messageThreadInfo

export type MessageThreadInfo$Input =
  | messageThreadInfo$Input

/** Describes a text object inside an instant-view web page */
export type RichText =
  | richTextPlain
  | richTextBold
  | richTextItalic
  | richTextUnderline
  | richTextStrikethrough
  | richTextFixed
  | richTextUrl
  | richTextEmailAddress
  | richTextSubscript
  | richTextSuperscript
  | richTextMarked
  | richTextPhoneNumber
  | richTextIcon
  | richTextReference
  | richTextAnchor
  | richTextAnchorLink
  | richTexts

/** Describes a text object inside an instant-view web page */
export type RichText$Input =
  | richTextPlain$Input
  | richTextBold$Input
  | richTextItalic$Input
  | richTextUnderline$Input
  | richTextStrikethrough$Input
  | richTextFixed$Input
  | richTextUrl$Input
  | richTextEmailAddress$Input
  | richTextSubscript$Input
  | richTextSuperscript$Input
  | richTextMarked$Input
  | richTextPhoneNumber$Input
  | richTextIcon$Input
  | richTextReference$Input
  | richTextAnchor$Input
  | richTextAnchorLink$Input
  | richTexts$Input

export type PageBlockCaption =
  | pageBlockCaption

export type PageBlockCaption$Input =
  | pageBlockCaption$Input

export type PageBlockListItem =
  | pageBlockListItem

export type PageBlockListItem$Input =
  | pageBlockListItem$Input

/** Describes a horizontal alignment of a table cell content */
export type PageBlockHorizontalAlignment =
  | pageBlockHorizontalAlignmentLeft
  | pageBlockHorizontalAlignmentCenter
  | pageBlockHorizontalAlignmentRight

/** Describes a horizontal alignment of a table cell content */
export type PageBlockHorizontalAlignment$Input =
  | pageBlockHorizontalAlignmentLeft$Input
  | pageBlockHorizontalAlignmentCenter$Input
  | pageBlockHorizontalAlignmentRight$Input

/** Describes a Vertical alignment of a table cell content */
export type PageBlockVerticalAlignment =
  | pageBlockVerticalAlignmentTop
  | pageBlockVerticalAlignmentMiddle
  | pageBlockVerticalAlignmentBottom

/** Describes a Vertical alignment of a table cell content */
export type PageBlockVerticalAlignment$Input =
  | pageBlockVerticalAlignmentTop$Input
  | pageBlockVerticalAlignmentMiddle$Input
  | pageBlockVerticalAlignmentBottom$Input

export type PageBlockTableCell =
  | pageBlockTableCell

export type PageBlockTableCell$Input =
  | pageBlockTableCell$Input

export type PageBlockRelatedArticle =
  | pageBlockRelatedArticle

export type PageBlockRelatedArticle$Input =
  | pageBlockRelatedArticle$Input

/** Describes a block of an instant view web page */
export type PageBlock =
  | pageBlockTitle
  | pageBlockSubtitle
  | pageBlockAuthorDate
  | pageBlockHeader
  | pageBlockSubheader
  | pageBlockKicker
  | pageBlockParagraph
  | pageBlockPreformatted
  | pageBlockFooter
  | pageBlockDivider
  | pageBlockAnchor
  | pageBlockList
  | pageBlockBlockQuote
  | pageBlockPullQuote
  | pageBlockAnimation
  | pageBlockAudio
  | pageBlockPhoto
  | pageBlockVideo
  | pageBlockVoiceNote
  | pageBlockCover
  | pageBlockEmbedded
  | pageBlockEmbeddedPost
  | pageBlockCollage
  | pageBlockSlideshow
  | pageBlockChatLink
  | pageBlockTable
  | pageBlockDetails
  | pageBlockRelatedArticles
  | pageBlockMap

/** Describes a block of an instant view web page */
export type PageBlock$Input =
  | pageBlockTitle$Input
  | pageBlockSubtitle$Input
  | pageBlockAuthorDate$Input
  | pageBlockHeader$Input
  | pageBlockSubheader$Input
  | pageBlockKicker$Input
  | pageBlockParagraph$Input
  | pageBlockPreformatted$Input
  | pageBlockFooter$Input
  | pageBlockDivider$Input
  | pageBlockAnchor$Input
  | pageBlockList$Input
  | pageBlockBlockQuote$Input
  | pageBlockPullQuote$Input
  | pageBlockAnimation$Input
  | pageBlockAudio$Input
  | pageBlockPhoto$Input
  | pageBlockVideo$Input
  | pageBlockVoiceNote$Input
  | pageBlockCover$Input
  | pageBlockEmbedded$Input
  | pageBlockEmbeddedPost$Input
  | pageBlockCollage$Input
  | pageBlockSlideshow$Input
  | pageBlockChatLink$Input
  | pageBlockTable$Input
  | pageBlockDetails$Input
  | pageBlockRelatedArticles$Input
  | pageBlockMap$Input

export type WebPageInstantView =
  | webPageInstantView

export type WebPageInstantView$Input =
  | webPageInstantView$Input

export type WebPage =
  | webPage

export type WebPage$Input =
  | webPage$Input

export type CountryInfo =
  | countryInfo

export type CountryInfo$Input =
  | countryInfo$Input

export type Countries =
  | countries

export type Countries$Input =
  | countries$Input

export type PhoneNumberInfo =
  | phoneNumberInfo

export type PhoneNumberInfo$Input =
  | phoneNumberInfo$Input

export type BankCardActionOpenUrl =
  | bankCardActionOpenUrl

export type BankCardActionOpenUrl$Input =
  | bankCardActionOpenUrl$Input

export type BankCardInfo =
  | bankCardInfo

export type BankCardInfo$Input =
  | bankCardInfo$Input

export type Address =
  | address

export type Address$Input =
  | address$Input

export type LabeledPricePart =
  | labeledPricePart

export type LabeledPricePart$Input =
  | labeledPricePart$Input

export type Invoice =
  | invoice

export type Invoice$Input =
  | invoice$Input

export type OrderInfo =
  | orderInfo

export type OrderInfo$Input =
  | orderInfo$Input

export type ShippingOption =
  | shippingOption

export type ShippingOption$Input =
  | shippingOption$Input

export type SavedCredentials =
  | savedCredentials

export type SavedCredentials$Input =
  | savedCredentials$Input

/** Contains information about the payment method chosen by the user */
export type InputCredentials =
  | inputCredentialsSaved
  | inputCredentialsNew
  | inputCredentialsApplePay
  | inputCredentialsGooglePay

/** Contains information about the payment method chosen by the user */
export type InputCredentials$Input =
  | inputCredentialsSaved$Input
  | inputCredentialsNew$Input
  | inputCredentialsApplePay$Input
  | inputCredentialsGooglePay$Input

export type PaymentsProviderStripe =
  | paymentsProviderStripe

export type PaymentsProviderStripe$Input =
  | paymentsProviderStripe$Input

export type PaymentFormTheme =
  | paymentFormTheme

export type PaymentFormTheme$Input =
  | paymentFormTheme$Input

export type PaymentForm =
  | paymentForm

export type PaymentForm$Input =
  | paymentForm$Input

export type ValidatedOrderInfo =
  | validatedOrderInfo

export type ValidatedOrderInfo$Input =
  | validatedOrderInfo$Input

export type PaymentResult =
  | paymentResult

export type PaymentResult$Input =
  | paymentResult$Input

export type PaymentReceipt =
  | paymentReceipt

export type PaymentReceipt$Input =
  | paymentReceipt$Input

export type DatedFile =
  | datedFile

export type DatedFile$Input =
  | datedFile$Input

/** Contains the type of a Telegram Passport element */
export type PassportElementType =
  | passportElementTypePersonalDetails
  | passportElementTypePassport
  | passportElementTypeDriverLicense
  | passportElementTypeIdentityCard
  | passportElementTypeInternalPassport
  | passportElementTypeAddress
  | passportElementTypeUtilityBill
  | passportElementTypeBankStatement
  | passportElementTypeRentalAgreement
  | passportElementTypePassportRegistration
  | passportElementTypeTemporaryRegistration
  | passportElementTypePhoneNumber
  | passportElementTypeEmailAddress

/** Contains the type of a Telegram Passport element */
export type PassportElementType$Input =
  | passportElementTypePersonalDetails$Input
  | passportElementTypePassport$Input
  | passportElementTypeDriverLicense$Input
  | passportElementTypeIdentityCard$Input
  | passportElementTypeInternalPassport$Input
  | passportElementTypeAddress$Input
  | passportElementTypeUtilityBill$Input
  | passportElementTypeBankStatement$Input
  | passportElementTypeRentalAgreement$Input
  | passportElementTypePassportRegistration$Input
  | passportElementTypeTemporaryRegistration$Input
  | passportElementTypePhoneNumber$Input
  | passportElementTypeEmailAddress$Input

export type Date =
  | date

export type Date$Input =
  | date$Input

export type PersonalDetails =
  | personalDetails

export type PersonalDetails$Input =
  | personalDetails$Input

export type IdentityDocument =
  | identityDocument

export type IdentityDocument$Input =
  | identityDocument$Input

export type InputIdentityDocument =
  | inputIdentityDocument

export type InputIdentityDocument$Input =
  | inputIdentityDocument$Input

export type PersonalDocument =
  | personalDocument

export type PersonalDocument$Input =
  | personalDocument$Input

export type InputPersonalDocument =
  | inputPersonalDocument

export type InputPersonalDocument$Input =
  | inputPersonalDocument$Input

/** Contains information about a Telegram Passport element */
export type PassportElement =
  | passportElementPersonalDetails
  | passportElementPassport
  | passportElementDriverLicense
  | passportElementIdentityCard
  | passportElementInternalPassport
  | passportElementAddress
  | passportElementUtilityBill
  | passportElementBankStatement
  | passportElementRentalAgreement
  | passportElementPassportRegistration
  | passportElementTemporaryRegistration
  | passportElementPhoneNumber
  | passportElementEmailAddress

/** Contains information about a Telegram Passport element */
export type PassportElement$Input =
  | passportElementPersonalDetails$Input
  | passportElementPassport$Input
  | passportElementDriverLicense$Input
  | passportElementIdentityCard$Input
  | passportElementInternalPassport$Input
  | passportElementAddress$Input
  | passportElementUtilityBill$Input
  | passportElementBankStatement$Input
  | passportElementRentalAgreement$Input
  | passportElementPassportRegistration$Input
  | passportElementTemporaryRegistration$Input
  | passportElementPhoneNumber$Input
  | passportElementEmailAddress$Input

/** Contains information about a Telegram Passport element to be saved */
export type InputPassportElement =
  | inputPassportElementPersonalDetails
  | inputPassportElementPassport
  | inputPassportElementDriverLicense
  | inputPassportElementIdentityCard
  | inputPassportElementInternalPassport
  | inputPassportElementAddress
  | inputPassportElementUtilityBill
  | inputPassportElementBankStatement
  | inputPassportElementRentalAgreement
  | inputPassportElementPassportRegistration
  | inputPassportElementTemporaryRegistration
  | inputPassportElementPhoneNumber
  | inputPassportElementEmailAddress

/** Contains information about a Telegram Passport element to be saved */
export type InputPassportElement$Input =
  | inputPassportElementPersonalDetails$Input
  | inputPassportElementPassport$Input
  | inputPassportElementDriverLicense$Input
  | inputPassportElementIdentityCard$Input
  | inputPassportElementInternalPassport$Input
  | inputPassportElementAddress$Input
  | inputPassportElementUtilityBill$Input
  | inputPassportElementBankStatement$Input
  | inputPassportElementRentalAgreement$Input
  | inputPassportElementPassportRegistration$Input
  | inputPassportElementTemporaryRegistration$Input
  | inputPassportElementPhoneNumber$Input
  | inputPassportElementEmailAddress$Input

export type PassportElements =
  | passportElements

export type PassportElements$Input =
  | passportElements$Input

/** Contains the description of an error in a Telegram Passport element */
export type PassportElementErrorSource =
  | passportElementErrorSourceUnspecified
  | passportElementErrorSourceDataField
  | passportElementErrorSourceFrontSide
  | passportElementErrorSourceReverseSide
  | passportElementErrorSourceSelfie
  | passportElementErrorSourceTranslationFile
  | passportElementErrorSourceTranslationFiles
  | passportElementErrorSourceFile
  | passportElementErrorSourceFiles

/** Contains the description of an error in a Telegram Passport element */
export type PassportElementErrorSource$Input =
  | passportElementErrorSourceUnspecified$Input
  | passportElementErrorSourceDataField$Input
  | passportElementErrorSourceFrontSide$Input
  | passportElementErrorSourceReverseSide$Input
  | passportElementErrorSourceSelfie$Input
  | passportElementErrorSourceTranslationFile$Input
  | passportElementErrorSourceTranslationFiles$Input
  | passportElementErrorSourceFile$Input
  | passportElementErrorSourceFiles$Input

export type PassportElementError =
  | passportElementError

export type PassportElementError$Input =
  | passportElementError$Input

export type PassportSuitableElement =
  | passportSuitableElement

export type PassportSuitableElement$Input =
  | passportSuitableElement$Input

export type PassportRequiredElement =
  | passportRequiredElement

export type PassportRequiredElement$Input =
  | passportRequiredElement$Input

export type PassportAuthorizationForm =
  | passportAuthorizationForm

export type PassportAuthorizationForm$Input =
  | passportAuthorizationForm$Input

export type PassportElementsWithErrors =
  | passportElementsWithErrors

export type PassportElementsWithErrors$Input =
  | passportElementsWithErrors$Input

export type EncryptedCredentials =
  | encryptedCredentials

export type EncryptedCredentials$Input =
  | encryptedCredentials$Input

export type EncryptedPassportElement =
  | encryptedPassportElement

export type EncryptedPassportElement$Input =
  | encryptedPassportElement$Input

/** Contains the description of an error in a Telegram Passport element; for bots only */
export type InputPassportElementErrorSource =
  | inputPassportElementErrorSourceUnspecified
  | inputPassportElementErrorSourceDataField
  | inputPassportElementErrorSourceFrontSide
  | inputPassportElementErrorSourceReverseSide
  | inputPassportElementErrorSourceSelfie
  | inputPassportElementErrorSourceTranslationFile
  | inputPassportElementErrorSourceTranslationFiles
  | inputPassportElementErrorSourceFile
  | inputPassportElementErrorSourceFiles

/** Contains the description of an error in a Telegram Passport element; for bots only */
export type InputPassportElementErrorSource$Input =
  | inputPassportElementErrorSourceUnspecified$Input
  | inputPassportElementErrorSourceDataField$Input
  | inputPassportElementErrorSourceFrontSide$Input
  | inputPassportElementErrorSourceReverseSide$Input
  | inputPassportElementErrorSourceSelfie$Input
  | inputPassportElementErrorSourceTranslationFile$Input
  | inputPassportElementErrorSourceTranslationFiles$Input
  | inputPassportElementErrorSourceFile$Input
  | inputPassportElementErrorSourceFiles$Input

export type InputPassportElementError =
  | inputPassportElementError

export type InputPassportElementError$Input =
  | inputPassportElementError$Input

/** Contains the content of a message */
export type MessageContent =
  | messageText
  | messageAnimation
  | messageAudio
  | messageDocument
  | messagePhoto
  | messageExpiredPhoto
  | messageSticker
  | messageVideo
  | messageExpiredVideo
  | messageVideoNote
  | messageVoiceNote
  | messageLocation
  | messageVenue
  | messageContact
  | messageAnimatedEmoji
  | messageDice
  | messageGame
  | messagePoll
  | messageInvoice
  | messageCall
  | messageVideoChatScheduled
  | messageVideoChatStarted
  | messageVideoChatEnded
  | messageInviteVideoChatParticipants
  | messageBasicGroupChatCreate
  | messageSupergroupChatCreate
  | messageChatChangeTitle
  | messageChatChangePhoto
  | messageChatDeletePhoto
  | messageChatAddMembers
  | messageChatJoinByLink
  | messageChatJoinByRequest
  | messageChatDeleteMember
  | messageChatUpgradeTo
  | messageChatUpgradeFrom
  | messagePinMessage
  | messageScreenshotTaken
  | messageChatSetTheme
  | messageChatSetTtl
  | messageCustomServiceAction
  | messageGameScore
  | messagePaymentSuccessful
  | messagePaymentSuccessfulBot
  | messageContactRegistered
  | messageWebsiteConnected
  | messagePassportDataSent
  | messagePassportDataReceived
  | messageProximityAlertTriggered
  | messageUnsupported

/** Contains the content of a message */
export type MessageContent$Input =
  | messageText$Input
  | messageAnimation$Input
  | messageAudio$Input
  | messageDocument$Input
  | messagePhoto$Input
  | messageExpiredPhoto$Input
  | messageSticker$Input
  | messageVideo$Input
  | messageExpiredVideo$Input
  | messageVideoNote$Input
  | messageVoiceNote$Input
  | messageLocation$Input
  | messageVenue$Input
  | messageContact$Input
  | messageAnimatedEmoji$Input
  | messageDice$Input
  | messageGame$Input
  | messagePoll$Input
  | messageInvoice$Input
  | messageCall$Input
  | messageVideoChatScheduled$Input
  | messageVideoChatStarted$Input
  | messageVideoChatEnded$Input
  | messageInviteVideoChatParticipants$Input
  | messageBasicGroupChatCreate$Input
  | messageSupergroupChatCreate$Input
  | messageChatChangeTitle$Input
  | messageChatChangePhoto$Input
  | messageChatDeletePhoto$Input
  | messageChatAddMembers$Input
  | messageChatJoinByLink$Input
  | messageChatJoinByRequest$Input
  | messageChatDeleteMember$Input
  | messageChatUpgradeTo$Input
  | messageChatUpgradeFrom$Input
  | messagePinMessage$Input
  | messageScreenshotTaken$Input
  | messageChatSetTheme$Input
  | messageChatSetTtl$Input
  | messageCustomServiceAction$Input
  | messageGameScore$Input
  | messagePaymentSuccessful$Input
  | messagePaymentSuccessfulBot$Input
  | messageContactRegistered$Input
  | messageWebsiteConnected$Input
  | messagePassportDataSent$Input
  | messagePassportDataReceived$Input
  | messageProximityAlertTriggered$Input
  | messageUnsupported$Input

/** Represents a part of the text which must be formatted differently */
export type TextEntityType =
  | textEntityTypeMention
  | textEntityTypeHashtag
  | textEntityTypeCashtag
  | textEntityTypeBotCommand
  | textEntityTypeUrl
  | textEntityTypeEmailAddress
  | textEntityTypePhoneNumber
  | textEntityTypeBankCardNumber
  | textEntityTypeBold
  | textEntityTypeItalic
  | textEntityTypeUnderline
  | textEntityTypeStrikethrough
  | textEntityTypeCode
  | textEntityTypePre
  | textEntityTypePreCode
  | textEntityTypeTextUrl
  | textEntityTypeMentionName
  | textEntityTypeMediaTimestamp

/** Represents a part of the text which must be formatted differently */
export type TextEntityType$Input =
  | textEntityTypeMention$Input
  | textEntityTypeHashtag$Input
  | textEntityTypeCashtag$Input
  | textEntityTypeBotCommand$Input
  | textEntityTypeUrl$Input
  | textEntityTypeEmailAddress$Input
  | textEntityTypePhoneNumber$Input
  | textEntityTypeBankCardNumber$Input
  | textEntityTypeBold$Input
  | textEntityTypeItalic$Input
  | textEntityTypeUnderline$Input
  | textEntityTypeStrikethrough$Input
  | textEntityTypeCode$Input
  | textEntityTypePre$Input
  | textEntityTypePreCode$Input
  | textEntityTypeTextUrl$Input
  | textEntityTypeMentionName$Input
  | textEntityTypeMediaTimestamp$Input

export type InputThumbnail =
  | inputThumbnail

export type InputThumbnail$Input =
  | inputThumbnail$Input

/** Contains information about the time when a scheduled message will be sent */
export type MessageSchedulingState =
  | messageSchedulingStateSendAtDate
  | messageSchedulingStateSendWhenOnline

/** Contains information about the time when a scheduled message will be sent */
export type MessageSchedulingState$Input =
  | messageSchedulingStateSendAtDate$Input
  | messageSchedulingStateSendWhenOnline$Input

export type MessageSendOptions =
  | messageSendOptions

export type MessageSendOptions$Input =
  | messageSendOptions$Input

export type MessageCopyOptions =
  | messageCopyOptions

export type MessageCopyOptions$Input =
  | messageCopyOptions$Input

/** The content of a message to send */
export type InputMessageContent =
  | inputMessageText
  | inputMessageAnimation
  | inputMessageAudio
  | inputMessageDocument
  | inputMessagePhoto
  | inputMessageSticker
  | inputMessageVideo
  | inputMessageVideoNote
  | inputMessageVoiceNote
  | inputMessageLocation
  | inputMessageVenue
  | inputMessageContact
  | inputMessageDice
  | inputMessageGame
  | inputMessageInvoice
  | inputMessagePoll
  | inputMessageForwarded

/** The content of a message to send */
export type InputMessageContent$Input =
  | inputMessageText$Input
  | inputMessageAnimation$Input
  | inputMessageAudio$Input
  | inputMessageDocument$Input
  | inputMessagePhoto$Input
  | inputMessageSticker$Input
  | inputMessageVideo$Input
  | inputMessageVideoNote$Input
  | inputMessageVoiceNote$Input
  | inputMessageLocation$Input
  | inputMessageVenue$Input
  | inputMessageContact$Input
  | inputMessageDice$Input
  | inputMessageGame$Input
  | inputMessageInvoice$Input
  | inputMessagePoll$Input
  | inputMessageForwarded$Input

/** Represents a filter for message search results */
export type SearchMessagesFilter =
  | searchMessagesFilterEmpty
  | searchMessagesFilterAnimation
  | searchMessagesFilterAudio
  | searchMessagesFilterDocument
  | searchMessagesFilterPhoto
  | searchMessagesFilterVideo
  | searchMessagesFilterVoiceNote
  | searchMessagesFilterPhotoAndVideo
  | searchMessagesFilterUrl
  | searchMessagesFilterChatPhoto
  | searchMessagesFilterVideoNote
  | searchMessagesFilterVoiceAndVideoNote
  | searchMessagesFilterMention
  | searchMessagesFilterUnreadMention
  | searchMessagesFilterFailedToSend
  | searchMessagesFilterPinned

/** Represents a filter for message search results */
export type SearchMessagesFilter$Input =
  | searchMessagesFilterEmpty$Input
  | searchMessagesFilterAnimation$Input
  | searchMessagesFilterAudio$Input
  | searchMessagesFilterDocument$Input
  | searchMessagesFilterPhoto$Input
  | searchMessagesFilterVideo$Input
  | searchMessagesFilterVoiceNote$Input
  | searchMessagesFilterPhotoAndVideo$Input
  | searchMessagesFilterUrl$Input
  | searchMessagesFilterChatPhoto$Input
  | searchMessagesFilterVideoNote$Input
  | searchMessagesFilterVoiceAndVideoNote$Input
  | searchMessagesFilterMention$Input
  | searchMessagesFilterUnreadMention$Input
  | searchMessagesFilterFailedToSend$Input
  | searchMessagesFilterPinned$Input

/** Describes the different types of activity in a chat */
export type ChatAction =
  | chatActionTyping
  | chatActionRecordingVideo
  | chatActionUploadingVideo
  | chatActionRecordingVoiceNote
  | chatActionUploadingVoiceNote
  | chatActionUploadingPhoto
  | chatActionUploadingDocument
  | chatActionChoosingSticker
  | chatActionChoosingLocation
  | chatActionChoosingContact
  | chatActionStartPlayingGame
  | chatActionRecordingVideoNote
  | chatActionUploadingVideoNote
  | chatActionWatchingAnimations
  | chatActionCancel

/** Describes the different types of activity in a chat */
export type ChatAction$Input =
  | chatActionTyping$Input
  | chatActionRecordingVideo$Input
  | chatActionUploadingVideo$Input
  | chatActionRecordingVoiceNote$Input
  | chatActionUploadingVoiceNote$Input
  | chatActionUploadingPhoto$Input
  | chatActionUploadingDocument$Input
  | chatActionChoosingSticker$Input
  | chatActionChoosingLocation$Input
  | chatActionChoosingContact$Input
  | chatActionStartPlayingGame$Input
  | chatActionRecordingVideoNote$Input
  | chatActionUploadingVideoNote$Input
  | chatActionWatchingAnimations$Input
  | chatActionCancel$Input

/** Describes the last time the user was online */
export type UserStatus =
  | userStatusEmpty
  | userStatusOnline
  | userStatusOffline
  | userStatusRecently
  | userStatusLastWeek
  | userStatusLastMonth

/** Describes the last time the user was online */
export type UserStatus$Input =
  | userStatusEmpty$Input
  | userStatusOnline$Input
  | userStatusOffline$Input
  | userStatusRecently$Input
  | userStatusLastWeek$Input
  | userStatusLastMonth$Input

export type Stickers =
  | stickers

export type Stickers$Input =
  | stickers$Input

export type Emojis =
  | emojis

export type Emojis$Input =
  | emojis$Input

export type StickerSet =
  | stickerSet

export type StickerSet$Input =
  | stickerSet$Input

export type StickerSetInfo =
  | stickerSetInfo

export type StickerSetInfo$Input =
  | stickerSetInfo$Input

export type StickerSets =
  | stickerSets

export type StickerSets$Input =
  | stickerSets$Input

/** Describes the reason why a call was discarded */
export type CallDiscardReason =
  | callDiscardReasonEmpty
  | callDiscardReasonMissed
  | callDiscardReasonDeclined
  | callDiscardReasonDisconnected
  | callDiscardReasonHungUp

/** Describes the reason why a call was discarded */
export type CallDiscardReason$Input =
  | callDiscardReasonEmpty$Input
  | callDiscardReasonMissed$Input
  | callDiscardReasonDeclined$Input
  | callDiscardReasonDisconnected$Input
  | callDiscardReasonHungUp$Input

export type CallProtocol =
  | callProtocol

export type CallProtocol$Input =
  | callProtocol$Input

/** Describes the type of a call server */
export type CallServerType =
  | callServerTypeTelegramReflector
  | callServerTypeWebrtc

/** Describes the type of a call server */
export type CallServerType$Input =
  | callServerTypeTelegramReflector$Input
  | callServerTypeWebrtc$Input

export type CallServer =
  | callServer

export type CallServer$Input =
  | callServer$Input

export type CallId =
  | callId

export type CallId$Input =
  | callId$Input

export type GroupCallId =
  | groupCallId

export type GroupCallId$Input =
  | groupCallId$Input

/** Describes the current call state */
export type CallState =
  | callStatePending
  | callStateExchangingKeys
  | callStateReady
  | callStateHangingUp
  | callStateDiscarded
  | callStateError

/** Describes the current call state */
export type CallState$Input =
  | callStatePending$Input
  | callStateExchangingKeys$Input
  | callStateReady$Input
  | callStateHangingUp$Input
  | callStateDiscarded$Input
  | callStateError$Input

/** Describes the quality of a group call video */
export type GroupCallVideoQuality =
  | groupCallVideoQualityThumbnail
  | groupCallVideoQualityMedium
  | groupCallVideoQualityFull

/** Describes the quality of a group call video */
export type GroupCallVideoQuality$Input =
  | groupCallVideoQualityThumbnail$Input
  | groupCallVideoQualityMedium$Input
  | groupCallVideoQualityFull$Input

export type GroupCallRecentSpeaker =
  | groupCallRecentSpeaker

export type GroupCallRecentSpeaker$Input =
  | groupCallRecentSpeaker$Input

export type GroupCall =
  | groupCall

export type GroupCall$Input =
  | groupCall$Input

export type GroupCallVideoSourceGroup =
  | groupCallVideoSourceGroup

export type GroupCallVideoSourceGroup$Input =
  | groupCallVideoSourceGroup$Input

export type GroupCallParticipantVideoInfo =
  | groupCallParticipantVideoInfo

export type GroupCallParticipantVideoInfo$Input =
  | groupCallParticipantVideoInfo$Input

export type GroupCallParticipant =
  | groupCallParticipant

export type GroupCallParticipant$Input =
  | groupCallParticipant$Input

/** Describes the exact type of a problem with a call */
export type CallProblem =
  | callProblemEcho
  | callProblemNoise
  | callProblemInterruptions
  | callProblemDistortedSpeech
  | callProblemSilentLocal
  | callProblemSilentRemote
  | callProblemDropped
  | callProblemDistortedVideo
  | callProblemPixelatedVideo

/** Describes the exact type of a problem with a call */
export type CallProblem$Input =
  | callProblemEcho$Input
  | callProblemNoise$Input
  | callProblemInterruptions$Input
  | callProblemDistortedSpeech$Input
  | callProblemSilentLocal$Input
  | callProblemSilentRemote$Input
  | callProblemDropped$Input
  | callProblemDistortedVideo$Input
  | callProblemPixelatedVideo$Input

export type Call =
  | call

export type Call$Input =
  | call$Input

export type PhoneNumberAuthenticationSettings =
  | phoneNumberAuthenticationSettings

export type PhoneNumberAuthenticationSettings$Input =
  | phoneNumberAuthenticationSettings$Input

export type Animations =
  | animations

export type Animations$Input =
  | animations$Input

/** Contains animated stickers which must be used for dice animation rendering */
export type DiceStickers =
  | diceStickersRegular
  | diceStickersSlotMachine

/** Contains animated stickers which must be used for dice animation rendering */
export type DiceStickers$Input =
  | diceStickersRegular$Input
  | diceStickersSlotMachine$Input

export type ImportedContacts =
  | importedContacts

export type ImportedContacts$Input =
  | importedContacts$Input

export type HttpUrl =
  | httpUrl

export type HttpUrl$Input =
  | httpUrl$Input

/** Represents a single result of an inline query; for bots only */
export type InputInlineQueryResult =
  | inputInlineQueryResultAnimation
  | inputInlineQueryResultArticle
  | inputInlineQueryResultAudio
  | inputInlineQueryResultContact
  | inputInlineQueryResultDocument
  | inputInlineQueryResultGame
  | inputInlineQueryResultLocation
  | inputInlineQueryResultPhoto
  | inputInlineQueryResultSticker
  | inputInlineQueryResultVenue
  | inputInlineQueryResultVideo
  | inputInlineQueryResultVoiceNote

/** Represents a single result of an inline query; for bots only */
export type InputInlineQueryResult$Input =
  | inputInlineQueryResultAnimation$Input
  | inputInlineQueryResultArticle$Input
  | inputInlineQueryResultAudio$Input
  | inputInlineQueryResultContact$Input
  | inputInlineQueryResultDocument$Input
  | inputInlineQueryResultGame$Input
  | inputInlineQueryResultLocation$Input
  | inputInlineQueryResultPhoto$Input
  | inputInlineQueryResultSticker$Input
  | inputInlineQueryResultVenue$Input
  | inputInlineQueryResultVideo$Input
  | inputInlineQueryResultVoiceNote$Input

/** Represents a single result of an inline query */
export type InlineQueryResult =
  | inlineQueryResultArticle
  | inlineQueryResultContact
  | inlineQueryResultLocation
  | inlineQueryResultVenue
  | inlineQueryResultGame
  | inlineQueryResultAnimation
  | inlineQueryResultAudio
  | inlineQueryResultDocument
  | inlineQueryResultPhoto
  | inlineQueryResultSticker
  | inlineQueryResultVideo
  | inlineQueryResultVoiceNote

/** Represents a single result of an inline query */
export type InlineQueryResult$Input =
  | inlineQueryResultArticle$Input
  | inlineQueryResultContact$Input
  | inlineQueryResultLocation$Input
  | inlineQueryResultVenue$Input
  | inlineQueryResultGame$Input
  | inlineQueryResultAnimation$Input
  | inlineQueryResultAudio$Input
  | inlineQueryResultDocument$Input
  | inlineQueryResultPhoto$Input
  | inlineQueryResultSticker$Input
  | inlineQueryResultVideo$Input
  | inlineQueryResultVoiceNote$Input

export type InlineQueryResults =
  | inlineQueryResults

export type InlineQueryResults$Input =
  | inlineQueryResults$Input

/** Represents a payload of a callback query */
export type CallbackQueryPayload =
  | callbackQueryPayloadData
  | callbackQueryPayloadDataWithPassword
  | callbackQueryPayloadGame

/** Represents a payload of a callback query */
export type CallbackQueryPayload$Input =
  | callbackQueryPayloadData$Input
  | callbackQueryPayloadDataWithPassword$Input
  | callbackQueryPayloadGame$Input

export type CallbackQueryAnswer =
  | callbackQueryAnswer

export type CallbackQueryAnswer$Input =
  | callbackQueryAnswer$Input

export type CustomRequestResult =
  | customRequestResult

export type CustomRequestResult$Input =
  | customRequestResult$Input

export type GameHighScore =
  | gameHighScore

export type GameHighScore$Input =
  | gameHighScore$Input

export type GameHighScores =
  | gameHighScores

export type GameHighScores$Input =
  | gameHighScores$Input

/** Represents a chat event */
export type ChatEventAction =
  | chatEventMessageEdited
  | chatEventMessageDeleted
  | chatEventPollStopped
  | chatEventMessagePinned
  | chatEventMessageUnpinned
  | chatEventMemberJoined
  | chatEventMemberJoinedByInviteLink
  | chatEventMemberJoinedByRequest
  | chatEventMemberLeft
  | chatEventMemberInvited
  | chatEventMemberPromoted
  | chatEventMemberRestricted
  | chatEventTitleChanged
  | chatEventPermissionsChanged
  | chatEventDescriptionChanged
  | chatEventUsernameChanged
  | chatEventPhotoChanged
  | chatEventInvitesToggled
  | chatEventLinkedChatChanged
  | chatEventSlowModeDelayChanged
  | chatEventMessageTtlChanged
  | chatEventSignMessagesToggled
  | chatEventHasProtectedContentToggled
  | chatEventStickerSetChanged
  | chatEventLocationChanged
  | chatEventIsAllHistoryAvailableToggled
  | chatEventInviteLinkEdited
  | chatEventInviteLinkRevoked
  | chatEventInviteLinkDeleted
  | chatEventVideoChatCreated
  | chatEventVideoChatEnded
  | chatEventVideoChatParticipantIsMutedToggled
  | chatEventVideoChatParticipantVolumeLevelChanged
  | chatEventVideoChatMuteNewParticipantsToggled

/** Represents a chat event */
export type ChatEventAction$Input =
  | chatEventMessageEdited$Input
  | chatEventMessageDeleted$Input
  | chatEventPollStopped$Input
  | chatEventMessagePinned$Input
  | chatEventMessageUnpinned$Input
  | chatEventMemberJoined$Input
  | chatEventMemberJoinedByInviteLink$Input
  | chatEventMemberJoinedByRequest$Input
  | chatEventMemberLeft$Input
  | chatEventMemberInvited$Input
  | chatEventMemberPromoted$Input
  | chatEventMemberRestricted$Input
  | chatEventTitleChanged$Input
  | chatEventPermissionsChanged$Input
  | chatEventDescriptionChanged$Input
  | chatEventUsernameChanged$Input
  | chatEventPhotoChanged$Input
  | chatEventInvitesToggled$Input
  | chatEventLinkedChatChanged$Input
  | chatEventSlowModeDelayChanged$Input
  | chatEventMessageTtlChanged$Input
  | chatEventSignMessagesToggled$Input
  | chatEventHasProtectedContentToggled$Input
  | chatEventStickerSetChanged$Input
  | chatEventLocationChanged$Input
  | chatEventIsAllHistoryAvailableToggled$Input
  | chatEventInviteLinkEdited$Input
  | chatEventInviteLinkRevoked$Input
  | chatEventInviteLinkDeleted$Input
  | chatEventVideoChatCreated$Input
  | chatEventVideoChatEnded$Input
  | chatEventVideoChatParticipantIsMutedToggled$Input
  | chatEventVideoChatParticipantVolumeLevelChanged$Input
  | chatEventVideoChatMuteNewParticipantsToggled$Input

export type ChatEvent =
  | chatEvent

export type ChatEvent$Input =
  | chatEvent$Input

export type ChatEvents =
  | chatEvents

export type ChatEvents$Input =
  | chatEvents$Input

export type ChatEventLogFilters =
  | chatEventLogFilters

export type ChatEventLogFilters$Input =
  | chatEventLogFilters$Input

/** Represents the value of a string in a language pack */
export type LanguagePackStringValue =
  | languagePackStringValueOrdinary
  | languagePackStringValuePluralized
  | languagePackStringValueDeleted

/** Represents the value of a string in a language pack */
export type LanguagePackStringValue$Input =
  | languagePackStringValueOrdinary$Input
  | languagePackStringValuePluralized$Input
  | languagePackStringValueDeleted$Input

export type LanguagePackString =
  | languagePackString

export type LanguagePackString$Input =
  | languagePackString$Input

export type LanguagePackStrings =
  | languagePackStrings

export type LanguagePackStrings$Input =
  | languagePackStrings$Input

export type LanguagePackInfo =
  | languagePackInfo

export type LanguagePackInfo$Input =
  | languagePackInfo$Input

export type LocalizationTargetInfo =
  | localizationTargetInfo

export type LocalizationTargetInfo$Input =
  | localizationTargetInfo$Input

/**
 * Represents a data needed to subscribe for push notifications through registerDevice
 * method. To use specific push notification service, the correct application platform
 * must be specified and a valid server authentication data must be uploaded at https://my.telegram.org
 */
export type DeviceToken =
  | deviceTokenFirebaseCloudMessaging
  | deviceTokenApplePush
  | deviceTokenApplePushVoIP
  | deviceTokenWindowsPush
  | deviceTokenMicrosoftPush
  | deviceTokenMicrosoftPushVoIP
  | deviceTokenWebPush
  | deviceTokenSimplePush
  | deviceTokenUbuntuPush
  | deviceTokenBlackBerryPush
  | deviceTokenTizenPush

/**
 * Represents a data needed to subscribe for push notifications through registerDevice
 * method. To use specific push notification service, the correct application platform
 * must be specified and a valid server authentication data must be uploaded at https://my.telegram.org
 */
export type DeviceToken$Input =
  | deviceTokenFirebaseCloudMessaging$Input
  | deviceTokenApplePush$Input
  | deviceTokenApplePushVoIP$Input
  | deviceTokenWindowsPush$Input
  | deviceTokenMicrosoftPush$Input
  | deviceTokenMicrosoftPushVoIP$Input
  | deviceTokenWebPush$Input
  | deviceTokenSimplePush$Input
  | deviceTokenUbuntuPush$Input
  | deviceTokenBlackBerryPush$Input
  | deviceTokenTizenPush$Input

export type PushReceiverId =
  | pushReceiverId

export type PushReceiverId$Input =
  | pushReceiverId$Input

/** Describes a fill of a background */
export type BackgroundFill =
  | backgroundFillSolid
  | backgroundFillGradient
  | backgroundFillFreeformGradient

/** Describes a fill of a background */
export type BackgroundFill$Input =
  | backgroundFillSolid$Input
  | backgroundFillGradient$Input
  | backgroundFillFreeformGradient$Input

/** Describes the type of a background */
export type BackgroundType =
  | backgroundTypeWallpaper
  | backgroundTypePattern
  | backgroundTypeFill

/** Describes the type of a background */
export type BackgroundType$Input =
  | backgroundTypeWallpaper$Input
  | backgroundTypePattern$Input
  | backgroundTypeFill$Input

export type Background =
  | background

export type Background$Input =
  | background$Input

export type Backgrounds =
  | backgrounds

export type Backgrounds$Input =
  | backgrounds$Input

/** Contains information about background to set */
export type InputBackground =
  | inputBackgroundLocal
  | inputBackgroundRemote

/** Contains information about background to set */
export type InputBackground$Input =
  | inputBackgroundLocal$Input
  | inputBackgroundRemote$Input

export type ThemeSettings =
  | themeSettings

export type ThemeSettings$Input =
  | themeSettings$Input

export type ChatTheme =
  | chatTheme

export type ChatTheme$Input =
  | chatTheme$Input

export type Hashtags =
  | hashtags

export type Hashtags$Input =
  | hashtags$Input

/**
 * Represents result of checking whether the current session can be used to transfer
 * a chat ownership to another user
 */
export type CanTransferOwnershipResult =
  | canTransferOwnershipResultOk
  | canTransferOwnershipResultPasswordNeeded
  | canTransferOwnershipResultPasswordTooFresh
  | canTransferOwnershipResultSessionTooFresh

/**
 * Represents result of checking whether the current session can be used to transfer
 * a chat ownership to another user
 */
export type CanTransferOwnershipResult$Input =
  | canTransferOwnershipResultOk$Input
  | canTransferOwnershipResultPasswordNeeded$Input
  | canTransferOwnershipResultPasswordTooFresh$Input
  | canTransferOwnershipResultSessionTooFresh$Input

/** Represents result of checking whether a username can be set for a chat */
export type CheckChatUsernameResult =
  | checkChatUsernameResultOk
  | checkChatUsernameResultUsernameInvalid
  | checkChatUsernameResultUsernameOccupied
  | checkChatUsernameResultPublicChatsTooMuch
  | checkChatUsernameResultPublicGroupsUnavailable

/** Represents result of checking whether a username can be set for a chat */
export type CheckChatUsernameResult$Input =
  | checkChatUsernameResultOk$Input
  | checkChatUsernameResultUsernameInvalid$Input
  | checkChatUsernameResultUsernameOccupied$Input
  | checkChatUsernameResultPublicChatsTooMuch$Input
  | checkChatUsernameResultPublicGroupsUnavailable$Input

/** Represents result of checking whether a name can be used for a new sticker set */
export type CheckStickerSetNameResult =
  | checkStickerSetNameResultOk
  | checkStickerSetNameResultNameInvalid
  | checkStickerSetNameResultNameOccupied

/** Represents result of checking whether a name can be used for a new sticker set */
export type CheckStickerSetNameResult$Input =
  | checkStickerSetNameResultOk$Input
  | checkStickerSetNameResultNameInvalid$Input
  | checkStickerSetNameResultNameOccupied$Input

/** Represents result of 2-step verification password reset */
export type ResetPasswordResult =
  | resetPasswordResultOk
  | resetPasswordResultPending
  | resetPasswordResultDeclined

/** Represents result of 2-step verification password reset */
export type ResetPasswordResult$Input =
  | resetPasswordResultOk$Input
  | resetPasswordResultPending$Input
  | resetPasswordResultDeclined$Input

/** Contains information about a file with messages exported from another app */
export type MessageFileType =
  | messageFileTypePrivate
  | messageFileTypeGroup
  | messageFileTypeUnknown

/** Contains information about a file with messages exported from another app */
export type MessageFileType$Input =
  | messageFileTypePrivate$Input
  | messageFileTypeGroup$Input
  | messageFileTypeUnknown$Input

/** Contains content of a push message notification */
export type PushMessageContent =
  | pushMessageContentHidden
  | pushMessageContentAnimation
  | pushMessageContentAudio
  | pushMessageContentContact
  | pushMessageContentContactRegistered
  | pushMessageContentDocument
  | pushMessageContentGame
  | pushMessageContentGameScore
  | pushMessageContentInvoice
  | pushMessageContentLocation
  | pushMessageContentPhoto
  | pushMessageContentPoll
  | pushMessageContentScreenshotTaken
  | pushMessageContentSticker
  | pushMessageContentText
  | pushMessageContentVideo
  | pushMessageContentVideoNote
  | pushMessageContentVoiceNote
  | pushMessageContentBasicGroupChatCreate
  | pushMessageContentChatAddMembers
  | pushMessageContentChatChangePhoto
  | pushMessageContentChatChangeTitle
  | pushMessageContentChatSetTheme
  | pushMessageContentChatDeleteMember
  | pushMessageContentChatJoinByLink
  | pushMessageContentChatJoinByRequest
  | pushMessageContentMessageForwards
  | pushMessageContentMediaAlbum

/** Contains content of a push message notification */
export type PushMessageContent$Input =
  | pushMessageContentHidden$Input
  | pushMessageContentAnimation$Input
  | pushMessageContentAudio$Input
  | pushMessageContentContact$Input
  | pushMessageContentContactRegistered$Input
  | pushMessageContentDocument$Input
  | pushMessageContentGame$Input
  | pushMessageContentGameScore$Input
  | pushMessageContentInvoice$Input
  | pushMessageContentLocation$Input
  | pushMessageContentPhoto$Input
  | pushMessageContentPoll$Input
  | pushMessageContentScreenshotTaken$Input
  | pushMessageContentSticker$Input
  | pushMessageContentText$Input
  | pushMessageContentVideo$Input
  | pushMessageContentVideoNote$Input
  | pushMessageContentVoiceNote$Input
  | pushMessageContentBasicGroupChatCreate$Input
  | pushMessageContentChatAddMembers$Input
  | pushMessageContentChatChangePhoto$Input
  | pushMessageContentChatChangeTitle$Input
  | pushMessageContentChatSetTheme$Input
  | pushMessageContentChatDeleteMember$Input
  | pushMessageContentChatJoinByLink$Input
  | pushMessageContentChatJoinByRequest$Input
  | pushMessageContentMessageForwards$Input
  | pushMessageContentMediaAlbum$Input

/** Contains detailed information about a notification */
export type NotificationType =
  | notificationTypeNewMessage
  | notificationTypeNewSecretChat
  | notificationTypeNewCall
  | notificationTypeNewPushMessage

/** Contains detailed information about a notification */
export type NotificationType$Input =
  | notificationTypeNewMessage$Input
  | notificationTypeNewSecretChat$Input
  | notificationTypeNewCall$Input
  | notificationTypeNewPushMessage$Input

/** Describes the type of notifications in a notification group */
export type NotificationGroupType =
  | notificationGroupTypeMessages
  | notificationGroupTypeMentions
  | notificationGroupTypeSecretChat
  | notificationGroupTypeCalls

/** Describes the type of notifications in a notification group */
export type NotificationGroupType$Input =
  | notificationGroupTypeMessages$Input
  | notificationGroupTypeMentions$Input
  | notificationGroupTypeSecretChat$Input
  | notificationGroupTypeCalls$Input

export type Notification =
  | notification

export type Notification$Input =
  | notification$Input

export type NotificationGroup =
  | notificationGroup

export type NotificationGroup$Input =
  | notificationGroup$Input

/** Represents the value of an option */
export type OptionValue =
  | optionValueBoolean
  | optionValueEmpty
  | optionValueInteger
  | optionValueString

/** Represents the value of an option */
export type OptionValue$Input =
  | optionValueBoolean$Input
  | optionValueEmpty$Input
  | optionValueInteger$Input
  | optionValueString$Input

export type JsonObjectMember =
  | jsonObjectMember

export type JsonObjectMember$Input =
  | jsonObjectMember$Input

/** Represents a JSON value */
export type JsonValue =
  | jsonValueNull
  | jsonValueBoolean
  | jsonValueNumber
  | jsonValueString
  | jsonValueArray
  | jsonValueObject

/** Represents a JSON value */
export type JsonValue$Input =
  | jsonValueNull$Input
  | jsonValueBoolean$Input
  | jsonValueNumber$Input
  | jsonValueString$Input
  | jsonValueArray$Input
  | jsonValueObject$Input

/** Represents a single rule for managing privacy settings */
export type UserPrivacySettingRule =
  | userPrivacySettingRuleAllowAll
  | userPrivacySettingRuleAllowContacts
  | userPrivacySettingRuleAllowUsers
  | userPrivacySettingRuleAllowChatMembers
  | userPrivacySettingRuleRestrictAll
  | userPrivacySettingRuleRestrictContacts
  | userPrivacySettingRuleRestrictUsers
  | userPrivacySettingRuleRestrictChatMembers

/** Represents a single rule for managing privacy settings */
export type UserPrivacySettingRule$Input =
  | userPrivacySettingRuleAllowAll$Input
  | userPrivacySettingRuleAllowContacts$Input
  | userPrivacySettingRuleAllowUsers$Input
  | userPrivacySettingRuleAllowChatMembers$Input
  | userPrivacySettingRuleRestrictAll$Input
  | userPrivacySettingRuleRestrictContacts$Input
  | userPrivacySettingRuleRestrictUsers$Input
  | userPrivacySettingRuleRestrictChatMembers$Input

export type UserPrivacySettingRules =
  | userPrivacySettingRules

export type UserPrivacySettingRules$Input =
  | userPrivacySettingRules$Input

/** Describes available user privacy settings */
export type UserPrivacySetting =
  | userPrivacySettingShowStatus
  | userPrivacySettingShowProfilePhoto
  | userPrivacySettingShowLinkInForwardedMessages
  | userPrivacySettingShowPhoneNumber
  | userPrivacySettingAllowChatInvites
  | userPrivacySettingAllowCalls
  | userPrivacySettingAllowPeerToPeerCalls
  | userPrivacySettingAllowFindingByPhoneNumber

/** Describes available user privacy settings */
export type UserPrivacySetting$Input =
  | userPrivacySettingShowStatus$Input
  | userPrivacySettingShowProfilePhoto$Input
  | userPrivacySettingShowLinkInForwardedMessages$Input
  | userPrivacySettingShowPhoneNumber$Input
  | userPrivacySettingAllowChatInvites$Input
  | userPrivacySettingAllowCalls$Input
  | userPrivacySettingAllowPeerToPeerCalls$Input
  | userPrivacySettingAllowFindingByPhoneNumber$Input

export type AccountTtl =
  | accountTtl

export type AccountTtl$Input =
  | accountTtl$Input

export type Session =
  | session

export type Session$Input =
  | session$Input

export type Sessions =
  | sessions

export type Sessions$Input =
  | sessions$Input

export type ConnectedWebsite =
  | connectedWebsite

export type ConnectedWebsite$Input =
  | connectedWebsite$Input

export type ConnectedWebsites =
  | connectedWebsites

export type ConnectedWebsites$Input =
  | connectedWebsites$Input

/** Describes the reason why a chat is reported */
export type ChatReportReason =
  | chatReportReasonSpam
  | chatReportReasonViolence
  | chatReportReasonPornography
  | chatReportReasonChildAbuse
  | chatReportReasonCopyright
  | chatReportReasonUnrelatedLocation
  | chatReportReasonFake
  | chatReportReasonCustom

/** Describes the reason why a chat is reported */
export type ChatReportReason$Input =
  | chatReportReasonSpam$Input
  | chatReportReasonViolence$Input
  | chatReportReasonPornography$Input
  | chatReportReasonChildAbuse$Input
  | chatReportReasonCopyright$Input
  | chatReportReasonUnrelatedLocation$Input
  | chatReportReasonFake$Input
  | chatReportReasonCustom$Input

/**
 * Describes an internal https://t.me or tg: link, which must be processed by the app
 * in a special way
 */
export type InternalLinkType =
  | internalLinkTypeActiveSessions
  | internalLinkTypeAuthenticationCode
  | internalLinkTypeBackground
  | internalLinkTypeBotStart
  | internalLinkTypeBotStartInGroup
  | internalLinkTypeChangePhoneNumber
  | internalLinkTypeChatInvite
  | internalLinkTypeFilterSettings
  | internalLinkTypeGame
  | internalLinkTypeLanguagePack
  | internalLinkTypeMessage
  | internalLinkTypeMessageDraft
  | internalLinkTypePassportDataRequest
  | internalLinkTypePhoneNumberConfirmation
  | internalLinkTypeProxy
  | internalLinkTypePublicChat
  | internalLinkTypeQrCodeAuthentication
  | internalLinkTypeSettings
  | internalLinkTypeStickerSet
  | internalLinkTypeTheme
  | internalLinkTypeThemeSettings
  | internalLinkTypeUnknownDeepLink
  | internalLinkTypeUnsupportedProxy
  | internalLinkTypeVideoChat

/**
 * Describes an internal https://t.me or tg: link, which must be processed by the app
 * in a special way
 */
export type InternalLinkType$Input =
  | internalLinkTypeActiveSessions$Input
  | internalLinkTypeAuthenticationCode$Input
  | internalLinkTypeBackground$Input
  | internalLinkTypeBotStart$Input
  | internalLinkTypeBotStartInGroup$Input
  | internalLinkTypeChangePhoneNumber$Input
  | internalLinkTypeChatInvite$Input
  | internalLinkTypeFilterSettings$Input
  | internalLinkTypeGame$Input
  | internalLinkTypeLanguagePack$Input
  | internalLinkTypeMessage$Input
  | internalLinkTypeMessageDraft$Input
  | internalLinkTypePassportDataRequest$Input
  | internalLinkTypePhoneNumberConfirmation$Input
  | internalLinkTypeProxy$Input
  | internalLinkTypePublicChat$Input
  | internalLinkTypeQrCodeAuthentication$Input
  | internalLinkTypeSettings$Input
  | internalLinkTypeStickerSet$Input
  | internalLinkTypeTheme$Input
  | internalLinkTypeThemeSettings$Input
  | internalLinkTypeUnknownDeepLink$Input
  | internalLinkTypeUnsupportedProxy$Input
  | internalLinkTypeVideoChat$Input

export type MessageLink =
  | messageLink

export type MessageLink$Input =
  | messageLink$Input

export type MessageLinkInfo =
  | messageLinkInfo

export type MessageLinkInfo$Input =
  | messageLinkInfo$Input

export type FilePart =
  | filePart

export type FilePart$Input =
  | filePart$Input

/** Represents the type of a file */
export type FileType =
  | fileTypeNone
  | fileTypeAnimation
  | fileTypeAudio
  | fileTypeDocument
  | fileTypePhoto
  | fileTypeProfilePhoto
  | fileTypeSecret
  | fileTypeSecretThumbnail
  | fileTypeSecure
  | fileTypeSticker
  | fileTypeThumbnail
  | fileTypeUnknown
  | fileTypeVideo
  | fileTypeVideoNote
  | fileTypeVoiceNote
  | fileTypeWallpaper

/** Represents the type of a file */
export type FileType$Input =
  | fileTypeNone$Input
  | fileTypeAnimation$Input
  | fileTypeAudio$Input
  | fileTypeDocument$Input
  | fileTypePhoto$Input
  | fileTypeProfilePhoto$Input
  | fileTypeSecret$Input
  | fileTypeSecretThumbnail$Input
  | fileTypeSecure$Input
  | fileTypeSticker$Input
  | fileTypeThumbnail$Input
  | fileTypeUnknown$Input
  | fileTypeVideo$Input
  | fileTypeVideoNote$Input
  | fileTypeVoiceNote$Input
  | fileTypeWallpaper$Input

export type StorageStatisticsByFileType =
  | storageStatisticsByFileType

export type StorageStatisticsByFileType$Input =
  | storageStatisticsByFileType$Input

export type StorageStatisticsByChat =
  | storageStatisticsByChat

export type StorageStatisticsByChat$Input =
  | storageStatisticsByChat$Input

export type StorageStatistics =
  | storageStatistics

export type StorageStatistics$Input =
  | storageStatistics$Input

export type StorageStatisticsFast =
  | storageStatisticsFast

export type StorageStatisticsFast$Input =
  | storageStatisticsFast$Input

export type DatabaseStatistics =
  | databaseStatistics

export type DatabaseStatistics$Input =
  | databaseStatistics$Input

/** Represents the type of a network */
export type NetworkType =
  | networkTypeNone
  | networkTypeMobile
  | networkTypeMobileRoaming
  | networkTypeWiFi
  | networkTypeOther

/** Represents the type of a network */
export type NetworkType$Input =
  | networkTypeNone$Input
  | networkTypeMobile$Input
  | networkTypeMobileRoaming$Input
  | networkTypeWiFi$Input
  | networkTypeOther$Input

/** Contains statistics about network usage */
export type NetworkStatisticsEntry =
  | networkStatisticsEntryFile
  | networkStatisticsEntryCall

/** Contains statistics about network usage */
export type NetworkStatisticsEntry$Input =
  | networkStatisticsEntryFile$Input
  | networkStatisticsEntryCall$Input

export type NetworkStatistics =
  | networkStatistics

export type NetworkStatistics$Input =
  | networkStatistics$Input

export type AutoDownloadSettings =
  | autoDownloadSettings

export type AutoDownloadSettings$Input =
  | autoDownloadSettings$Input

export type AutoDownloadSettingsPresets =
  | autoDownloadSettingsPresets

export type AutoDownloadSettingsPresets$Input =
  | autoDownloadSettingsPresets$Input

/** Describes the current state of the connection to Telegram servers */
export type ConnectionState =
  | connectionStateWaitingForNetwork
  | connectionStateConnectingToProxy
  | connectionStateConnecting
  | connectionStateUpdating
  | connectionStateReady

/** Describes the current state of the connection to Telegram servers */
export type ConnectionState$Input =
  | connectionStateWaitingForNetwork$Input
  | connectionStateConnectingToProxy$Input
  | connectionStateConnecting$Input
  | connectionStateUpdating$Input
  | connectionStateReady$Input

/**
 * Represents the categories of chats for which a list of frequently used chats can
 * be retrieved
 */
export type TopChatCategory =
  | topChatCategoryUsers
  | topChatCategoryBots
  | topChatCategoryGroups
  | topChatCategoryChannels
  | topChatCategoryInlineBots
  | topChatCategoryCalls
  | topChatCategoryForwardChats

/**
 * Represents the categories of chats for which a list of frequently used chats can
 * be retrieved
 */
export type TopChatCategory$Input =
  | topChatCategoryUsers$Input
  | topChatCategoryBots$Input
  | topChatCategoryGroups$Input
  | topChatCategoryChannels$Input
  | topChatCategoryInlineBots$Input
  | topChatCategoryCalls$Input
  | topChatCategoryForwardChats$Input

/** Describes the type of a URL linking to an internal Telegram entity */
export type TMeUrlType =
  | tMeUrlTypeUser
  | tMeUrlTypeSupergroup
  | tMeUrlTypeChatInvite
  | tMeUrlTypeStickerSet

/** Describes the type of a URL linking to an internal Telegram entity */
export type TMeUrlType$Input =
  | tMeUrlTypeUser$Input
  | tMeUrlTypeSupergroup$Input
  | tMeUrlTypeChatInvite$Input
  | tMeUrlTypeStickerSet$Input

export type TMeUrl =
  | tMeUrl

export type TMeUrl$Input =
  | tMeUrl$Input

export type TMeUrls =
  | tMeUrls

export type TMeUrls$Input =
  | tMeUrls$Input

/** Describes an action suggested to the current user */
export type SuggestedAction =
  | suggestedActionEnableArchiveAndMuteNewChats
  | suggestedActionCheckPassword
  | suggestedActionCheckPhoneNumber
  | suggestedActionViewChecksHint
  | suggestedActionConvertToBroadcastGroup
  | suggestedActionSetPassword

/** Describes an action suggested to the current user */
export type SuggestedAction$Input =
  | suggestedActionEnableArchiveAndMuteNewChats$Input
  | suggestedActionCheckPassword$Input
  | suggestedActionCheckPhoneNumber$Input
  | suggestedActionViewChecksHint$Input
  | suggestedActionConvertToBroadcastGroup$Input
  | suggestedActionSetPassword$Input

export type Count =
  | count

export type Count$Input =
  | count$Input

export type Text =
  | text

export type Text$Input =
  | text$Input

export type Seconds =
  | seconds

export type Seconds$Input =
  | seconds$Input

export type DeepLinkInfo =
  | deepLinkInfo

export type DeepLinkInfo$Input =
  | deepLinkInfo$Input

/** Describes the way the text needs to be parsed for TextEntities */
export type TextParseMode =
  | textParseModeMarkdown
  | textParseModeHTML

/** Describes the way the text needs to be parsed for TextEntities */
export type TextParseMode$Input =
  | textParseModeMarkdown$Input
  | textParseModeHTML$Input

/** Describes the type of a proxy server */
export type ProxyType =
  | proxyTypeSocks5
  | proxyTypeHttp
  | proxyTypeMtproto

/** Describes the type of a proxy server */
export type ProxyType$Input =
  | proxyTypeSocks5$Input
  | proxyTypeHttp$Input
  | proxyTypeMtproto$Input

export type Proxy =
  | proxy

export type Proxy$Input =
  | proxy$Input

export type Proxies =
  | proxies

export type Proxies$Input =
  | proxies$Input

/** Describes a sticker that needs to be added to a sticker set */
export type InputSticker =
  | inputStickerStatic
  | inputStickerAnimated

/** Describes a sticker that needs to be added to a sticker set */
export type InputSticker$Input =
  | inputStickerStatic$Input
  | inputStickerAnimated$Input

export type DateRange =
  | dateRange

export type DateRange$Input =
  | dateRange$Input

export type StatisticalValue =
  | statisticalValue

export type StatisticalValue$Input =
  | statisticalValue$Input

/** Describes a statistical graph */
export type StatisticalGraph =
  | statisticalGraphData
  | statisticalGraphAsync
  | statisticalGraphError

/** Describes a statistical graph */
export type StatisticalGraph$Input =
  | statisticalGraphData$Input
  | statisticalGraphAsync$Input
  | statisticalGraphError$Input

export type ChatStatisticsMessageInteractionInfo =
  | chatStatisticsMessageInteractionInfo

export type ChatStatisticsMessageInteractionInfo$Input =
  | chatStatisticsMessageInteractionInfo$Input

export type ChatStatisticsMessageSenderInfo =
  | chatStatisticsMessageSenderInfo

export type ChatStatisticsMessageSenderInfo$Input =
  | chatStatisticsMessageSenderInfo$Input

export type ChatStatisticsAdministratorActionsInfo =
  | chatStatisticsAdministratorActionsInfo

export type ChatStatisticsAdministratorActionsInfo$Input =
  | chatStatisticsAdministratorActionsInfo$Input

export type ChatStatisticsInviterInfo =
  | chatStatisticsInviterInfo

export type ChatStatisticsInviterInfo$Input =
  | chatStatisticsInviterInfo$Input

/** Contains a detailed statistics about a chat */
export type ChatStatistics =
  | chatStatisticsSupergroup
  | chatStatisticsChannel

/** Contains a detailed statistics about a chat */
export type ChatStatistics$Input =
  | chatStatisticsSupergroup$Input
  | chatStatisticsChannel$Input

export type MessageStatistics =
  | messageStatistics

export type MessageStatistics$Input =
  | messageStatistics$Input

export type Point =
  | point

export type Point$Input =
  | point$Input

/** Represents a vector path command */
export type VectorPathCommand =
  | vectorPathCommandLine
  | vectorPathCommandCubicBezierCurve

/** Represents a vector path command */
export type VectorPathCommand$Input =
  | vectorPathCommandLine$Input
  | vectorPathCommandCubicBezierCurve$Input

/** Represents the scope to which bot commands are relevant */
export type BotCommandScope =
  | botCommandScopeDefault
  | botCommandScopeAllPrivateChats
  | botCommandScopeAllGroupChats
  | botCommandScopeAllChatAdministrators
  | botCommandScopeChat
  | botCommandScopeChatAdministrators
  | botCommandScopeChatMember

/** Represents the scope to which bot commands are relevant */
export type BotCommandScope$Input =
  | botCommandScopeDefault$Input
  | botCommandScopeAllPrivateChats$Input
  | botCommandScopeAllGroupChats$Input
  | botCommandScopeAllChatAdministrators$Input
  | botCommandScopeChat$Input
  | botCommandScopeChatAdministrators$Input
  | botCommandScopeChatMember$Input

/** Contains notifications about data changes */
export type Update =
  | updateAuthorizationState
  | updateNewMessage
  | updateMessageSendAcknowledged
  | updateMessageSendSucceeded
  | updateMessageSendFailed
  | updateMessageContent
  | updateMessageEdited
  | updateMessageIsPinned
  | updateMessageInteractionInfo
  | updateMessageContentOpened
  | updateMessageMentionRead
  | updateMessageLiveLocationViewed
  | updateNewChat
  | updateChatTitle
  | updateChatPhoto
  | updateChatPermissions
  | updateChatLastMessage
  | updateChatPosition
  | updateChatReadInbox
  | updateChatReadOutbox
  | updateChatActionBar
  | updateChatDraftMessage
  | updateChatMessageSender
  | updateChatMessageTtl
  | updateChatNotificationSettings
  | updateChatPendingJoinRequests
  | updateChatReplyMarkup
  | updateChatTheme
  | updateChatUnreadMentionCount
  | updateChatVideoChat
  | updateChatDefaultDisableNotification
  | updateChatHasProtectedContent
  | updateChatHasScheduledMessages
  | updateChatIsBlocked
  | updateChatIsMarkedAsUnread
  | updateChatFilters
  | updateChatOnlineMemberCount
  | updateScopeNotificationSettings
  | updateNotification
  | updateNotificationGroup
  | updateActiveNotifications
  | updateHavePendingNotifications
  | updateDeleteMessages
  | updateChatAction
  | updateUserStatus
  | updateUser
  | updateBasicGroup
  | updateSupergroup
  | updateSecretChat
  | updateUserFullInfo
  | updateBasicGroupFullInfo
  | updateSupergroupFullInfo
  | updateServiceNotification
  | updateFile
  | updateFileGenerationStart
  | updateFileGenerationStop
  | updateCall
  | updateGroupCall
  | updateGroupCallParticipant
  | updateNewCallSignalingData
  | updateUserPrivacySettingRules
  | updateUnreadMessageCount
  | updateUnreadChatCount
  | updateOption
  | updateStickerSet
  | updateInstalledStickerSets
  | updateTrendingStickerSets
  | updateRecentStickers
  | updateFavoriteStickers
  | updateSavedAnimations
  | updateSelectedBackground
  | updateChatThemes
  | updateLanguagePackStrings
  | updateConnectionState
  | updateTermsOfService
  | updateUsersNearby
  | updateDiceEmojis
  | updateAnimatedEmojiMessageClicked
  | updateAnimationSearchParameters
  | updateSuggestedActions
  | updateNewInlineQuery
  | updateNewChosenInlineResult
  | updateNewCallbackQuery
  | updateNewInlineCallbackQuery
  | updateNewShippingQuery
  | updateNewPreCheckoutQuery
  | updateNewCustomEvent
  | updateNewCustomQuery
  | updatePoll
  | updatePollAnswer
  | updateChatMember
  | updateNewChatJoinRequest

/** Contains notifications about data changes */
export type Update$Input =
  | updateAuthorizationState$Input
  | updateNewMessage$Input
  | updateMessageSendAcknowledged$Input
  | updateMessageSendSucceeded$Input
  | updateMessageSendFailed$Input
  | updateMessageContent$Input
  | updateMessageEdited$Input
  | updateMessageIsPinned$Input
  | updateMessageInteractionInfo$Input
  | updateMessageContentOpened$Input
  | updateMessageMentionRead$Input
  | updateMessageLiveLocationViewed$Input
  | updateNewChat$Input
  | updateChatTitle$Input
  | updateChatPhoto$Input
  | updateChatPermissions$Input
  | updateChatLastMessage$Input
  | updateChatPosition$Input
  | updateChatReadInbox$Input
  | updateChatReadOutbox$Input
  | updateChatActionBar$Input
  | updateChatDraftMessage$Input
  | updateChatMessageSender$Input
  | updateChatMessageTtl$Input
  | updateChatNotificationSettings$Input
  | updateChatPendingJoinRequests$Input
  | updateChatReplyMarkup$Input
  | updateChatTheme$Input
  | updateChatUnreadMentionCount$Input
  | updateChatVideoChat$Input
  | updateChatDefaultDisableNotification$Input
  | updateChatHasProtectedContent$Input
  | updateChatHasScheduledMessages$Input
  | updateChatIsBlocked$Input
  | updateChatIsMarkedAsUnread$Input
  | updateChatFilters$Input
  | updateChatOnlineMemberCount$Input
  | updateScopeNotificationSettings$Input
  | updateNotification$Input
  | updateNotificationGroup$Input
  | updateActiveNotifications$Input
  | updateHavePendingNotifications$Input
  | updateDeleteMessages$Input
  | updateChatAction$Input
  | updateUserStatus$Input
  | updateUser$Input
  | updateBasicGroup$Input
  | updateSupergroup$Input
  | updateSecretChat$Input
  | updateUserFullInfo$Input
  | updateBasicGroupFullInfo$Input
  | updateSupergroupFullInfo$Input
  | updateServiceNotification$Input
  | updateFile$Input
  | updateFileGenerationStart$Input
  | updateFileGenerationStop$Input
  | updateCall$Input
  | updateGroupCall$Input
  | updateGroupCallParticipant$Input
  | updateNewCallSignalingData$Input
  | updateUserPrivacySettingRules$Input
  | updateUnreadMessageCount$Input
  | updateUnreadChatCount$Input
  | updateOption$Input
  | updateStickerSet$Input
  | updateInstalledStickerSets$Input
  | updateTrendingStickerSets$Input
  | updateRecentStickers$Input
  | updateFavoriteStickers$Input
  | updateSavedAnimations$Input
  | updateSelectedBackground$Input
  | updateChatThemes$Input
  | updateLanguagePackStrings$Input
  | updateConnectionState$Input
  | updateTermsOfService$Input
  | updateUsersNearby$Input
  | updateDiceEmojis$Input
  | updateAnimatedEmojiMessageClicked$Input
  | updateAnimationSearchParameters$Input
  | updateSuggestedActions$Input
  | updateNewInlineQuery$Input
  | updateNewChosenInlineResult$Input
  | updateNewCallbackQuery$Input
  | updateNewInlineCallbackQuery$Input
  | updateNewShippingQuery$Input
  | updateNewPreCheckoutQuery$Input
  | updateNewCustomEvent$Input
  | updateNewCustomQuery$Input
  | updatePoll$Input
  | updatePollAnswer$Input
  | updateChatMember$Input
  | updateNewChatJoinRequest$Input

export type Updates =
  | updates

export type Updates$Input =
  | updates$Input

/** Describes a stream to which TDLib internal log is written */
export type LogStream =
  | logStreamDefault
  | logStreamFile
  | logStreamEmpty

/** Describes a stream to which TDLib internal log is written */
export type LogStream$Input =
  | logStreamDefault$Input
  | logStreamFile$Input
  | logStreamEmpty$Input

export type LogVerbosityLevel =
  | logVerbosityLevel

export type LogVerbosityLevel$Input =
  | logVerbosityLevel$Input

export type LogTags =
  | logTags

export type LogTags$Input =
  | logTags$Input

export type TestInt =
  | testInt

export type TestInt$Input =
  | testInt$Input

export type TestString =
  | testString

export type TestString$Input =
  | testString$Input

export type TestBytes =
  | testBytes

export type TestBytes$Input =
  | testBytes$Input

export type TestVectorInt =
  | testVectorInt

export type TestVectorInt$Input =
  | testVectorInt$Input

export type TestVectorIntObject =
  | testVectorIntObject

export type TestVectorIntObject$Input =
  | testVectorIntObject$Input

export type TestVectorString =
  | testVectorString

export type TestVectorString$Input =
  | testVectorString$Input

export type TestVectorStringObject =
  | testVectorStringObject

export type TestVectorStringObject$Input =
  | testVectorStringObject$Input

export type TDFunction =
  | getAuthorizationState
  | setTdlibParameters
  | checkDatabaseEncryptionKey
  | setAuthenticationPhoneNumber
  | resendAuthenticationCode
  | checkAuthenticationCode
  | requestQrCodeAuthentication
  | registerUser
  | checkAuthenticationPassword
  | requestAuthenticationPasswordRecovery
  | checkAuthenticationPasswordRecoveryCode
  | recoverAuthenticationPassword
  | checkAuthenticationBotToken
  | logOut
  | close
  | destroy
  | confirmQrCodeAuthentication
  | getCurrentState
  | setDatabaseEncryptionKey
  | getPasswordState
  | setPassword
  | getRecoveryEmailAddress
  | setRecoveryEmailAddress
  | checkRecoveryEmailAddressCode
  | resendRecoveryEmailAddressCode
  | requestPasswordRecovery
  | checkPasswordRecoveryCode
  | recoverPassword
  | resetPassword
  | cancelPasswordReset
  | createTemporaryPassword
  | getTemporaryPasswordState
  | getMe
  | getUser
  | getUserFullInfo
  | getBasicGroup
  | getBasicGroupFullInfo
  | getSupergroup
  | getSupergroupFullInfo
  | getSecretChat
  | getChat
  | getMessage
  | getMessageLocally
  | getRepliedMessage
  | getChatPinnedMessage
  | getCallbackQueryMessage
  | getMessages
  | getMessageThread
  | getMessageViewers
  | getFile
  | getRemoteFile
  | loadChats
  | getChats
  | searchPublicChat
  | searchPublicChats
  | searchChats
  | searchChatsOnServer
  | searchChatsNearby
  | getTopChats
  | removeTopChat
  | addRecentlyFoundChat
  | removeRecentlyFoundChat
  | clearRecentlyFoundChats
  | getRecentlyOpenedChats
  | checkChatUsername
  | getCreatedPublicChats
  | checkCreatedPublicChatsLimit
  | getSuitableDiscussionChats
  | getInactiveSupergroupChats
  | getGroupsInCommon
  | getChatHistory
  | getMessageThreadHistory
  | deleteChatHistory
  | deleteChat
  | searchChatMessages
  | searchMessages
  | searchSecretMessages
  | searchCallMessages
  | deleteAllCallMessages
  | searchChatRecentLocationMessages
  | getActiveLiveLocationMessages
  | getChatMessageByDate
  | getChatSparseMessagePositions
  | getChatMessageCalendar
  | getChatMessageCount
  | getChatScheduledMessages
  | getMessagePublicForwards
  | getChatSponsoredMessage
  | removeNotification
  | removeNotificationGroup
  | getMessageLink
  | getMessageEmbeddingCode
  | getMessageLinkInfo
  | getChatAvailableMessageSenders
  | setChatMessageSender
  | sendMessage
  | sendMessageAlbum
  | sendBotStartMessage
  | sendInlineQueryResultMessage
  | forwardMessages
  | resendMessages
  | sendChatScreenshotTakenNotification
  | addLocalMessage
  | deleteMessages
  | deleteChatMessagesBySender
  | deleteChatMessagesByDate
  | editMessageText
  | editMessageLiveLocation
  | editMessageMedia
  | editMessageCaption
  | editMessageReplyMarkup
  | editInlineMessageText
  | editInlineMessageLiveLocation
  | editInlineMessageMedia
  | editInlineMessageCaption
  | editInlineMessageReplyMarkup
  | editMessageSchedulingState
  | getTextEntities
  | parseTextEntities
  | parseMarkdown
  | getMarkdownText
  | getFileMimeType
  | getFileExtension
  | cleanFileName
  | getLanguagePackString
  | getJsonValue
  | getJsonString
  | setPollAnswer
  | getPollVoters
  | stopPoll
  | hideSuggestedAction
  | getLoginUrlInfo
  | getLoginUrl
  | getInlineQueryResults
  | answerInlineQuery
  | getCallbackQueryAnswer
  | answerCallbackQuery
  | answerShippingQuery
  | answerPreCheckoutQuery
  | setGameScore
  | setInlineGameScore
  | getGameHighScores
  | getInlineGameHighScores
  | deleteChatReplyMarkup
  | sendChatAction
  | openChat
  | closeChat
  | viewMessages
  | openMessageContent
  | clickAnimatedEmojiMessage
  | getInternalLinkType
  | getExternalLinkInfo
  | getExternalLink
  | readAllChatMentions
  | createPrivateChat
  | createBasicGroupChat
  | createSupergroupChat
  | createSecretChat
  | createNewBasicGroupChat
  | createNewSupergroupChat
  | createNewSecretChat
  | upgradeBasicGroupChatToSupergroupChat
  | getChatListsToAddChat
  | addChatToList
  | getChatFilter
  | createChatFilter
  | editChatFilter
  | deleteChatFilter
  | reorderChatFilters
  | getRecommendedChatFilters
  | getChatFilterDefaultIconName
  | setChatTitle
  | setChatPhoto
  | setChatMessageTtl
  | setChatPermissions
  | setChatTheme
  | setChatDraftMessage
  | setChatNotificationSettings
  | toggleChatHasProtectedContent
  | toggleChatIsMarkedAsUnread
  | toggleChatDefaultDisableNotification
  | setChatClientData
  | setChatDescription
  | setChatDiscussionGroup
  | setChatLocation
  | setChatSlowModeDelay
  | pinChatMessage
  | unpinChatMessage
  | unpinAllChatMessages
  | joinChat
  | leaveChat
  | addChatMember
  | addChatMembers
  | setChatMemberStatus
  | banChatMember
  | canTransferOwnership
  | transferChatOwnership
  | getChatMember
  | searchChatMembers
  | getChatAdministrators
  | clearAllDraftMessages
  | getChatNotificationSettingsExceptions
  | getScopeNotificationSettings
  | setScopeNotificationSettings
  | resetAllNotificationSettings
  | toggleChatIsPinned
  | setPinnedChats
  | downloadFile
  | getFileDownloadedPrefixSize
  | cancelDownloadFile
  | getSuggestedFileName
  | uploadFile
  | cancelUploadFile
  | writeGeneratedFilePart
  | setFileGenerationProgress
  | finishFileGeneration
  | readFilePart
  | deleteFile
  | getMessageFileType
  | getMessageImportConfirmationText
  | importMessages
  | replacePrimaryChatInviteLink
  | createChatInviteLink
  | editChatInviteLink
  | getChatInviteLink
  | getChatInviteLinkCounts
  | getChatInviteLinks
  | getChatInviteLinkMembers
  | revokeChatInviteLink
  | deleteRevokedChatInviteLink
  | deleteAllRevokedChatInviteLinks
  | checkChatInviteLink
  | joinChatByInviteLink
  | getChatJoinRequests
  | processChatJoinRequest
  | processChatJoinRequests
  | createCall
  | acceptCall
  | sendCallSignalingData
  | discardCall
  | sendCallRating
  | sendCallDebugInformation
  | getVideoChatAvailableParticipants
  | setVideoChatDefaultParticipant
  | createVideoChat
  | getGroupCall
  | startScheduledGroupCall
  | toggleGroupCallEnabledStartNotification
  | joinGroupCall
  | startGroupCallScreenSharing
  | toggleGroupCallScreenSharingIsPaused
  | endGroupCallScreenSharing
  | setGroupCallTitle
  | toggleGroupCallMuteNewParticipants
  | inviteGroupCallParticipants
  | getGroupCallInviteLink
  | revokeGroupCallInviteLink
  | startGroupCallRecording
  | endGroupCallRecording
  | toggleGroupCallIsMyVideoPaused
  | toggleGroupCallIsMyVideoEnabled
  | setGroupCallParticipantIsSpeaking
  | toggleGroupCallParticipantIsMuted
  | setGroupCallParticipantVolumeLevel
  | toggleGroupCallParticipantIsHandRaised
  | loadGroupCallParticipants
  | leaveGroupCall
  | endGroupCall
  | getGroupCallStreamSegment
  | toggleMessageSenderIsBlocked
  | blockMessageSenderFromReplies
  | getBlockedMessageSenders
  | addContact
  | importContacts
  | getContacts
  | searchContacts
  | removeContacts
  | getImportedContactCount
  | changeImportedContacts
  | clearImportedContacts
  | sharePhoneNumber
  | getUserProfilePhotos
  | getStickers
  | searchStickers
  | getInstalledStickerSets
  | getArchivedStickerSets
  | getTrendingStickerSets
  | getAttachedStickerSets
  | getStickerSet
  | searchStickerSet
  | searchInstalledStickerSets
  | searchStickerSets
  | changeStickerSet
  | viewTrendingStickerSets
  | reorderInstalledStickerSets
  | getRecentStickers
  | addRecentSticker
  | removeRecentSticker
  | clearRecentStickers
  | getFavoriteStickers
  | addFavoriteSticker
  | removeFavoriteSticker
  | getStickerEmojis
  | searchEmojis
  | getAnimatedEmoji
  | getEmojiSuggestionsUrl
  | getSavedAnimations
  | addSavedAnimation
  | removeSavedAnimation
  | getRecentInlineBots
  | searchHashtags
  | removeRecentHashtag
  | getWebPagePreview
  | getWebPageInstantView
  | setProfilePhoto
  | deleteProfilePhoto
  | setName
  | setBio
  | setUsername
  | setLocation
  | changePhoneNumber
  | resendChangePhoneNumberCode
  | checkChangePhoneNumberCode
  | setCommands
  | deleteCommands
  | getCommands
  | getActiveSessions
  | terminateSession
  | terminateAllOtherSessions
  | toggleSessionCanAcceptCalls
  | toggleSessionCanAcceptSecretChats
  | setInactiveSessionTtl
  | getConnectedWebsites
  | disconnectWebsite
  | disconnectAllWebsites
  | setSupergroupUsername
  | setSupergroupStickerSet
  | toggleSupergroupSignMessages
  | toggleSupergroupIsAllHistoryAvailable
  | toggleSupergroupIsBroadcastGroup
  | reportSupergroupSpam
  | getSupergroupMembers
  | closeSecretChat
  | getChatEventLog
  | getPaymentForm
  | validateOrderInfo
  | sendPaymentForm
  | getPaymentReceipt
  | getSavedOrderInfo
  | deleteSavedOrderInfo
  | deleteSavedCredentials
  | getSupportUser
  | getBackgrounds
  | getBackgroundUrl
  | searchBackground
  | setBackground
  | removeBackground
  | resetBackgrounds
  | getLocalizationTargetInfo
  | getLanguagePackInfo
  | getLanguagePackStrings
  | synchronizeLanguagePack
  | addCustomServerLanguagePack
  | setCustomLanguagePack
  | editCustomLanguagePackInfo
  | setCustomLanguagePackString
  | deleteLanguagePack
  | registerDevice
  | processPushNotification
  | getPushReceiverId
  | getRecentlyVisitedTMeUrls
  | setUserPrivacySettingRules
  | getUserPrivacySettingRules
  | getOption
  | setOption
  | setAccountTtl
  | getAccountTtl
  | deleteAccount
  | removeChatActionBar
  | reportChat
  | reportChatPhoto
  | getChatStatistics
  | getMessageStatistics
  | getStatisticalGraph
  | getStorageStatistics
  | getStorageStatisticsFast
  | getDatabaseStatistics
  | optimizeStorage
  | setNetworkType
  | getNetworkStatistics
  | addNetworkStatistics
  | resetNetworkStatistics
  | getAutoDownloadSettingsPresets
  | setAutoDownloadSettings
  | getBankCardInfo
  | getPassportElement
  | getAllPassportElements
  | setPassportElement
  | deletePassportElement
  | setPassportElementErrors
  | getPreferredCountryLanguage
  | sendPhoneNumberVerificationCode
  | resendPhoneNumberVerificationCode
  | checkPhoneNumberVerificationCode
  | sendEmailAddressVerificationCode
  | resendEmailAddressVerificationCode
  | checkEmailAddressVerificationCode
  | getPassportAuthorizationForm
  | getPassportAuthorizationFormAvailableElements
  | sendPassportAuthorizationForm
  | sendPhoneNumberConfirmationCode
  | resendPhoneNumberConfirmationCode
  | checkPhoneNumberConfirmationCode
  | setBotUpdatesStatus
  | uploadStickerFile
  | getSuggestedStickerSetName
  | checkStickerSetName
  | createNewStickerSet
  | addStickerToSet
  | setStickerSetThumbnail
  | setStickerPositionInSet
  | removeStickerFromSet
  | getMapThumbnailFile
  | acceptTermsOfService
  | sendCustomRequest
  | answerCustomQuery
  | setAlarm
  | getCountries
  | getCountryCode
  | getPhoneNumberInfo
  | getPhoneNumberInfoSync
  | getApplicationDownloadLink
  | getDeepLinkInfo
  | getApplicationConfig
  | saveApplicationLogEvent
  | addProxy
  | editProxy
  | enableProxy
  | disableProxy
  | removeProxy
  | getProxies
  | getProxyLink
  | pingProxy
  | setLogStream
  | getLogStream
  | setLogVerbosityLevel
  | getLogVerbosityLevel
  | getLogTags
  | setLogTagVerbosityLevel
  | getLogTagVerbosityLevel
  | addLogMessage
  | testCallEmpty
  | testCallString
  | testCallBytes
  | testCallVectorInt
  | testCallVectorIntObject
  | testCallVectorString
  | testCallVectorStringObject
  | testSquareInt
  | testNetwork
  | testProxy
  | testGetDifference
  | testUseUpdate
  | testReturnError

export type TDObject =
  | Error
  | Ok
  | TdlibParameters
  | AuthenticationCodeType
  | AuthenticationCodeInfo
  | EmailAddressAuthenticationCodeInfo
  | TextEntity
  | TextEntities
  | FormattedText
  | TermsOfService
  | AuthorizationState
  | PasswordState
  | RecoveryEmailAddress
  | TemporaryPasswordState
  | LocalFile
  | RemoteFile
  | File
  | InputFile
  | PhotoSize
  | Minithumbnail
  | ThumbnailFormat
  | Thumbnail
  | MaskPoint
  | MaskPosition
  | ClosedVectorPath
  | PollOption
  | PollType
  | Animation
  | Audio
  | Document
  | Photo
  | Sticker
  | Video
  | VideoNote
  | VoiceNote
  | AnimatedEmoji
  | Contact
  | Location
  | Venue
  | Game
  | Poll
  | ProfilePhoto
  | ChatPhotoInfo
  | UserType
  | BotCommand
  | BotCommands
  | ChatLocation
  | AnimatedChatPhoto
  | ChatPhoto
  | ChatPhotos
  | InputChatPhoto
  | User
  | UserFullInfo
  | Users
  | ChatAdministrator
  | ChatAdministrators
  | ChatPermissions
  | ChatMemberStatus
  | ChatMember
  | ChatMembers
  | ChatMembersFilter
  | SupergroupMembersFilter
  | ChatInviteLink
  | ChatInviteLinks
  | ChatInviteLinkCount
  | ChatInviteLinkCounts
  | ChatInviteLinkMember
  | ChatInviteLinkMembers
  | ChatInviteLinkInfo
  | ChatJoinRequest
  | ChatJoinRequests
  | ChatJoinRequestsInfo
  | BasicGroup
  | BasicGroupFullInfo
  | Supergroup
  | SupergroupFullInfo
  | SecretChatState
  | SecretChat
  | MessageSender
  | MessageSenders
  | MessageForwardOrigin
  | MessageForwardInfo
  | MessageReplyInfo
  | MessageInteractionInfo
  | MessageSendingState
  | Message
  | Messages
  | FoundMessages
  | MessagePosition
  | MessagePositions
  | MessageCalendarDay
  | MessageCalendar
  | SponsoredMessage
  | NotificationSettingsScope
  | ChatNotificationSettings
  | ScopeNotificationSettings
  | DraftMessage
  | ChatType
  | ChatFilter
  | ChatFilterInfo
  | RecommendedChatFilter
  | RecommendedChatFilters
  | ChatList
  | ChatLists
  | ChatSource
  | ChatPosition
  | VideoChat
  | Chat
  | Chats
  | ChatNearby
  | ChatsNearby
  | PublicChatType
  | ChatActionBar
  | KeyboardButtonType
  | KeyboardButton
  | InlineKeyboardButtonType
  | InlineKeyboardButton
  | ReplyMarkup
  | LoginUrlInfo
  | MessageThreadInfo
  | RichText
  | PageBlockCaption
  | PageBlockListItem
  | PageBlockHorizontalAlignment
  | PageBlockVerticalAlignment
  | PageBlockTableCell
  | PageBlockRelatedArticle
  | PageBlock
  | WebPageInstantView
  | WebPage
  | CountryInfo
  | Countries
  | PhoneNumberInfo
  | BankCardActionOpenUrl
  | BankCardInfo
  | Address
  | LabeledPricePart
  | Invoice
  | OrderInfo
  | ShippingOption
  | SavedCredentials
  | InputCredentials
  | PaymentsProviderStripe
  | PaymentFormTheme
  | PaymentForm
  | ValidatedOrderInfo
  | PaymentResult
  | PaymentReceipt
  | DatedFile
  | PassportElementType
  | Date
  | PersonalDetails
  | IdentityDocument
  | InputIdentityDocument
  | PersonalDocument
  | InputPersonalDocument
  | PassportElement
  | InputPassportElement
  | PassportElements
  | PassportElementErrorSource
  | PassportElementError
  | PassportSuitableElement
  | PassportRequiredElement
  | PassportAuthorizationForm
  | PassportElementsWithErrors
  | EncryptedCredentials
  | EncryptedPassportElement
  | InputPassportElementErrorSource
  | InputPassportElementError
  | MessageContent
  | TextEntityType
  | InputThumbnail
  | MessageSchedulingState
  | MessageSendOptions
  | MessageCopyOptions
  | InputMessageContent
  | SearchMessagesFilter
  | ChatAction
  | UserStatus
  | Stickers
  | Emojis
  | StickerSet
  | StickerSetInfo
  | StickerSets
  | CallDiscardReason
  | CallProtocol
  | CallServerType
  | CallServer
  | CallId
  | GroupCallId
  | CallState
  | GroupCallVideoQuality
  | GroupCallRecentSpeaker
  | GroupCall
  | GroupCallVideoSourceGroup
  | GroupCallParticipantVideoInfo
  | GroupCallParticipant
  | CallProblem
  | Call
  | PhoneNumberAuthenticationSettings
  | Animations
  | DiceStickers
  | ImportedContacts
  | HttpUrl
  | InputInlineQueryResult
  | InlineQueryResult
  | InlineQueryResults
  | CallbackQueryPayload
  | CallbackQueryAnswer
  | CustomRequestResult
  | GameHighScore
  | GameHighScores
  | ChatEventAction
  | ChatEvent
  | ChatEvents
  | ChatEventLogFilters
  | LanguagePackStringValue
  | LanguagePackString
  | LanguagePackStrings
  | LanguagePackInfo
  | LocalizationTargetInfo
  | DeviceToken
  | PushReceiverId
  | BackgroundFill
  | BackgroundType
  | Background
  | Backgrounds
  | InputBackground
  | ThemeSettings
  | ChatTheme
  | Hashtags
  | CanTransferOwnershipResult
  | CheckChatUsernameResult
  | CheckStickerSetNameResult
  | ResetPasswordResult
  | MessageFileType
  | PushMessageContent
  | NotificationType
  | NotificationGroupType
  | Notification
  | NotificationGroup
  | OptionValue
  | JsonObjectMember
  | JsonValue
  | UserPrivacySettingRule
  | UserPrivacySettingRules
  | UserPrivacySetting
  | AccountTtl
  | Session
  | Sessions
  | ConnectedWebsite
  | ConnectedWebsites
  | ChatReportReason
  | InternalLinkType
  | MessageLink
  | MessageLinkInfo
  | FilePart
  | FileType
  | StorageStatisticsByFileType
  | StorageStatisticsByChat
  | StorageStatistics
  | StorageStatisticsFast
  | DatabaseStatistics
  | NetworkType
  | NetworkStatisticsEntry
  | NetworkStatistics
  | AutoDownloadSettings
  | AutoDownloadSettingsPresets
  | ConnectionState
  | TopChatCategory
  | TMeUrlType
  | TMeUrl
  | TMeUrls
  | SuggestedAction
  | Count
  | Text
  | Seconds
  | DeepLinkInfo
  | TextParseMode
  | ProxyType
  | Proxy
  | Proxies
  | InputSticker
  | DateRange
  | StatisticalValue
  | StatisticalGraph
  | ChatStatisticsMessageInteractionInfo
  | ChatStatisticsMessageSenderInfo
  | ChatStatisticsAdministratorActionsInfo
  | ChatStatisticsInviterInfo
  | ChatStatistics
  | MessageStatistics
  | Point
  | VectorPathCommand
  | BotCommandScope
  | Update
  | Updates
  | LogStream
  | LogVerbosityLevel
  | LogTags
  | TestInt
  | TestString
  | TestBytes
  | TestVectorInt
  | TestVectorIntObject
  | TestVectorString
  | TestVectorStringObject

export type TDObject$Input =
  | Error$Input
  | Ok$Input
  | TdlibParameters$Input
  | AuthenticationCodeType$Input
  | AuthenticationCodeInfo$Input
  | EmailAddressAuthenticationCodeInfo$Input
  | TextEntity$Input
  | TextEntities$Input
  | FormattedText$Input
  | TermsOfService$Input
  | AuthorizationState$Input
  | PasswordState$Input
  | RecoveryEmailAddress$Input
  | TemporaryPasswordState$Input
  | LocalFile$Input
  | RemoteFile$Input
  | File$Input
  | InputFile$Input
  | PhotoSize$Input
  | Minithumbnail$Input
  | ThumbnailFormat$Input
  | Thumbnail$Input
  | MaskPoint$Input
  | MaskPosition$Input
  | ClosedVectorPath$Input
  | PollOption$Input
  | PollType$Input
  | Animation$Input
  | Audio$Input
  | Document$Input
  | Photo$Input
  | Sticker$Input
  | Video$Input
  | VideoNote$Input
  | VoiceNote$Input
  | AnimatedEmoji$Input
  | Contact$Input
  | Location$Input
  | Venue$Input
  | Game$Input
  | Poll$Input
  | ProfilePhoto$Input
  | ChatPhotoInfo$Input
  | UserType$Input
  | BotCommand$Input
  | BotCommands$Input
  | ChatLocation$Input
  | AnimatedChatPhoto$Input
  | ChatPhoto$Input
  | ChatPhotos$Input
  | InputChatPhoto$Input
  | User$Input
  | UserFullInfo$Input
  | Users$Input
  | ChatAdministrator$Input
  | ChatAdministrators$Input
  | ChatPermissions$Input
  | ChatMemberStatus$Input
  | ChatMember$Input
  | ChatMembers$Input
  | ChatMembersFilter$Input
  | SupergroupMembersFilter$Input
  | ChatInviteLink$Input
  | ChatInviteLinks$Input
  | ChatInviteLinkCount$Input
  | ChatInviteLinkCounts$Input
  | ChatInviteLinkMember$Input
  | ChatInviteLinkMembers$Input
  | ChatInviteLinkInfo$Input
  | ChatJoinRequest$Input
  | ChatJoinRequests$Input
  | ChatJoinRequestsInfo$Input
  | BasicGroup$Input
  | BasicGroupFullInfo$Input
  | Supergroup$Input
  | SupergroupFullInfo$Input
  | SecretChatState$Input
  | SecretChat$Input
  | MessageSender$Input
  | MessageSenders$Input
  | MessageForwardOrigin$Input
  | MessageForwardInfo$Input
  | MessageReplyInfo$Input
  | MessageInteractionInfo$Input
  | MessageSendingState$Input
  | Message$Input
  | Messages$Input
  | FoundMessages$Input
  | MessagePosition$Input
  | MessagePositions$Input
  | MessageCalendarDay$Input
  | MessageCalendar$Input
  | SponsoredMessage$Input
  | NotificationSettingsScope$Input
  | ChatNotificationSettings$Input
  | ScopeNotificationSettings$Input
  | DraftMessage$Input
  | ChatType$Input
  | ChatFilter$Input
  | ChatFilterInfo$Input
  | RecommendedChatFilter$Input
  | RecommendedChatFilters$Input
  | ChatList$Input
  | ChatLists$Input
  | ChatSource$Input
  | ChatPosition$Input
  | VideoChat$Input
  | Chat$Input
  | Chats$Input
  | ChatNearby$Input
  | ChatsNearby$Input
  | PublicChatType$Input
  | ChatActionBar$Input
  | KeyboardButtonType$Input
  | KeyboardButton$Input
  | InlineKeyboardButtonType$Input
  | InlineKeyboardButton$Input
  | ReplyMarkup$Input
  | LoginUrlInfo$Input
  | MessageThreadInfo$Input
  | RichText$Input
  | PageBlockCaption$Input
  | PageBlockListItem$Input
  | PageBlockHorizontalAlignment$Input
  | PageBlockVerticalAlignment$Input
  | PageBlockTableCell$Input
  | PageBlockRelatedArticle$Input
  | PageBlock$Input
  | WebPageInstantView$Input
  | WebPage$Input
  | CountryInfo$Input
  | Countries$Input
  | PhoneNumberInfo$Input
  | BankCardActionOpenUrl$Input
  | BankCardInfo$Input
  | Address$Input
  | LabeledPricePart$Input
  | Invoice$Input
  | OrderInfo$Input
  | ShippingOption$Input
  | SavedCredentials$Input
  | InputCredentials$Input
  | PaymentsProviderStripe$Input
  | PaymentFormTheme$Input
  | PaymentForm$Input
  | ValidatedOrderInfo$Input
  | PaymentResult$Input
  | PaymentReceipt$Input
  | DatedFile$Input
  | PassportElementType$Input
  | Date$Input
  | PersonalDetails$Input
  | IdentityDocument$Input
  | InputIdentityDocument$Input
  | PersonalDocument$Input
  | InputPersonalDocument$Input
  | PassportElement$Input
  | InputPassportElement$Input
  | PassportElements$Input
  | PassportElementErrorSource$Input
  | PassportElementError$Input
  | PassportSuitableElement$Input
  | PassportRequiredElement$Input
  | PassportAuthorizationForm$Input
  | PassportElementsWithErrors$Input
  | EncryptedCredentials$Input
  | EncryptedPassportElement$Input
  | InputPassportElementErrorSource$Input
  | InputPassportElementError$Input
  | MessageContent$Input
  | TextEntityType$Input
  | InputThumbnail$Input
  | MessageSchedulingState$Input
  | MessageSendOptions$Input
  | MessageCopyOptions$Input
  | InputMessageContent$Input
  | SearchMessagesFilter$Input
  | ChatAction$Input
  | UserStatus$Input
  | Stickers$Input
  | Emojis$Input
  | StickerSet$Input
  | StickerSetInfo$Input
  | StickerSets$Input
  | CallDiscardReason$Input
  | CallProtocol$Input
  | CallServerType$Input
  | CallServer$Input
  | CallId$Input
  | GroupCallId$Input
  | CallState$Input
  | GroupCallVideoQuality$Input
  | GroupCallRecentSpeaker$Input
  | GroupCall$Input
  | GroupCallVideoSourceGroup$Input
  | GroupCallParticipantVideoInfo$Input
  | GroupCallParticipant$Input
  | CallProblem$Input
  | Call$Input
  | PhoneNumberAuthenticationSettings$Input
  | Animations$Input
  | DiceStickers$Input
  | ImportedContacts$Input
  | HttpUrl$Input
  | InputInlineQueryResult$Input
  | InlineQueryResult$Input
  | InlineQueryResults$Input
  | CallbackQueryPayload$Input
  | CallbackQueryAnswer$Input
  | CustomRequestResult$Input
  | GameHighScore$Input
  | GameHighScores$Input
  | ChatEventAction$Input
  | ChatEvent$Input
  | ChatEvents$Input
  | ChatEventLogFilters$Input
  | LanguagePackStringValue$Input
  | LanguagePackString$Input
  | LanguagePackStrings$Input
  | LanguagePackInfo$Input
  | LocalizationTargetInfo$Input
  | DeviceToken$Input
  | PushReceiverId$Input
  | BackgroundFill$Input
  | BackgroundType$Input
  | Background$Input
  | Backgrounds$Input
  | InputBackground$Input
  | ThemeSettings$Input
  | ChatTheme$Input
  | Hashtags$Input
  | CanTransferOwnershipResult$Input
  | CheckChatUsernameResult$Input
  | CheckStickerSetNameResult$Input
  | ResetPasswordResult$Input
  | MessageFileType$Input
  | PushMessageContent$Input
  | NotificationType$Input
  | NotificationGroupType$Input
  | Notification$Input
  | NotificationGroup$Input
  | OptionValue$Input
  | JsonObjectMember$Input
  | JsonValue$Input
  | UserPrivacySettingRule$Input
  | UserPrivacySettingRules$Input
  | UserPrivacySetting$Input
  | AccountTtl$Input
  | Session$Input
  | Sessions$Input
  | ConnectedWebsite$Input
  | ConnectedWebsites$Input
  | ChatReportReason$Input
  | InternalLinkType$Input
  | MessageLink$Input
  | MessageLinkInfo$Input
  | FilePart$Input
  | FileType$Input
  | StorageStatisticsByFileType$Input
  | StorageStatisticsByChat$Input
  | StorageStatistics$Input
  | StorageStatisticsFast$Input
  | DatabaseStatistics$Input
  | NetworkType$Input
  | NetworkStatisticsEntry$Input
  | NetworkStatistics$Input
  | AutoDownloadSettings$Input
  | AutoDownloadSettingsPresets$Input
  | ConnectionState$Input
  | TopChatCategory$Input
  | TMeUrlType$Input
  | TMeUrl$Input
  | TMeUrls$Input
  | SuggestedAction$Input
  | Count$Input
  | Text$Input
  | Seconds$Input
  | DeepLinkInfo$Input
  | TextParseMode$Input
  | ProxyType$Input
  | Proxy$Input
  | Proxies$Input
  | InputSticker$Input
  | DateRange$Input
  | StatisticalValue$Input
  | StatisticalGraph$Input
  | ChatStatisticsMessageInteractionInfo$Input
  | ChatStatisticsMessageSenderInfo$Input
  | ChatStatisticsAdministratorActionsInfo$Input
  | ChatStatisticsInviterInfo$Input
  | ChatStatistics$Input
  | MessageStatistics$Input
  | Point$Input
  | VectorPathCommand$Input
  | BotCommandScope$Input
  | Update$Input
  | Updates$Input
  | LogStream$Input
  | LogVerbosityLevel$Input
  | LogTags$Input
  | TestInt$Input
  | TestString$Input
  | TestBytes$Input
  | TestVectorInt$Input
  | TestVectorIntObject$Input
  | TestVectorString$Input
  | TestVectorStringObject$Input

// ----

export type Invoke =
  & ((query: getAuthorizationState) => Promise<AuthorizationState>)
  & ((query: setTdlibParameters) => Promise<Ok>)
  & ((query: checkDatabaseEncryptionKey) => Promise<Ok>)
  & ((query: setAuthenticationPhoneNumber) => Promise<Ok>)
  & ((query: resendAuthenticationCode) => Promise<Ok>)
  & ((query: checkAuthenticationCode) => Promise<Ok>)
  & ((query: requestQrCodeAuthentication) => Promise<Ok>)
  & ((query: registerUser) => Promise<Ok>)
  & ((query: checkAuthenticationPassword) => Promise<Ok>)
  & ((query: requestAuthenticationPasswordRecovery) => Promise<Ok>)
  & ((query: checkAuthenticationPasswordRecoveryCode) => Promise<Ok>)
  & ((query: recoverAuthenticationPassword) => Promise<Ok>)
  & ((query: checkAuthenticationBotToken) => Promise<Ok>)
  & ((query: logOut) => Promise<Ok>)
  & ((query: close) => Promise<Ok>)
  & ((query: destroy) => Promise<Ok>)
  & ((query: confirmQrCodeAuthentication) => Promise<Session>)
  & ((query: getCurrentState) => Promise<Updates>)
  & ((query: setDatabaseEncryptionKey) => Promise<Ok>)
  & ((query: getPasswordState) => Promise<PasswordState>)
  & ((query: setPassword) => Promise<PasswordState>)
  & ((query: getRecoveryEmailAddress) => Promise<RecoveryEmailAddress>)
  & ((query: setRecoveryEmailAddress) => Promise<PasswordState>)
  & ((query: checkRecoveryEmailAddressCode) => Promise<PasswordState>)
  & ((query: resendRecoveryEmailAddressCode) => Promise<PasswordState>)
  & ((query: requestPasswordRecovery) => Promise<EmailAddressAuthenticationCodeInfo>)
  & ((query: checkPasswordRecoveryCode) => Promise<Ok>)
  & ((query: recoverPassword) => Promise<PasswordState>)
  & ((query: resetPassword) => Promise<ResetPasswordResult>)
  & ((query: cancelPasswordReset) => Promise<Ok>)
  & ((query: createTemporaryPassword) => Promise<TemporaryPasswordState>)
  & ((query: getTemporaryPasswordState) => Promise<TemporaryPasswordState>)
  & ((query: getMe) => Promise<User>)
  & ((query: getUser) => Promise<User>)
  & ((query: getUserFullInfo) => Promise<UserFullInfo>)
  & ((query: getBasicGroup) => Promise<BasicGroup>)
  & ((query: getBasicGroupFullInfo) => Promise<BasicGroupFullInfo>)
  & ((query: getSupergroup) => Promise<Supergroup>)
  & ((query: getSupergroupFullInfo) => Promise<SupergroupFullInfo>)
  & ((query: getSecretChat) => Promise<SecretChat>)
  & ((query: getChat) => Promise<Chat>)
  & ((query: getMessage) => Promise<Message>)
  & ((query: getMessageLocally) => Promise<Message>)
  & ((query: getRepliedMessage) => Promise<Message>)
  & ((query: getChatPinnedMessage) => Promise<Message>)
  & ((query: getCallbackQueryMessage) => Promise<Message>)
  & ((query: getMessages) => Promise<Messages>)
  & ((query: getMessageThread) => Promise<MessageThreadInfo>)
  & ((query: getMessageViewers) => Promise<Users>)
  & ((query: getFile) => Promise<File>)
  & ((query: getRemoteFile) => Promise<File>)
  & ((query: loadChats) => Promise<Ok>)
  & ((query: getChats) => Promise<Chats>)
  & ((query: searchPublicChat) => Promise<Chat>)
  & ((query: searchPublicChats) => Promise<Chats>)
  & ((query: searchChats) => Promise<Chats>)
  & ((query: searchChatsOnServer) => Promise<Chats>)
  & ((query: searchChatsNearby) => Promise<ChatsNearby>)
  & ((query: getTopChats) => Promise<Chats>)
  & ((query: removeTopChat) => Promise<Ok>)
  & ((query: addRecentlyFoundChat) => Promise<Ok>)
  & ((query: removeRecentlyFoundChat) => Promise<Ok>)
  & ((query: clearRecentlyFoundChats) => Promise<Ok>)
  & ((query: getRecentlyOpenedChats) => Promise<Chats>)
  & ((query: checkChatUsername) => Promise<CheckChatUsernameResult>)
  & ((query: getCreatedPublicChats) => Promise<Chats>)
  & ((query: checkCreatedPublicChatsLimit) => Promise<Ok>)
  & ((query: getSuitableDiscussionChats) => Promise<Chats>)
  & ((query: getInactiveSupergroupChats) => Promise<Chats>)
  & ((query: getGroupsInCommon) => Promise<Chats>)
  & ((query: getChatHistory) => Promise<Messages>)
  & ((query: getMessageThreadHistory) => Promise<Messages>)
  & ((query: deleteChatHistory) => Promise<Ok>)
  & ((query: deleteChat) => Promise<Ok>)
  & ((query: searchChatMessages) => Promise<Messages>)
  & ((query: searchMessages) => Promise<Messages>)
  & ((query: searchSecretMessages) => Promise<FoundMessages>)
  & ((query: searchCallMessages) => Promise<Messages>)
  & ((query: deleteAllCallMessages) => Promise<Ok>)
  & ((query: searchChatRecentLocationMessages) => Promise<Messages>)
  & ((query: getActiveLiveLocationMessages) => Promise<Messages>)
  & ((query: getChatMessageByDate) => Promise<Message>)
  & ((query: getChatSparseMessagePositions) => Promise<MessagePositions>)
  & ((query: getChatMessageCalendar) => Promise<MessageCalendar>)
  & ((query: getChatMessageCount) => Promise<Count>)
  & ((query: getChatScheduledMessages) => Promise<Messages>)
  & ((query: getMessagePublicForwards) => Promise<FoundMessages>)
  & ((query: getChatSponsoredMessage) => Promise<SponsoredMessage>)
  & ((query: removeNotification) => Promise<Ok>)
  & ((query: removeNotificationGroup) => Promise<Ok>)
  & ((query: getMessageLink) => Promise<MessageLink>)
  & ((query: getMessageEmbeddingCode) => Promise<Text>)
  & ((query: getMessageLinkInfo) => Promise<MessageLinkInfo>)
  & ((query: getChatAvailableMessageSenders) => Promise<MessageSenders>)
  & ((query: setChatMessageSender) => Promise<Ok>)
  & ((query: sendMessage) => Promise<Message>)
  & ((query: sendMessageAlbum) => Promise<Messages>)
  & ((query: sendBotStartMessage) => Promise<Message>)
  & ((query: sendInlineQueryResultMessage) => Promise<Message>)
  & ((query: forwardMessages) => Promise<Messages>)
  & ((query: resendMessages) => Promise<Messages>)
  & ((query: sendChatScreenshotTakenNotification) => Promise<Ok>)
  & ((query: addLocalMessage) => Promise<Message>)
  & ((query: deleteMessages) => Promise<Ok>)
  & ((query: deleteChatMessagesBySender) => Promise<Ok>)
  & ((query: deleteChatMessagesByDate) => Promise<Ok>)
  & ((query: editMessageText) => Promise<Message>)
  & ((query: editMessageLiveLocation) => Promise<Message>)
  & ((query: editMessageMedia) => Promise<Message>)
  & ((query: editMessageCaption) => Promise<Message>)
  & ((query: editMessageReplyMarkup) => Promise<Message>)
  & ((query: editInlineMessageText) => Promise<Ok>)
  & ((query: editInlineMessageLiveLocation) => Promise<Ok>)
  & ((query: editInlineMessageMedia) => Promise<Ok>)
  & ((query: editInlineMessageCaption) => Promise<Ok>)
  & ((query: editInlineMessageReplyMarkup) => Promise<Ok>)
  & ((query: editMessageSchedulingState) => Promise<Ok>)
  & ((query: getTextEntities) => Promise<TextEntities>)
  & ((query: parseTextEntities) => Promise<FormattedText>)
  & ((query: parseMarkdown) => Promise<FormattedText>)
  & ((query: getMarkdownText) => Promise<FormattedText>)
  & ((query: getFileMimeType) => Promise<Text>)
  & ((query: getFileExtension) => Promise<Text>)
  & ((query: cleanFileName) => Promise<Text>)
  & ((query: getLanguagePackString) => Promise<LanguagePackStringValue>)
  & ((query: getJsonValue) => Promise<JsonValue>)
  & ((query: getJsonString) => Promise<Text>)
  & ((query: setPollAnswer) => Promise<Ok>)
  & ((query: getPollVoters) => Promise<Users>)
  & ((query: stopPoll) => Promise<Ok>)
  & ((query: hideSuggestedAction) => Promise<Ok>)
  & ((query: getLoginUrlInfo) => Promise<LoginUrlInfo>)
  & ((query: getLoginUrl) => Promise<HttpUrl>)
  & ((query: getInlineQueryResults) => Promise<InlineQueryResults>)
  & ((query: answerInlineQuery) => Promise<Ok>)
  & ((query: getCallbackQueryAnswer) => Promise<CallbackQueryAnswer>)
  & ((query: answerCallbackQuery) => Promise<Ok>)
  & ((query: answerShippingQuery) => Promise<Ok>)
  & ((query: answerPreCheckoutQuery) => Promise<Ok>)
  & ((query: setGameScore) => Promise<Message>)
  & ((query: setInlineGameScore) => Promise<Ok>)
  & ((query: getGameHighScores) => Promise<GameHighScores>)
  & ((query: getInlineGameHighScores) => Promise<GameHighScores>)
  & ((query: deleteChatReplyMarkup) => Promise<Ok>)
  & ((query: sendChatAction) => Promise<Ok>)
  & ((query: openChat) => Promise<Ok>)
  & ((query: closeChat) => Promise<Ok>)
  & ((query: viewMessages) => Promise<Ok>)
  & ((query: openMessageContent) => Promise<Ok>)
  & ((query: clickAnimatedEmojiMessage) => Promise<Sticker>)
  & ((query: getInternalLinkType) => Promise<InternalLinkType>)
  & ((query: getExternalLinkInfo) => Promise<LoginUrlInfo>)
  & ((query: getExternalLink) => Promise<HttpUrl>)
  & ((query: readAllChatMentions) => Promise<Ok>)
  & ((query: createPrivateChat) => Promise<Chat>)
  & ((query: createBasicGroupChat) => Promise<Chat>)
  & ((query: createSupergroupChat) => Promise<Chat>)
  & ((query: createSecretChat) => Promise<Chat>)
  & ((query: createNewBasicGroupChat) => Promise<Chat>)
  & ((query: createNewSupergroupChat) => Promise<Chat>)
  & ((query: createNewSecretChat) => Promise<Chat>)
  & ((query: upgradeBasicGroupChatToSupergroupChat) => Promise<Chat>)
  & ((query: getChatListsToAddChat) => Promise<ChatLists>)
  & ((query: addChatToList) => Promise<Ok>)
  & ((query: getChatFilter) => Promise<ChatFilter>)
  & ((query: createChatFilter) => Promise<ChatFilterInfo>)
  & ((query: editChatFilter) => Promise<ChatFilterInfo>)
  & ((query: deleteChatFilter) => Promise<Ok>)
  & ((query: reorderChatFilters) => Promise<Ok>)
  & ((query: getRecommendedChatFilters) => Promise<RecommendedChatFilters>)
  & ((query: getChatFilterDefaultIconName) => Promise<Text>)
  & ((query: setChatTitle) => Promise<Ok>)
  & ((query: setChatPhoto) => Promise<Ok>)
  & ((query: setChatMessageTtl) => Promise<Ok>)
  & ((query: setChatPermissions) => Promise<Ok>)
  & ((query: setChatTheme) => Promise<Ok>)
  & ((query: setChatDraftMessage) => Promise<Ok>)
  & ((query: setChatNotificationSettings) => Promise<Ok>)
  & ((query: toggleChatHasProtectedContent) => Promise<Ok>)
  & ((query: toggleChatIsMarkedAsUnread) => Promise<Ok>)
  & ((query: toggleChatDefaultDisableNotification) => Promise<Ok>)
  & ((query: setChatClientData) => Promise<Ok>)
  & ((query: setChatDescription) => Promise<Ok>)
  & ((query: setChatDiscussionGroup) => Promise<Ok>)
  & ((query: setChatLocation) => Promise<Ok>)
  & ((query: setChatSlowModeDelay) => Promise<Ok>)
  & ((query: pinChatMessage) => Promise<Ok>)
  & ((query: unpinChatMessage) => Promise<Ok>)
  & ((query: unpinAllChatMessages) => Promise<Ok>)
  & ((query: joinChat) => Promise<Ok>)
  & ((query: leaveChat) => Promise<Ok>)
  & ((query: addChatMember) => Promise<Ok>)
  & ((query: addChatMembers) => Promise<Ok>)
  & ((query: setChatMemberStatus) => Promise<Ok>)
  & ((query: banChatMember) => Promise<Ok>)
  & ((query: canTransferOwnership) => Promise<CanTransferOwnershipResult>)
  & ((query: transferChatOwnership) => Promise<Ok>)
  & ((query: getChatMember) => Promise<ChatMember>)
  & ((query: searchChatMembers) => Promise<ChatMembers>)
  & ((query: getChatAdministrators) => Promise<ChatAdministrators>)
  & ((query: clearAllDraftMessages) => Promise<Ok>)
  & ((query: getChatNotificationSettingsExceptions) => Promise<Chats>)
  & ((query: getScopeNotificationSettings) => Promise<ScopeNotificationSettings>)
  & ((query: setScopeNotificationSettings) => Promise<Ok>)
  & ((query: resetAllNotificationSettings) => Promise<Ok>)
  & ((query: toggleChatIsPinned) => Promise<Ok>)
  & ((query: setPinnedChats) => Promise<Ok>)
  & ((query: downloadFile) => Promise<File>)
  & ((query: getFileDownloadedPrefixSize) => Promise<Count>)
  & ((query: cancelDownloadFile) => Promise<Ok>)
  & ((query: getSuggestedFileName) => Promise<Text>)
  & ((query: uploadFile) => Promise<File>)
  & ((query: cancelUploadFile) => Promise<Ok>)
  & ((query: writeGeneratedFilePart) => Promise<Ok>)
  & ((query: setFileGenerationProgress) => Promise<Ok>)
  & ((query: finishFileGeneration) => Promise<Ok>)
  & ((query: readFilePart) => Promise<FilePart>)
  & ((query: deleteFile) => Promise<Ok>)
  & ((query: getMessageFileType) => Promise<MessageFileType>)
  & ((query: getMessageImportConfirmationText) => Promise<Text>)
  & ((query: importMessages) => Promise<Ok>)
  & ((query: replacePrimaryChatInviteLink) => Promise<ChatInviteLink>)
  & ((query: createChatInviteLink) => Promise<ChatInviteLink>)
  & ((query: editChatInviteLink) => Promise<ChatInviteLink>)
  & ((query: getChatInviteLink) => Promise<ChatInviteLink>)
  & ((query: getChatInviteLinkCounts) => Promise<ChatInviteLinkCounts>)
  & ((query: getChatInviteLinks) => Promise<ChatInviteLinks>)
  & ((query: getChatInviteLinkMembers) => Promise<ChatInviteLinkMembers>)
  & ((query: revokeChatInviteLink) => Promise<ChatInviteLinks>)
  & ((query: deleteRevokedChatInviteLink) => Promise<Ok>)
  & ((query: deleteAllRevokedChatInviteLinks) => Promise<Ok>)
  & ((query: checkChatInviteLink) => Promise<ChatInviteLinkInfo>)
  & ((query: joinChatByInviteLink) => Promise<Chat>)
  & ((query: getChatJoinRequests) => Promise<ChatJoinRequests>)
  & ((query: processChatJoinRequest) => Promise<Ok>)
  & ((query: processChatJoinRequests) => Promise<Ok>)
  & ((query: createCall) => Promise<CallId>)
  & ((query: acceptCall) => Promise<Ok>)
  & ((query: sendCallSignalingData) => Promise<Ok>)
  & ((query: discardCall) => Promise<Ok>)
  & ((query: sendCallRating) => Promise<Ok>)
  & ((query: sendCallDebugInformation) => Promise<Ok>)
  & ((query: getVideoChatAvailableParticipants) => Promise<MessageSenders>)
  & ((query: setVideoChatDefaultParticipant) => Promise<Ok>)
  & ((query: createVideoChat) => Promise<GroupCallId>)
  & ((query: getGroupCall) => Promise<GroupCall>)
  & ((query: startScheduledGroupCall) => Promise<Ok>)
  & ((query: toggleGroupCallEnabledStartNotification) => Promise<Ok>)
  & ((query: joinGroupCall) => Promise<Text>)
  & ((query: startGroupCallScreenSharing) => Promise<Text>)
  & ((query: toggleGroupCallScreenSharingIsPaused) => Promise<Ok>)
  & ((query: endGroupCallScreenSharing) => Promise<Ok>)
  & ((query: setGroupCallTitle) => Promise<Ok>)
  & ((query: toggleGroupCallMuteNewParticipants) => Promise<Ok>)
  & ((query: inviteGroupCallParticipants) => Promise<Ok>)
  & ((query: getGroupCallInviteLink) => Promise<HttpUrl>)
  & ((query: revokeGroupCallInviteLink) => Promise<Ok>)
  & ((query: startGroupCallRecording) => Promise<Ok>)
  & ((query: endGroupCallRecording) => Promise<Ok>)
  & ((query: toggleGroupCallIsMyVideoPaused) => Promise<Ok>)
  & ((query: toggleGroupCallIsMyVideoEnabled) => Promise<Ok>)
  & ((query: setGroupCallParticipantIsSpeaking) => Promise<Ok>)
  & ((query: toggleGroupCallParticipantIsMuted) => Promise<Ok>)
  & ((query: setGroupCallParticipantVolumeLevel) => Promise<Ok>)
  & ((query: toggleGroupCallParticipantIsHandRaised) => Promise<Ok>)
  & ((query: loadGroupCallParticipants) => Promise<Ok>)
  & ((query: leaveGroupCall) => Promise<Ok>)
  & ((query: endGroupCall) => Promise<Ok>)
  & ((query: getGroupCallStreamSegment) => Promise<FilePart>)
  & ((query: toggleMessageSenderIsBlocked) => Promise<Ok>)
  & ((query: blockMessageSenderFromReplies) => Promise<Ok>)
  & ((query: getBlockedMessageSenders) => Promise<MessageSenders>)
  & ((query: addContact) => Promise<Ok>)
  & ((query: importContacts) => Promise<ImportedContacts>)
  & ((query: getContacts) => Promise<Users>)
  & ((query: searchContacts) => Promise<Users>)
  & ((query: removeContacts) => Promise<Ok>)
  & ((query: getImportedContactCount) => Promise<Count>)
  & ((query: changeImportedContacts) => Promise<ImportedContacts>)
  & ((query: clearImportedContacts) => Promise<Ok>)
  & ((query: sharePhoneNumber) => Promise<Ok>)
  & ((query: getUserProfilePhotos) => Promise<ChatPhotos>)
  & ((query: getStickers) => Promise<Stickers>)
  & ((query: searchStickers) => Promise<Stickers>)
  & ((query: getInstalledStickerSets) => Promise<StickerSets>)
  & ((query: getArchivedStickerSets) => Promise<StickerSets>)
  & ((query: getTrendingStickerSets) => Promise<StickerSets>)
  & ((query: getAttachedStickerSets) => Promise<StickerSets>)
  & ((query: getStickerSet) => Promise<StickerSet>)
  & ((query: searchStickerSet) => Promise<StickerSet>)
  & ((query: searchInstalledStickerSets) => Promise<StickerSets>)
  & ((query: searchStickerSets) => Promise<StickerSets>)
  & ((query: changeStickerSet) => Promise<Ok>)
  & ((query: viewTrendingStickerSets) => Promise<Ok>)
  & ((query: reorderInstalledStickerSets) => Promise<Ok>)
  & ((query: getRecentStickers) => Promise<Stickers>)
  & ((query: addRecentSticker) => Promise<Stickers>)
  & ((query: removeRecentSticker) => Promise<Ok>)
  & ((query: clearRecentStickers) => Promise<Ok>)
  & ((query: getFavoriteStickers) => Promise<Stickers>)
  & ((query: addFavoriteSticker) => Promise<Ok>)
  & ((query: removeFavoriteSticker) => Promise<Ok>)
  & ((query: getStickerEmojis) => Promise<Emojis>)
  & ((query: searchEmojis) => Promise<Emojis>)
  & ((query: getAnimatedEmoji) => Promise<AnimatedEmoji>)
  & ((query: getEmojiSuggestionsUrl) => Promise<HttpUrl>)
  & ((query: getSavedAnimations) => Promise<Animations>)
  & ((query: addSavedAnimation) => Promise<Ok>)
  & ((query: removeSavedAnimation) => Promise<Ok>)
  & ((query: getRecentInlineBots) => Promise<Users>)
  & ((query: searchHashtags) => Promise<Hashtags>)
  & ((query: removeRecentHashtag) => Promise<Ok>)
  & ((query: getWebPagePreview) => Promise<WebPage>)
  & ((query: getWebPageInstantView) => Promise<WebPageInstantView>)
  & ((query: setProfilePhoto) => Promise<Ok>)
  & ((query: deleteProfilePhoto) => Promise<Ok>)
  & ((query: setName) => Promise<Ok>)
  & ((query: setBio) => Promise<Ok>)
  & ((query: setUsername) => Promise<Ok>)
  & ((query: setLocation) => Promise<Ok>)
  & ((query: changePhoneNumber) => Promise<AuthenticationCodeInfo>)
  & ((query: resendChangePhoneNumberCode) => Promise<AuthenticationCodeInfo>)
  & ((query: checkChangePhoneNumberCode) => Promise<Ok>)
  & ((query: setCommands) => Promise<Ok>)
  & ((query: deleteCommands) => Promise<Ok>)
  & ((query: getCommands) => Promise<BotCommands>)
  & ((query: getActiveSessions) => Promise<Sessions>)
  & ((query: terminateSession) => Promise<Ok>)
  & ((query: terminateAllOtherSessions) => Promise<Ok>)
  & ((query: toggleSessionCanAcceptCalls) => Promise<Ok>)
  & ((query: toggleSessionCanAcceptSecretChats) => Promise<Ok>)
  & ((query: setInactiveSessionTtl) => Promise<Ok>)
  & ((query: getConnectedWebsites) => Promise<ConnectedWebsites>)
  & ((query: disconnectWebsite) => Promise<Ok>)
  & ((query: disconnectAllWebsites) => Promise<Ok>)
  & ((query: setSupergroupUsername) => Promise<Ok>)
  & ((query: setSupergroupStickerSet) => Promise<Ok>)
  & ((query: toggleSupergroupSignMessages) => Promise<Ok>)
  & ((query: toggleSupergroupIsAllHistoryAvailable) => Promise<Ok>)
  & ((query: toggleSupergroupIsBroadcastGroup) => Promise<Ok>)
  & ((query: reportSupergroupSpam) => Promise<Ok>)
  & ((query: getSupergroupMembers) => Promise<ChatMembers>)
  & ((query: closeSecretChat) => Promise<Ok>)
  & ((query: getChatEventLog) => Promise<ChatEvents>)
  & ((query: getPaymentForm) => Promise<PaymentForm>)
  & ((query: validateOrderInfo) => Promise<ValidatedOrderInfo>)
  & ((query: sendPaymentForm) => Promise<PaymentResult>)
  & ((query: getPaymentReceipt) => Promise<PaymentReceipt>)
  & ((query: getSavedOrderInfo) => Promise<OrderInfo>)
  & ((query: deleteSavedOrderInfo) => Promise<Ok>)
  & ((query: deleteSavedCredentials) => Promise<Ok>)
  & ((query: getSupportUser) => Promise<User>)
  & ((query: getBackgrounds) => Promise<Backgrounds>)
  & ((query: getBackgroundUrl) => Promise<HttpUrl>)
  & ((query: searchBackground) => Promise<Background>)
  & ((query: setBackground) => Promise<Background>)
  & ((query: removeBackground) => Promise<Ok>)
  & ((query: resetBackgrounds) => Promise<Ok>)
  & ((query: getLocalizationTargetInfo) => Promise<LocalizationTargetInfo>)
  & ((query: getLanguagePackInfo) => Promise<LanguagePackInfo>)
  & ((query: getLanguagePackStrings) => Promise<LanguagePackStrings>)
  & ((query: synchronizeLanguagePack) => Promise<Ok>)
  & ((query: addCustomServerLanguagePack) => Promise<Ok>)
  & ((query: setCustomLanguagePack) => Promise<Ok>)
  & ((query: editCustomLanguagePackInfo) => Promise<Ok>)
  & ((query: setCustomLanguagePackString) => Promise<Ok>)
  & ((query: deleteLanguagePack) => Promise<Ok>)
  & ((query: registerDevice) => Promise<PushReceiverId>)
  & ((query: processPushNotification) => Promise<Ok>)
  & ((query: getPushReceiverId) => Promise<PushReceiverId>)
  & ((query: getRecentlyVisitedTMeUrls) => Promise<TMeUrls>)
  & ((query: setUserPrivacySettingRules) => Promise<Ok>)
  & ((query: getUserPrivacySettingRules) => Promise<UserPrivacySettingRules>)
  & ((query: getOption) => Promise<OptionValue>)
  & ((query: setOption) => Promise<Ok>)
  & ((query: setAccountTtl) => Promise<Ok>)
  & ((query: getAccountTtl) => Promise<AccountTtl>)
  & ((query: deleteAccount) => Promise<Ok>)
  & ((query: removeChatActionBar) => Promise<Ok>)
  & ((query: reportChat) => Promise<Ok>)
  & ((query: reportChatPhoto) => Promise<Ok>)
  & ((query: getChatStatistics) => Promise<ChatStatistics>)
  & ((query: getMessageStatistics) => Promise<MessageStatistics>)
  & ((query: getStatisticalGraph) => Promise<StatisticalGraph>)
  & ((query: getStorageStatistics) => Promise<StorageStatistics>)
  & ((query: getStorageStatisticsFast) => Promise<StorageStatisticsFast>)
  & ((query: getDatabaseStatistics) => Promise<DatabaseStatistics>)
  & ((query: optimizeStorage) => Promise<StorageStatistics>)
  & ((query: setNetworkType) => Promise<Ok>)
  & ((query: getNetworkStatistics) => Promise<NetworkStatistics>)
  & ((query: addNetworkStatistics) => Promise<Ok>)
  & ((query: resetNetworkStatistics) => Promise<Ok>)
  & ((query: getAutoDownloadSettingsPresets) => Promise<AutoDownloadSettingsPresets>)
  & ((query: setAutoDownloadSettings) => Promise<Ok>)
  & ((query: getBankCardInfo) => Promise<BankCardInfo>)
  & ((query: getPassportElement) => Promise<PassportElement>)
  & ((query: getAllPassportElements) => Promise<PassportElements>)
  & ((query: setPassportElement) => Promise<PassportElement>)
  & ((query: deletePassportElement) => Promise<Ok>)
  & ((query: setPassportElementErrors) => Promise<Ok>)
  & ((query: getPreferredCountryLanguage) => Promise<Text>)
  & ((query: sendPhoneNumberVerificationCode) => Promise<AuthenticationCodeInfo>)
  & ((query: resendPhoneNumberVerificationCode) => Promise<AuthenticationCodeInfo>)
  & ((query: checkPhoneNumberVerificationCode) => Promise<Ok>)
  & ((query: sendEmailAddressVerificationCode) => Promise<EmailAddressAuthenticationCodeInfo>)
  & ((query: resendEmailAddressVerificationCode) => Promise<EmailAddressAuthenticationCodeInfo>)
  & ((query: checkEmailAddressVerificationCode) => Promise<Ok>)
  & ((query: getPassportAuthorizationForm) => Promise<PassportAuthorizationForm>)
  & ((query: getPassportAuthorizationFormAvailableElements) => Promise<PassportElementsWithErrors>)
  & ((query: sendPassportAuthorizationForm) => Promise<Ok>)
  & ((query: sendPhoneNumberConfirmationCode) => Promise<AuthenticationCodeInfo>)
  & ((query: resendPhoneNumberConfirmationCode) => Promise<AuthenticationCodeInfo>)
  & ((query: checkPhoneNumberConfirmationCode) => Promise<Ok>)
  & ((query: setBotUpdatesStatus) => Promise<Ok>)
  & ((query: uploadStickerFile) => Promise<File>)
  & ((query: getSuggestedStickerSetName) => Promise<Text>)
  & ((query: checkStickerSetName) => Promise<CheckStickerSetNameResult>)
  & ((query: createNewStickerSet) => Promise<StickerSet>)
  & ((query: addStickerToSet) => Promise<StickerSet>)
  & ((query: setStickerSetThumbnail) => Promise<StickerSet>)
  & ((query: setStickerPositionInSet) => Promise<Ok>)
  & ((query: removeStickerFromSet) => Promise<Ok>)
  & ((query: getMapThumbnailFile) => Promise<File>)
  & ((query: acceptTermsOfService) => Promise<Ok>)
  & ((query: sendCustomRequest) => Promise<CustomRequestResult>)
  & ((query: answerCustomQuery) => Promise<Ok>)
  & ((query: setAlarm) => Promise<Ok>)
  & ((query: getCountries) => Promise<Countries>)
  & ((query: getCountryCode) => Promise<Text>)
  & ((query: getPhoneNumberInfo) => Promise<PhoneNumberInfo>)
  & ((query: getPhoneNumberInfoSync) => Promise<PhoneNumberInfo>)
  & ((query: getApplicationDownloadLink) => Promise<HttpUrl>)
  & ((query: getDeepLinkInfo) => Promise<DeepLinkInfo>)
  & ((query: getApplicationConfig) => Promise<JsonValue>)
  & ((query: saveApplicationLogEvent) => Promise<Ok>)
  & ((query: addProxy) => Promise<Proxy>)
  & ((query: editProxy) => Promise<Proxy>)
  & ((query: enableProxy) => Promise<Ok>)
  & ((query: disableProxy) => Promise<Ok>)
  & ((query: removeProxy) => Promise<Ok>)
  & ((query: getProxies) => Promise<Proxies>)
  & ((query: getProxyLink) => Promise<HttpUrl>)
  & ((query: pingProxy) => Promise<Seconds>)
  & ((query: setLogStream) => Promise<Ok>)
  & ((query: getLogStream) => Promise<LogStream>)
  & ((query: setLogVerbosityLevel) => Promise<Ok>)
  & ((query: getLogVerbosityLevel) => Promise<LogVerbosityLevel>)
  & ((query: getLogTags) => Promise<LogTags>)
  & ((query: setLogTagVerbosityLevel) => Promise<Ok>)
  & ((query: getLogTagVerbosityLevel) => Promise<LogVerbosityLevel>)
  & ((query: addLogMessage) => Promise<Ok>)
  & ((query: testCallEmpty) => Promise<Ok>)
  & ((query: testCallString) => Promise<TestString>)
  & ((query: testCallBytes) => Promise<TestBytes>)
  & ((query: testCallVectorInt) => Promise<TestVectorInt>)
  & ((query: testCallVectorIntObject) => Promise<TestVectorIntObject>)
  & ((query: testCallVectorString) => Promise<TestVectorString>)
  & ((query: testCallVectorStringObject) => Promise<TestVectorStringObject>)
  & ((query: testSquareInt) => Promise<TestInt>)
  & ((query: testNetwork) => Promise<Ok>)
  & ((query: testProxy) => Promise<Ok>)
  & ((query: testGetDifference) => Promise<Ok>)
  & ((query: testUseUpdate) => Promise<Update>)
  & ((query: testReturnError) => Promise<Error>)

export type Execute =
  & ((query: getAuthorizationState) => AuthorizationState | error | null)
  & ((query: setTdlibParameters) => Ok | error | null)
  & ((query: checkDatabaseEncryptionKey) => Ok | error | null)
  & ((query: setAuthenticationPhoneNumber) => Ok | error | null)
  & ((query: resendAuthenticationCode) => Ok | error | null)
  & ((query: checkAuthenticationCode) => Ok | error | null)
  & ((query: requestQrCodeAuthentication) => Ok | error | null)
  & ((query: registerUser) => Ok | error | null)
  & ((query: checkAuthenticationPassword) => Ok | error | null)
  & ((query: requestAuthenticationPasswordRecovery) => Ok | error | null)
  & ((query: checkAuthenticationPasswordRecoveryCode) => Ok | error | null)
  & ((query: recoverAuthenticationPassword) => Ok | error | null)
  & ((query: checkAuthenticationBotToken) => Ok | error | null)
  & ((query: logOut) => Ok | error | null)
  & ((query: close) => Ok | error | null)
  & ((query: destroy) => Ok | error | null)
  & ((query: confirmQrCodeAuthentication) => Session | error | null)
  & ((query: getCurrentState) => Updates | error | null)
  & ((query: setDatabaseEncryptionKey) => Ok | error | null)
  & ((query: getPasswordState) => PasswordState | error | null)
  & ((query: setPassword) => PasswordState | error | null)
  & ((query: getRecoveryEmailAddress) => RecoveryEmailAddress | error | null)
  & ((query: setRecoveryEmailAddress) => PasswordState | error | null)
  & ((query: checkRecoveryEmailAddressCode) => PasswordState | error | null)
  & ((query: resendRecoveryEmailAddressCode) => PasswordState | error | null)
  & ((query: requestPasswordRecovery) => EmailAddressAuthenticationCodeInfo | error | null)
  & ((query: checkPasswordRecoveryCode) => Ok | error | null)
  & ((query: recoverPassword) => PasswordState | error | null)
  & ((query: resetPassword) => ResetPasswordResult | error | null)
  & ((query: cancelPasswordReset) => Ok | error | null)
  & ((query: createTemporaryPassword) => TemporaryPasswordState | error | null)
  & ((query: getTemporaryPasswordState) => TemporaryPasswordState | error | null)
  & ((query: getMe) => User | error | null)
  & ((query: getUser) => User | error | null)
  & ((query: getUserFullInfo) => UserFullInfo | error | null)
  & ((query: getBasicGroup) => BasicGroup | error | null)
  & ((query: getBasicGroupFullInfo) => BasicGroupFullInfo | error | null)
  & ((query: getSupergroup) => Supergroup | error | null)
  & ((query: getSupergroupFullInfo) => SupergroupFullInfo | error | null)
  & ((query: getSecretChat) => SecretChat | error | null)
  & ((query: getChat) => Chat | error | null)
  & ((query: getMessage) => Message | error | null)
  & ((query: getMessageLocally) => Message | error | null)
  & ((query: getRepliedMessage) => Message | error | null)
  & ((query: getChatPinnedMessage) => Message | error | null)
  & ((query: getCallbackQueryMessage) => Message | error | null)
  & ((query: getMessages) => Messages | error | null)
  & ((query: getMessageThread) => MessageThreadInfo | error | null)
  & ((query: getMessageViewers) => Users | error | null)
  & ((query: getFile) => File | error | null)
  & ((query: getRemoteFile) => File | error | null)
  & ((query: loadChats) => Ok | error | null)
  & ((query: getChats) => Chats | error | null)
  & ((query: searchPublicChat) => Chat | error | null)
  & ((query: searchPublicChats) => Chats | error | null)
  & ((query: searchChats) => Chats | error | null)
  & ((query: searchChatsOnServer) => Chats | error | null)
  & ((query: searchChatsNearby) => ChatsNearby | error | null)
  & ((query: getTopChats) => Chats | error | null)
  & ((query: removeTopChat) => Ok | error | null)
  & ((query: addRecentlyFoundChat) => Ok | error | null)
  & ((query: removeRecentlyFoundChat) => Ok | error | null)
  & ((query: clearRecentlyFoundChats) => Ok | error | null)
  & ((query: getRecentlyOpenedChats) => Chats | error | null)
  & ((query: checkChatUsername) => CheckChatUsernameResult | error | null)
  & ((query: getCreatedPublicChats) => Chats | error | null)
  & ((query: checkCreatedPublicChatsLimit) => Ok | error | null)
  & ((query: getSuitableDiscussionChats) => Chats | error | null)
  & ((query: getInactiveSupergroupChats) => Chats | error | null)
  & ((query: getGroupsInCommon) => Chats | error | null)
  & ((query: getChatHistory) => Messages | error | null)
  & ((query: getMessageThreadHistory) => Messages | error | null)
  & ((query: deleteChatHistory) => Ok | error | null)
  & ((query: deleteChat) => Ok | error | null)
  & ((query: searchChatMessages) => Messages | error | null)
  & ((query: searchMessages) => Messages | error | null)
  & ((query: searchSecretMessages) => FoundMessages | error | null)
  & ((query: searchCallMessages) => Messages | error | null)
  & ((query: deleteAllCallMessages) => Ok | error | null)
  & ((query: searchChatRecentLocationMessages) => Messages | error | null)
  & ((query: getActiveLiveLocationMessages) => Messages | error | null)
  & ((query: getChatMessageByDate) => Message | error | null)
  & ((query: getChatSparseMessagePositions) => MessagePositions | error | null)
  & ((query: getChatMessageCalendar) => MessageCalendar | error | null)
  & ((query: getChatMessageCount) => Count | error | null)
  & ((query: getChatScheduledMessages) => Messages | error | null)
  & ((query: getMessagePublicForwards) => FoundMessages | error | null)
  & ((query: getChatSponsoredMessage) => SponsoredMessage | error | null)
  & ((query: removeNotification) => Ok | error | null)
  & ((query: removeNotificationGroup) => Ok | error | null)
  & ((query: getMessageLink) => MessageLink | error | null)
  & ((query: getMessageEmbeddingCode) => Text | error | null)
  & ((query: getMessageLinkInfo) => MessageLinkInfo | error | null)
  & ((query: getChatAvailableMessageSenders) => MessageSenders | error | null)
  & ((query: setChatMessageSender) => Ok | error | null)
  & ((query: sendMessage) => Message | error | null)
  & ((query: sendMessageAlbum) => Messages | error | null)
  & ((query: sendBotStartMessage) => Message | error | null)
  & ((query: sendInlineQueryResultMessage) => Message | error | null)
  & ((query: forwardMessages) => Messages | error | null)
  & ((query: resendMessages) => Messages | error | null)
  & ((query: sendChatScreenshotTakenNotification) => Ok | error | null)
  & ((query: addLocalMessage) => Message | error | null)
  & ((query: deleteMessages) => Ok | error | null)
  & ((query: deleteChatMessagesBySender) => Ok | error | null)
  & ((query: deleteChatMessagesByDate) => Ok | error | null)
  & ((query: editMessageText) => Message | error | null)
  & ((query: editMessageLiveLocation) => Message | error | null)
  & ((query: editMessageMedia) => Message | error | null)
  & ((query: editMessageCaption) => Message | error | null)
  & ((query: editMessageReplyMarkup) => Message | error | null)
  & ((query: editInlineMessageText) => Ok | error | null)
  & ((query: editInlineMessageLiveLocation) => Ok | error | null)
  & ((query: editInlineMessageMedia) => Ok | error | null)
  & ((query: editInlineMessageCaption) => Ok | error | null)
  & ((query: editInlineMessageReplyMarkup) => Ok | error | null)
  & ((query: editMessageSchedulingState) => Ok | error | null)
  & ((query: getTextEntities) => TextEntities | error | null)
  & ((query: parseTextEntities) => FormattedText | error | null)
  & ((query: parseMarkdown) => FormattedText | error | null)
  & ((query: getMarkdownText) => FormattedText | error | null)
  & ((query: getFileMimeType) => Text | error | null)
  & ((query: getFileExtension) => Text | error | null)
  & ((query: cleanFileName) => Text | error | null)
  & ((query: getLanguagePackString) => LanguagePackStringValue | error | null)
  & ((query: getJsonValue) => JsonValue | error | null)
  & ((query: getJsonString) => Text | error | null)
  & ((query: setPollAnswer) => Ok | error | null)
  & ((query: getPollVoters) => Users | error | null)
  & ((query: stopPoll) => Ok | error | null)
  & ((query: hideSuggestedAction) => Ok | error | null)
  & ((query: getLoginUrlInfo) => LoginUrlInfo | error | null)
  & ((query: getLoginUrl) => HttpUrl | error | null)
  & ((query: getInlineQueryResults) => InlineQueryResults | error | null)
  & ((query: answerInlineQuery) => Ok | error | null)
  & ((query: getCallbackQueryAnswer) => CallbackQueryAnswer | error | null)
  & ((query: answerCallbackQuery) => Ok | error | null)
  & ((query: answerShippingQuery) => Ok | error | null)
  & ((query: answerPreCheckoutQuery) => Ok | error | null)
  & ((query: setGameScore) => Message | error | null)
  & ((query: setInlineGameScore) => Ok | error | null)
  & ((query: getGameHighScores) => GameHighScores | error | null)
  & ((query: getInlineGameHighScores) => GameHighScores | error | null)
  & ((query: deleteChatReplyMarkup) => Ok | error | null)
  & ((query: sendChatAction) => Ok | error | null)
  & ((query: openChat) => Ok | error | null)
  & ((query: closeChat) => Ok | error | null)
  & ((query: viewMessages) => Ok | error | null)
  & ((query: openMessageContent) => Ok | error | null)
  & ((query: clickAnimatedEmojiMessage) => Sticker | error | null)
  & ((query: getInternalLinkType) => InternalLinkType | error | null)
  & ((query: getExternalLinkInfo) => LoginUrlInfo | error | null)
  & ((query: getExternalLink) => HttpUrl | error | null)
  & ((query: readAllChatMentions) => Ok | error | null)
  & ((query: createPrivateChat) => Chat | error | null)
  & ((query: createBasicGroupChat) => Chat | error | null)
  & ((query: createSupergroupChat) => Chat | error | null)
  & ((query: createSecretChat) => Chat | error | null)
  & ((query: createNewBasicGroupChat) => Chat | error | null)
  & ((query: createNewSupergroupChat) => Chat | error | null)
  & ((query: createNewSecretChat) => Chat | error | null)
  & ((query: upgradeBasicGroupChatToSupergroupChat) => Chat | error | null)
  & ((query: getChatListsToAddChat) => ChatLists | error | null)
  & ((query: addChatToList) => Ok | error | null)
  & ((query: getChatFilter) => ChatFilter | error | null)
  & ((query: createChatFilter) => ChatFilterInfo | error | null)
  & ((query: editChatFilter) => ChatFilterInfo | error | null)
  & ((query: deleteChatFilter) => Ok | error | null)
  & ((query: reorderChatFilters) => Ok | error | null)
  & ((query: getRecommendedChatFilters) => RecommendedChatFilters | error | null)
  & ((query: getChatFilterDefaultIconName) => Text | error | null)
  & ((query: setChatTitle) => Ok | error | null)
  & ((query: setChatPhoto) => Ok | error | null)
  & ((query: setChatMessageTtl) => Ok | error | null)
  & ((query: setChatPermissions) => Ok | error | null)
  & ((query: setChatTheme) => Ok | error | null)
  & ((query: setChatDraftMessage) => Ok | error | null)
  & ((query: setChatNotificationSettings) => Ok | error | null)
  & ((query: toggleChatHasProtectedContent) => Ok | error | null)
  & ((query: toggleChatIsMarkedAsUnread) => Ok | error | null)
  & ((query: toggleChatDefaultDisableNotification) => Ok | error | null)
  & ((query: setChatClientData) => Ok | error | null)
  & ((query: setChatDescription) => Ok | error | null)
  & ((query: setChatDiscussionGroup) => Ok | error | null)
  & ((query: setChatLocation) => Ok | error | null)
  & ((query: setChatSlowModeDelay) => Ok | error | null)
  & ((query: pinChatMessage) => Ok | error | null)
  & ((query: unpinChatMessage) => Ok | error | null)
  & ((query: unpinAllChatMessages) => Ok | error | null)
  & ((query: joinChat) => Ok | error | null)
  & ((query: leaveChat) => Ok | error | null)
  & ((query: addChatMember) => Ok | error | null)
  & ((query: addChatMembers) => Ok | error | null)
  & ((query: setChatMemberStatus) => Ok | error | null)
  & ((query: banChatMember) => Ok | error | null)
  & ((query: canTransferOwnership) => CanTransferOwnershipResult | error | null)
  & ((query: transferChatOwnership) => Ok | error | null)
  & ((query: getChatMember) => ChatMember | error | null)
  & ((query: searchChatMembers) => ChatMembers | error | null)
  & ((query: getChatAdministrators) => ChatAdministrators | error | null)
  & ((query: clearAllDraftMessages) => Ok | error | null)
  & ((query: getChatNotificationSettingsExceptions) => Chats | error | null)
  & ((query: getScopeNotificationSettings) => ScopeNotificationSettings | error | null)
  & ((query: setScopeNotificationSettings) => Ok | error | null)
  & ((query: resetAllNotificationSettings) => Ok | error | null)
  & ((query: toggleChatIsPinned) => Ok | error | null)
  & ((query: setPinnedChats) => Ok | error | null)
  & ((query: downloadFile) => File | error | null)
  & ((query: getFileDownloadedPrefixSize) => Count | error | null)
  & ((query: cancelDownloadFile) => Ok | error | null)
  & ((query: getSuggestedFileName) => Text | error | null)
  & ((query: uploadFile) => File | error | null)
  & ((query: cancelUploadFile) => Ok | error | null)
  & ((query: writeGeneratedFilePart) => Ok | error | null)
  & ((query: setFileGenerationProgress) => Ok | error | null)
  & ((query: finishFileGeneration) => Ok | error | null)
  & ((query: readFilePart) => FilePart | error | null)
  & ((query: deleteFile) => Ok | error | null)
  & ((query: getMessageFileType) => MessageFileType | error | null)
  & ((query: getMessageImportConfirmationText) => Text | error | null)
  & ((query: importMessages) => Ok | error | null)
  & ((query: replacePrimaryChatInviteLink) => ChatInviteLink | error | null)
  & ((query: createChatInviteLink) => ChatInviteLink | error | null)
  & ((query: editChatInviteLink) => ChatInviteLink | error | null)
  & ((query: getChatInviteLink) => ChatInviteLink | error | null)
  & ((query: getChatInviteLinkCounts) => ChatInviteLinkCounts | error | null)
  & ((query: getChatInviteLinks) => ChatInviteLinks | error | null)
  & ((query: getChatInviteLinkMembers) => ChatInviteLinkMembers | error | null)
  & ((query: revokeChatInviteLink) => ChatInviteLinks | error | null)
  & ((query: deleteRevokedChatInviteLink) => Ok | error | null)
  & ((query: deleteAllRevokedChatInviteLinks) => Ok | error | null)
  & ((query: checkChatInviteLink) => ChatInviteLinkInfo | error | null)
  & ((query: joinChatByInviteLink) => Chat | error | null)
  & ((query: getChatJoinRequests) => ChatJoinRequests | error | null)
  & ((query: processChatJoinRequest) => Ok | error | null)
  & ((query: processChatJoinRequests) => Ok | error | null)
  & ((query: createCall) => CallId | error | null)
  & ((query: acceptCall) => Ok | error | null)
  & ((query: sendCallSignalingData) => Ok | error | null)
  & ((query: discardCall) => Ok | error | null)
  & ((query: sendCallRating) => Ok | error | null)
  & ((query: sendCallDebugInformation) => Ok | error | null)
  & ((query: getVideoChatAvailableParticipants) => MessageSenders | error | null)
  & ((query: setVideoChatDefaultParticipant) => Ok | error | null)
  & ((query: createVideoChat) => GroupCallId | error | null)
  & ((query: getGroupCall) => GroupCall | error | null)
  & ((query: startScheduledGroupCall) => Ok | error | null)
  & ((query: toggleGroupCallEnabledStartNotification) => Ok | error | null)
  & ((query: joinGroupCall) => Text | error | null)
  & ((query: startGroupCallScreenSharing) => Text | error | null)
  & ((query: toggleGroupCallScreenSharingIsPaused) => Ok | error | null)
  & ((query: endGroupCallScreenSharing) => Ok | error | null)
  & ((query: setGroupCallTitle) => Ok | error | null)
  & ((query: toggleGroupCallMuteNewParticipants) => Ok | error | null)
  & ((query: inviteGroupCallParticipants) => Ok | error | null)
  & ((query: getGroupCallInviteLink) => HttpUrl | error | null)
  & ((query: revokeGroupCallInviteLink) => Ok | error | null)
  & ((query: startGroupCallRecording) => Ok | error | null)
  & ((query: endGroupCallRecording) => Ok | error | null)
  & ((query: toggleGroupCallIsMyVideoPaused) => Ok | error | null)
  & ((query: toggleGroupCallIsMyVideoEnabled) => Ok | error | null)
  & ((query: setGroupCallParticipantIsSpeaking) => Ok | error | null)
  & ((query: toggleGroupCallParticipantIsMuted) => Ok | error | null)
  & ((query: setGroupCallParticipantVolumeLevel) => Ok | error | null)
  & ((query: toggleGroupCallParticipantIsHandRaised) => Ok | error | null)
  & ((query: loadGroupCallParticipants) => Ok | error | null)
  & ((query: leaveGroupCall) => Ok | error | null)
  & ((query: endGroupCall) => Ok | error | null)
  & ((query: getGroupCallStreamSegment) => FilePart | error | null)
  & ((query: toggleMessageSenderIsBlocked) => Ok | error | null)
  & ((query: blockMessageSenderFromReplies) => Ok | error | null)
  & ((query: getBlockedMessageSenders) => MessageSenders | error | null)
  & ((query: addContact) => Ok | error | null)
  & ((query: importContacts) => ImportedContacts | error | null)
  & ((query: getContacts) => Users | error | null)
  & ((query: searchContacts) => Users | error | null)
  & ((query: removeContacts) => Ok | error | null)
  & ((query: getImportedContactCount) => Count | error | null)
  & ((query: changeImportedContacts) => ImportedContacts | error | null)
  & ((query: clearImportedContacts) => Ok | error | null)
  & ((query: sharePhoneNumber) => Ok | error | null)
  & ((query: getUserProfilePhotos) => ChatPhotos | error | null)
  & ((query: getStickers) => Stickers | error | null)
  & ((query: searchStickers) => Stickers | error | null)
  & ((query: getInstalledStickerSets) => StickerSets | error | null)
  & ((query: getArchivedStickerSets) => StickerSets | error | null)
  & ((query: getTrendingStickerSets) => StickerSets | error | null)
  & ((query: getAttachedStickerSets) => StickerSets | error | null)
  & ((query: getStickerSet) => StickerSet | error | null)
  & ((query: searchStickerSet) => StickerSet | error | null)
  & ((query: searchInstalledStickerSets) => StickerSets | error | null)
  & ((query: searchStickerSets) => StickerSets | error | null)
  & ((query: changeStickerSet) => Ok | error | null)
  & ((query: viewTrendingStickerSets) => Ok | error | null)
  & ((query: reorderInstalledStickerSets) => Ok | error | null)
  & ((query: getRecentStickers) => Stickers | error | null)
  & ((query: addRecentSticker) => Stickers | error | null)
  & ((query: removeRecentSticker) => Ok | error | null)
  & ((query: clearRecentStickers) => Ok | error | null)
  & ((query: getFavoriteStickers) => Stickers | error | null)
  & ((query: addFavoriteSticker) => Ok | error | null)
  & ((query: removeFavoriteSticker) => Ok | error | null)
  & ((query: getStickerEmojis) => Emojis | error | null)
  & ((query: searchEmojis) => Emojis | error | null)
  & ((query: getAnimatedEmoji) => AnimatedEmoji | error | null)
  & ((query: getEmojiSuggestionsUrl) => HttpUrl | error | null)
  & ((query: getSavedAnimations) => Animations | error | null)
  & ((query: addSavedAnimation) => Ok | error | null)
  & ((query: removeSavedAnimation) => Ok | error | null)
  & ((query: getRecentInlineBots) => Users | error | null)
  & ((query: searchHashtags) => Hashtags | error | null)
  & ((query: removeRecentHashtag) => Ok | error | null)
  & ((query: getWebPagePreview) => WebPage | error | null)
  & ((query: getWebPageInstantView) => WebPageInstantView | error | null)
  & ((query: setProfilePhoto) => Ok | error | null)
  & ((query: deleteProfilePhoto) => Ok | error | null)
  & ((query: setName) => Ok | error | null)
  & ((query: setBio) => Ok | error | null)
  & ((query: setUsername) => Ok | error | null)
  & ((query: setLocation) => Ok | error | null)
  & ((query: changePhoneNumber) => AuthenticationCodeInfo | error | null)
  & ((query: resendChangePhoneNumberCode) => AuthenticationCodeInfo | error | null)
  & ((query: checkChangePhoneNumberCode) => Ok | error | null)
  & ((query: setCommands) => Ok | error | null)
  & ((query: deleteCommands) => Ok | error | null)
  & ((query: getCommands) => BotCommands | error | null)
  & ((query: getActiveSessions) => Sessions | error | null)
  & ((query: terminateSession) => Ok | error | null)
  & ((query: terminateAllOtherSessions) => Ok | error | null)
  & ((query: toggleSessionCanAcceptCalls) => Ok | error | null)
  & ((query: toggleSessionCanAcceptSecretChats) => Ok | error | null)
  & ((query: setInactiveSessionTtl) => Ok | error | null)
  & ((query: getConnectedWebsites) => ConnectedWebsites | error | null)
  & ((query: disconnectWebsite) => Ok | error | null)
  & ((query: disconnectAllWebsites) => Ok | error | null)
  & ((query: setSupergroupUsername) => Ok | error | null)
  & ((query: setSupergroupStickerSet) => Ok | error | null)
  & ((query: toggleSupergroupSignMessages) => Ok | error | null)
  & ((query: toggleSupergroupIsAllHistoryAvailable) => Ok | error | null)
  & ((query: toggleSupergroupIsBroadcastGroup) => Ok | error | null)
  & ((query: reportSupergroupSpam) => Ok | error | null)
  & ((query: getSupergroupMembers) => ChatMembers | error | null)
  & ((query: closeSecretChat) => Ok | error | null)
  & ((query: getChatEventLog) => ChatEvents | error | null)
  & ((query: getPaymentForm) => PaymentForm | error | null)
  & ((query: validateOrderInfo) => ValidatedOrderInfo | error | null)
  & ((query: sendPaymentForm) => PaymentResult | error | null)
  & ((query: getPaymentReceipt) => PaymentReceipt | error | null)
  & ((query: getSavedOrderInfo) => OrderInfo | error | null)
  & ((query: deleteSavedOrderInfo) => Ok | error | null)
  & ((query: deleteSavedCredentials) => Ok | error | null)
  & ((query: getSupportUser) => User | error | null)
  & ((query: getBackgrounds) => Backgrounds | error | null)
  & ((query: getBackgroundUrl) => HttpUrl | error | null)
  & ((query: searchBackground) => Background | error | null)
  & ((query: setBackground) => Background | error | null)
  & ((query: removeBackground) => Ok | error | null)
  & ((query: resetBackgrounds) => Ok | error | null)
  & ((query: getLocalizationTargetInfo) => LocalizationTargetInfo | error | null)
  & ((query: getLanguagePackInfo) => LanguagePackInfo | error | null)
  & ((query: getLanguagePackStrings) => LanguagePackStrings | error | null)
  & ((query: synchronizeLanguagePack) => Ok | error | null)
  & ((query: addCustomServerLanguagePack) => Ok | error | null)
  & ((query: setCustomLanguagePack) => Ok | error | null)
  & ((query: editCustomLanguagePackInfo) => Ok | error | null)
  & ((query: setCustomLanguagePackString) => Ok | error | null)
  & ((query: deleteLanguagePack) => Ok | error | null)
  & ((query: registerDevice) => PushReceiverId | error | null)
  & ((query: processPushNotification) => Ok | error | null)
  & ((query: getPushReceiverId) => PushReceiverId | error | null)
  & ((query: getRecentlyVisitedTMeUrls) => TMeUrls | error | null)
  & ((query: setUserPrivacySettingRules) => Ok | error | null)
  & ((query: getUserPrivacySettingRules) => UserPrivacySettingRules | error | null)
  & ((query: getOption) => OptionValue | error | null)
  & ((query: setOption) => Ok | error | null)
  & ((query: setAccountTtl) => Ok | error | null)
  & ((query: getAccountTtl) => AccountTtl | error | null)
  & ((query: deleteAccount) => Ok | error | null)
  & ((query: removeChatActionBar) => Ok | error | null)
  & ((query: reportChat) => Ok | error | null)
  & ((query: reportChatPhoto) => Ok | error | null)
  & ((query: getChatStatistics) => ChatStatistics | error | null)
  & ((query: getMessageStatistics) => MessageStatistics | error | null)
  & ((query: getStatisticalGraph) => StatisticalGraph | error | null)
  & ((query: getStorageStatistics) => StorageStatistics | error | null)
  & ((query: getStorageStatisticsFast) => StorageStatisticsFast | error | null)
  & ((query: getDatabaseStatistics) => DatabaseStatistics | error | null)
  & ((query: optimizeStorage) => StorageStatistics | error | null)
  & ((query: setNetworkType) => Ok | error | null)
  & ((query: getNetworkStatistics) => NetworkStatistics | error | null)
  & ((query: addNetworkStatistics) => Ok | error | null)
  & ((query: resetNetworkStatistics) => Ok | error | null)
  & ((query: getAutoDownloadSettingsPresets) => AutoDownloadSettingsPresets | error | null)
  & ((query: setAutoDownloadSettings) => Ok | error | null)
  & ((query: getBankCardInfo) => BankCardInfo | error | null)
  & ((query: getPassportElement) => PassportElement | error | null)
  & ((query: getAllPassportElements) => PassportElements | error | null)
  & ((query: setPassportElement) => PassportElement | error | null)
  & ((query: deletePassportElement) => Ok | error | null)
  & ((query: setPassportElementErrors) => Ok | error | null)
  & ((query: getPreferredCountryLanguage) => Text | error | null)
  & ((query: sendPhoneNumberVerificationCode) => AuthenticationCodeInfo | error | null)
  & ((query: resendPhoneNumberVerificationCode) => AuthenticationCodeInfo | error | null)
  & ((query: checkPhoneNumberVerificationCode) => Ok | error | null)
  & ((query: sendEmailAddressVerificationCode) => EmailAddressAuthenticationCodeInfo | error | null)
  & ((query: resendEmailAddressVerificationCode) => EmailAddressAuthenticationCodeInfo | error | null)
  & ((query: checkEmailAddressVerificationCode) => Ok | error | null)
  & ((query: getPassportAuthorizationForm) => PassportAuthorizationForm | error | null)
  & ((query: getPassportAuthorizationFormAvailableElements) => PassportElementsWithErrors | error | null)
  & ((query: sendPassportAuthorizationForm) => Ok | error | null)
  & ((query: sendPhoneNumberConfirmationCode) => AuthenticationCodeInfo | error | null)
  & ((query: resendPhoneNumberConfirmationCode) => AuthenticationCodeInfo | error | null)
  & ((query: checkPhoneNumberConfirmationCode) => Ok | error | null)
  & ((query: setBotUpdatesStatus) => Ok | error | null)
  & ((query: uploadStickerFile) => File | error | null)
  & ((query: getSuggestedStickerSetName) => Text | error | null)
  & ((query: checkStickerSetName) => CheckStickerSetNameResult | error | null)
  & ((query: createNewStickerSet) => StickerSet | error | null)
  & ((query: addStickerToSet) => StickerSet | error | null)
  & ((query: setStickerSetThumbnail) => StickerSet | error | null)
  & ((query: setStickerPositionInSet) => Ok | error | null)
  & ((query: removeStickerFromSet) => Ok | error | null)
  & ((query: getMapThumbnailFile) => File | error | null)
  & ((query: acceptTermsOfService) => Ok | error | null)
  & ((query: sendCustomRequest) => CustomRequestResult | error | null)
  & ((query: answerCustomQuery) => Ok | error | null)
  & ((query: setAlarm) => Ok | error | null)
  & ((query: getCountries) => Countries | error | null)
  & ((query: getCountryCode) => Text | error | null)
  & ((query: getPhoneNumberInfo) => PhoneNumberInfo | error | null)
  & ((query: getPhoneNumberInfoSync) => PhoneNumberInfo | error | null)
  & ((query: getApplicationDownloadLink) => HttpUrl | error | null)
  & ((query: getDeepLinkInfo) => DeepLinkInfo | error | null)
  & ((query: getApplicationConfig) => JsonValue | error | null)
  & ((query: saveApplicationLogEvent) => Ok | error | null)
  & ((query: addProxy) => Proxy | error | null)
  & ((query: editProxy) => Proxy | error | null)
  & ((query: enableProxy) => Ok | error | null)
  & ((query: disableProxy) => Ok | error | null)
  & ((query: removeProxy) => Ok | error | null)
  & ((query: getProxies) => Proxies | error | null)
  & ((query: getProxyLink) => HttpUrl | error | null)
  & ((query: pingProxy) => Seconds | error | null)
  & ((query: setLogStream) => Ok | error | null)
  & ((query: getLogStream) => LogStream | error | null)
  & ((query: setLogVerbosityLevel) => Ok | error | null)
  & ((query: getLogVerbosityLevel) => LogVerbosityLevel | error | null)
  & ((query: getLogTags) => LogTags | error | null)
  & ((query: setLogTagVerbosityLevel) => Ok | error | null)
  & ((query: getLogTagVerbosityLevel) => LogVerbosityLevel | error | null)
  & ((query: addLogMessage) => Ok | error | null)
  & ((query: testCallEmpty) => Ok | error | null)
  & ((query: testCallString) => TestString | error | null)
  & ((query: testCallBytes) => TestBytes | error | null)
  & ((query: testCallVectorInt) => TestVectorInt | error | null)
  & ((query: testCallVectorIntObject) => TestVectorIntObject | error | null)
  & ((query: testCallVectorString) => TestVectorString | error | null)
  & ((query: testCallVectorStringObject) => TestVectorStringObject | error | null)
  & ((query: testSquareInt) => TestInt | error | null)
  & ((query: testNetwork) => Ok | error | null)
  & ((query: testProxy) => Ok | error | null)
  & ((query: testGetDifference) => Ok | error | null)
  & ((query: testUseUpdate) => Update | error | null)
  & ((query: testReturnError) => Error | error | null)

// Fluture support.
// Tested with fluture v8.0.
// Future<Left, Right>
import { Future } from 'fluture'

export type InvokeFuture =
  & ((query: getAuthorizationState) => Future<error, AuthorizationState>)
  & ((query: setTdlibParameters) => Future<error, Ok>)
  & ((query: checkDatabaseEncryptionKey) => Future<error, Ok>)
  & ((query: setAuthenticationPhoneNumber) => Future<error, Ok>)
  & ((query: resendAuthenticationCode) => Future<error, Ok>)
  & ((query: checkAuthenticationCode) => Future<error, Ok>)
  & ((query: requestQrCodeAuthentication) => Future<error, Ok>)
  & ((query: registerUser) => Future<error, Ok>)
  & ((query: checkAuthenticationPassword) => Future<error, Ok>)
  & ((query: requestAuthenticationPasswordRecovery) => Future<error, Ok>)
  & ((query: checkAuthenticationPasswordRecoveryCode) => Future<error, Ok>)
  & ((query: recoverAuthenticationPassword) => Future<error, Ok>)
  & ((query: checkAuthenticationBotToken) => Future<error, Ok>)
  & ((query: logOut) => Future<error, Ok>)
  & ((query: close) => Future<error, Ok>)
  & ((query: destroy) => Future<error, Ok>)
  & ((query: confirmQrCodeAuthentication) => Future<error, Session>)
  & ((query: getCurrentState) => Future<error, Updates>)
  & ((query: setDatabaseEncryptionKey) => Future<error, Ok>)
  & ((query: getPasswordState) => Future<error, PasswordState>)
  & ((query: setPassword) => Future<error, PasswordState>)
  & ((query: getRecoveryEmailAddress) => Future<error, RecoveryEmailAddress>)
  & ((query: setRecoveryEmailAddress) => Future<error, PasswordState>)
  & ((query: checkRecoveryEmailAddressCode) => Future<error, PasswordState>)
  & ((query: resendRecoveryEmailAddressCode) => Future<error, PasswordState>)
  & ((query: requestPasswordRecovery) => Future<error, EmailAddressAuthenticationCodeInfo>)
  & ((query: checkPasswordRecoveryCode) => Future<error, Ok>)
  & ((query: recoverPassword) => Future<error, PasswordState>)
  & ((query: resetPassword) => Future<error, ResetPasswordResult>)
  & ((query: cancelPasswordReset) => Future<error, Ok>)
  & ((query: createTemporaryPassword) => Future<error, TemporaryPasswordState>)
  & ((query: getTemporaryPasswordState) => Future<error, TemporaryPasswordState>)
  & ((query: getMe) => Future<error, User>)
  & ((query: getUser) => Future<error, User>)
  & ((query: getUserFullInfo) => Future<error, UserFullInfo>)
  & ((query: getBasicGroup) => Future<error, BasicGroup>)
  & ((query: getBasicGroupFullInfo) => Future<error, BasicGroupFullInfo>)
  & ((query: getSupergroup) => Future<error, Supergroup>)
  & ((query: getSupergroupFullInfo) => Future<error, SupergroupFullInfo>)
  & ((query: getSecretChat) => Future<error, SecretChat>)
  & ((query: getChat) => Future<error, Chat>)
  & ((query: getMessage) => Future<error, Message>)
  & ((query: getMessageLocally) => Future<error, Message>)
  & ((query: getRepliedMessage) => Future<error, Message>)
  & ((query: getChatPinnedMessage) => Future<error, Message>)
  & ((query: getCallbackQueryMessage) => Future<error, Message>)
  & ((query: getMessages) => Future<error, Messages>)
  & ((query: getMessageThread) => Future<error, MessageThreadInfo>)
  & ((query: getMessageViewers) => Future<error, Users>)
  & ((query: getFile) => Future<error, File>)
  & ((query: getRemoteFile) => Future<error, File>)
  & ((query: loadChats) => Future<error, Ok>)
  & ((query: getChats) => Future<error, Chats>)
  & ((query: searchPublicChat) => Future<error, Chat>)
  & ((query: searchPublicChats) => Future<error, Chats>)
  & ((query: searchChats) => Future<error, Chats>)
  & ((query: searchChatsOnServer) => Future<error, Chats>)
  & ((query: searchChatsNearby) => Future<error, ChatsNearby>)
  & ((query: getTopChats) => Future<error, Chats>)
  & ((query: removeTopChat) => Future<error, Ok>)
  & ((query: addRecentlyFoundChat) => Future<error, Ok>)
  & ((query: removeRecentlyFoundChat) => Future<error, Ok>)
  & ((query: clearRecentlyFoundChats) => Future<error, Ok>)
  & ((query: getRecentlyOpenedChats) => Future<error, Chats>)
  & ((query: checkChatUsername) => Future<error, CheckChatUsernameResult>)
  & ((query: getCreatedPublicChats) => Future<error, Chats>)
  & ((query: checkCreatedPublicChatsLimit) => Future<error, Ok>)
  & ((query: getSuitableDiscussionChats) => Future<error, Chats>)
  & ((query: getInactiveSupergroupChats) => Future<error, Chats>)
  & ((query: getGroupsInCommon) => Future<error, Chats>)
  & ((query: getChatHistory) => Future<error, Messages>)
  & ((query: getMessageThreadHistory) => Future<error, Messages>)
  & ((query: deleteChatHistory) => Future<error, Ok>)
  & ((query: deleteChat) => Future<error, Ok>)
  & ((query: searchChatMessages) => Future<error, Messages>)
  & ((query: searchMessages) => Future<error, Messages>)
  & ((query: searchSecretMessages) => Future<error, FoundMessages>)
  & ((query: searchCallMessages) => Future<error, Messages>)
  & ((query: deleteAllCallMessages) => Future<error, Ok>)
  & ((query: searchChatRecentLocationMessages) => Future<error, Messages>)
  & ((query: getActiveLiveLocationMessages) => Future<error, Messages>)
  & ((query: getChatMessageByDate) => Future<error, Message>)
  & ((query: getChatSparseMessagePositions) => Future<error, MessagePositions>)
  & ((query: getChatMessageCalendar) => Future<error, MessageCalendar>)
  & ((query: getChatMessageCount) => Future<error, Count>)
  & ((query: getChatScheduledMessages) => Future<error, Messages>)
  & ((query: getMessagePublicForwards) => Future<error, FoundMessages>)
  & ((query: getChatSponsoredMessage) => Future<error, SponsoredMessage>)
  & ((query: removeNotification) => Future<error, Ok>)
  & ((query: removeNotificationGroup) => Future<error, Ok>)
  & ((query: getMessageLink) => Future<error, MessageLink>)
  & ((query: getMessageEmbeddingCode) => Future<error, Text>)
  & ((query: getMessageLinkInfo) => Future<error, MessageLinkInfo>)
  & ((query: getChatAvailableMessageSenders) => Future<error, MessageSenders>)
  & ((query: setChatMessageSender) => Future<error, Ok>)
  & ((query: sendMessage) => Future<error, Message>)
  & ((query: sendMessageAlbum) => Future<error, Messages>)
  & ((query: sendBotStartMessage) => Future<error, Message>)
  & ((query: sendInlineQueryResultMessage) => Future<error, Message>)
  & ((query: forwardMessages) => Future<error, Messages>)
  & ((query: resendMessages) => Future<error, Messages>)
  & ((query: sendChatScreenshotTakenNotification) => Future<error, Ok>)
  & ((query: addLocalMessage) => Future<error, Message>)
  & ((query: deleteMessages) => Future<error, Ok>)
  & ((query: deleteChatMessagesBySender) => Future<error, Ok>)
  & ((query: deleteChatMessagesByDate) => Future<error, Ok>)
  & ((query: editMessageText) => Future<error, Message>)
  & ((query: editMessageLiveLocation) => Future<error, Message>)
  & ((query: editMessageMedia) => Future<error, Message>)
  & ((query: editMessageCaption) => Future<error, Message>)
  & ((query: editMessageReplyMarkup) => Future<error, Message>)
  & ((query: editInlineMessageText) => Future<error, Ok>)
  & ((query: editInlineMessageLiveLocation) => Future<error, Ok>)
  & ((query: editInlineMessageMedia) => Future<error, Ok>)
  & ((query: editInlineMessageCaption) => Future<error, Ok>)
  & ((query: editInlineMessageReplyMarkup) => Future<error, Ok>)
  & ((query: editMessageSchedulingState) => Future<error, Ok>)
  & ((query: getTextEntities) => Future<error, TextEntities>)
  & ((query: parseTextEntities) => Future<error, FormattedText>)
  & ((query: parseMarkdown) => Future<error, FormattedText>)
  & ((query: getMarkdownText) => Future<error, FormattedText>)
  & ((query: getFileMimeType) => Future<error, Text>)
  & ((query: getFileExtension) => Future<error, Text>)
  & ((query: cleanFileName) => Future<error, Text>)
  & ((query: getLanguagePackString) => Future<error, LanguagePackStringValue>)
  & ((query: getJsonValue) => Future<error, JsonValue>)
  & ((query: getJsonString) => Future<error, Text>)
  & ((query: setPollAnswer) => Future<error, Ok>)
  & ((query: getPollVoters) => Future<error, Users>)
  & ((query: stopPoll) => Future<error, Ok>)
  & ((query: hideSuggestedAction) => Future<error, Ok>)
  & ((query: getLoginUrlInfo) => Future<error, LoginUrlInfo>)
  & ((query: getLoginUrl) => Future<error, HttpUrl>)
  & ((query: getInlineQueryResults) => Future<error, InlineQueryResults>)
  & ((query: answerInlineQuery) => Future<error, Ok>)
  & ((query: getCallbackQueryAnswer) => Future<error, CallbackQueryAnswer>)
  & ((query: answerCallbackQuery) => Future<error, Ok>)
  & ((query: answerShippingQuery) => Future<error, Ok>)
  & ((query: answerPreCheckoutQuery) => Future<error, Ok>)
  & ((query: setGameScore) => Future<error, Message>)
  & ((query: setInlineGameScore) => Future<error, Ok>)
  & ((query: getGameHighScores) => Future<error, GameHighScores>)
  & ((query: getInlineGameHighScores) => Future<error, GameHighScores>)
  & ((query: deleteChatReplyMarkup) => Future<error, Ok>)
  & ((query: sendChatAction) => Future<error, Ok>)
  & ((query: openChat) => Future<error, Ok>)
  & ((query: closeChat) => Future<error, Ok>)
  & ((query: viewMessages) => Future<error, Ok>)
  & ((query: openMessageContent) => Future<error, Ok>)
  & ((query: clickAnimatedEmojiMessage) => Future<error, Sticker>)
  & ((query: getInternalLinkType) => Future<error, InternalLinkType>)
  & ((query: getExternalLinkInfo) => Future<error, LoginUrlInfo>)
  & ((query: getExternalLink) => Future<error, HttpUrl>)
  & ((query: readAllChatMentions) => Future<error, Ok>)
  & ((query: createPrivateChat) => Future<error, Chat>)
  & ((query: createBasicGroupChat) => Future<error, Chat>)
  & ((query: createSupergroupChat) => Future<error, Chat>)
  & ((query: createSecretChat) => Future<error, Chat>)
  & ((query: createNewBasicGroupChat) => Future<error, Chat>)
  & ((query: createNewSupergroupChat) => Future<error, Chat>)
  & ((query: createNewSecretChat) => Future<error, Chat>)
  & ((query: upgradeBasicGroupChatToSupergroupChat) => Future<error, Chat>)
  & ((query: getChatListsToAddChat) => Future<error, ChatLists>)
  & ((query: addChatToList) => Future<error, Ok>)
  & ((query: getChatFilter) => Future<error, ChatFilter>)
  & ((query: createChatFilter) => Future<error, ChatFilterInfo>)
  & ((query: editChatFilter) => Future<error, ChatFilterInfo>)
  & ((query: deleteChatFilter) => Future<error, Ok>)
  & ((query: reorderChatFilters) => Future<error, Ok>)
  & ((query: getRecommendedChatFilters) => Future<error, RecommendedChatFilters>)
  & ((query: getChatFilterDefaultIconName) => Future<error, Text>)
  & ((query: setChatTitle) => Future<error, Ok>)
  & ((query: setChatPhoto) => Future<error, Ok>)
  & ((query: setChatMessageTtl) => Future<error, Ok>)
  & ((query: setChatPermissions) => Future<error, Ok>)
  & ((query: setChatTheme) => Future<error, Ok>)
  & ((query: setChatDraftMessage) => Future<error, Ok>)
  & ((query: setChatNotificationSettings) => Future<error, Ok>)
  & ((query: toggleChatHasProtectedContent) => Future<error, Ok>)
  & ((query: toggleChatIsMarkedAsUnread) => Future<error, Ok>)
  & ((query: toggleChatDefaultDisableNotification) => Future<error, Ok>)
  & ((query: setChatClientData) => Future<error, Ok>)
  & ((query: setChatDescription) => Future<error, Ok>)
  & ((query: setChatDiscussionGroup) => Future<error, Ok>)
  & ((query: setChatLocation) => Future<error, Ok>)
  & ((query: setChatSlowModeDelay) => Future<error, Ok>)
  & ((query: pinChatMessage) => Future<error, Ok>)
  & ((query: unpinChatMessage) => Future<error, Ok>)
  & ((query: unpinAllChatMessages) => Future<error, Ok>)
  & ((query: joinChat) => Future<error, Ok>)
  & ((query: leaveChat) => Future<error, Ok>)
  & ((query: addChatMember) => Future<error, Ok>)
  & ((query: addChatMembers) => Future<error, Ok>)
  & ((query: setChatMemberStatus) => Future<error, Ok>)
  & ((query: banChatMember) => Future<error, Ok>)
  & ((query: canTransferOwnership) => Future<error, CanTransferOwnershipResult>)
  & ((query: transferChatOwnership) => Future<error, Ok>)
  & ((query: getChatMember) => Future<error, ChatMember>)
  & ((query: searchChatMembers) => Future<error, ChatMembers>)
  & ((query: getChatAdministrators) => Future<error, ChatAdministrators>)
  & ((query: clearAllDraftMessages) => Future<error, Ok>)
  & ((query: getChatNotificationSettingsExceptions) => Future<error, Chats>)
  & ((query: getScopeNotificationSettings) => Future<error, ScopeNotificationSettings>)
  & ((query: setScopeNotificationSettings) => Future<error, Ok>)
  & ((query: resetAllNotificationSettings) => Future<error, Ok>)
  & ((query: toggleChatIsPinned) => Future<error, Ok>)
  & ((query: setPinnedChats) => Future<error, Ok>)
  & ((query: downloadFile) => Future<error, File>)
  & ((query: getFileDownloadedPrefixSize) => Future<error, Count>)
  & ((query: cancelDownloadFile) => Future<error, Ok>)
  & ((query: getSuggestedFileName) => Future<error, Text>)
  & ((query: uploadFile) => Future<error, File>)
  & ((query: cancelUploadFile) => Future<error, Ok>)
  & ((query: writeGeneratedFilePart) => Future<error, Ok>)
  & ((query: setFileGenerationProgress) => Future<error, Ok>)
  & ((query: finishFileGeneration) => Future<error, Ok>)
  & ((query: readFilePart) => Future<error, FilePart>)
  & ((query: deleteFile) => Future<error, Ok>)
  & ((query: getMessageFileType) => Future<error, MessageFileType>)
  & ((query: getMessageImportConfirmationText) => Future<error, Text>)
  & ((query: importMessages) => Future<error, Ok>)
  & ((query: replacePrimaryChatInviteLink) => Future<error, ChatInviteLink>)
  & ((query: createChatInviteLink) => Future<error, ChatInviteLink>)
  & ((query: editChatInviteLink) => Future<error, ChatInviteLink>)
  & ((query: getChatInviteLink) => Future<error, ChatInviteLink>)
  & ((query: getChatInviteLinkCounts) => Future<error, ChatInviteLinkCounts>)
  & ((query: getChatInviteLinks) => Future<error, ChatInviteLinks>)
  & ((query: getChatInviteLinkMembers) => Future<error, ChatInviteLinkMembers>)
  & ((query: revokeChatInviteLink) => Future<error, ChatInviteLinks>)
  & ((query: deleteRevokedChatInviteLink) => Future<error, Ok>)
  & ((query: deleteAllRevokedChatInviteLinks) => Future<error, Ok>)
  & ((query: checkChatInviteLink) => Future<error, ChatInviteLinkInfo>)
  & ((query: joinChatByInviteLink) => Future<error, Chat>)
  & ((query: getChatJoinRequests) => Future<error, ChatJoinRequests>)
  & ((query: processChatJoinRequest) => Future<error, Ok>)
  & ((query: processChatJoinRequests) => Future<error, Ok>)
  & ((query: createCall) => Future<error, CallId>)
  & ((query: acceptCall) => Future<error, Ok>)
  & ((query: sendCallSignalingData) => Future<error, Ok>)
  & ((query: discardCall) => Future<error, Ok>)
  & ((query: sendCallRating) => Future<error, Ok>)
  & ((query: sendCallDebugInformation) => Future<error, Ok>)
  & ((query: getVideoChatAvailableParticipants) => Future<error, MessageSenders>)
  & ((query: setVideoChatDefaultParticipant) => Future<error, Ok>)
  & ((query: createVideoChat) => Future<error, GroupCallId>)
  & ((query: getGroupCall) => Future<error, GroupCall>)
  & ((query: startScheduledGroupCall) => Future<error, Ok>)
  & ((query: toggleGroupCallEnabledStartNotification) => Future<error, Ok>)
  & ((query: joinGroupCall) => Future<error, Text>)
  & ((query: startGroupCallScreenSharing) => Future<error, Text>)
  & ((query: toggleGroupCallScreenSharingIsPaused) => Future<error, Ok>)
  & ((query: endGroupCallScreenSharing) => Future<error, Ok>)
  & ((query: setGroupCallTitle) => Future<error, Ok>)
  & ((query: toggleGroupCallMuteNewParticipants) => Future<error, Ok>)
  & ((query: inviteGroupCallParticipants) => Future<error, Ok>)
  & ((query: getGroupCallInviteLink) => Future<error, HttpUrl>)
  & ((query: revokeGroupCallInviteLink) => Future<error, Ok>)
  & ((query: startGroupCallRecording) => Future<error, Ok>)
  & ((query: endGroupCallRecording) => Future<error, Ok>)
  & ((query: toggleGroupCallIsMyVideoPaused) => Future<error, Ok>)
  & ((query: toggleGroupCallIsMyVideoEnabled) => Future<error, Ok>)
  & ((query: setGroupCallParticipantIsSpeaking) => Future<error, Ok>)
  & ((query: toggleGroupCallParticipantIsMuted) => Future<error, Ok>)
  & ((query: setGroupCallParticipantVolumeLevel) => Future<error, Ok>)
  & ((query: toggleGroupCallParticipantIsHandRaised) => Future<error, Ok>)
  & ((query: loadGroupCallParticipants) => Future<error, Ok>)
  & ((query: leaveGroupCall) => Future<error, Ok>)
  & ((query: endGroupCall) => Future<error, Ok>)
  & ((query: getGroupCallStreamSegment) => Future<error, FilePart>)
  & ((query: toggleMessageSenderIsBlocked) => Future<error, Ok>)
  & ((query: blockMessageSenderFromReplies) => Future<error, Ok>)
  & ((query: getBlockedMessageSenders) => Future<error, MessageSenders>)
  & ((query: addContact) => Future<error, Ok>)
  & ((query: importContacts) => Future<error, ImportedContacts>)
  & ((query: getContacts) => Future<error, Users>)
  & ((query: searchContacts) => Future<error, Users>)
  & ((query: removeContacts) => Future<error, Ok>)
  & ((query: getImportedContactCount) => Future<error, Count>)
  & ((query: changeImportedContacts) => Future<error, ImportedContacts>)
  & ((query: clearImportedContacts) => Future<error, Ok>)
  & ((query: sharePhoneNumber) => Future<error, Ok>)
  & ((query: getUserProfilePhotos) => Future<error, ChatPhotos>)
  & ((query: getStickers) => Future<error, Stickers>)
  & ((query: searchStickers) => Future<error, Stickers>)
  & ((query: getInstalledStickerSets) => Future<error, StickerSets>)
  & ((query: getArchivedStickerSets) => Future<error, StickerSets>)
  & ((query: getTrendingStickerSets) => Future<error, StickerSets>)
  & ((query: getAttachedStickerSets) => Future<error, StickerSets>)
  & ((query: getStickerSet) => Future<error, StickerSet>)
  & ((query: searchStickerSet) => Future<error, StickerSet>)
  & ((query: searchInstalledStickerSets) => Future<error, StickerSets>)
  & ((query: searchStickerSets) => Future<error, StickerSets>)
  & ((query: changeStickerSet) => Future<error, Ok>)
  & ((query: viewTrendingStickerSets) => Future<error, Ok>)
  & ((query: reorderInstalledStickerSets) => Future<error, Ok>)
  & ((query: getRecentStickers) => Future<error, Stickers>)
  & ((query: addRecentSticker) => Future<error, Stickers>)
  & ((query: removeRecentSticker) => Future<error, Ok>)
  & ((query: clearRecentStickers) => Future<error, Ok>)
  & ((query: getFavoriteStickers) => Future<error, Stickers>)
  & ((query: addFavoriteSticker) => Future<error, Ok>)
  & ((query: removeFavoriteSticker) => Future<error, Ok>)
  & ((query: getStickerEmojis) => Future<error, Emojis>)
  & ((query: searchEmojis) => Future<error, Emojis>)
  & ((query: getAnimatedEmoji) => Future<error, AnimatedEmoji>)
  & ((query: getEmojiSuggestionsUrl) => Future<error, HttpUrl>)
  & ((query: getSavedAnimations) => Future<error, Animations>)
  & ((query: addSavedAnimation) => Future<error, Ok>)
  & ((query: removeSavedAnimation) => Future<error, Ok>)
  & ((query: getRecentInlineBots) => Future<error, Users>)
  & ((query: searchHashtags) => Future<error, Hashtags>)
  & ((query: removeRecentHashtag) => Future<error, Ok>)
  & ((query: getWebPagePreview) => Future<error, WebPage>)
  & ((query: getWebPageInstantView) => Future<error, WebPageInstantView>)
  & ((query: setProfilePhoto) => Future<error, Ok>)
  & ((query: deleteProfilePhoto) => Future<error, Ok>)
  & ((query: setName) => Future<error, Ok>)
  & ((query: setBio) => Future<error, Ok>)
  & ((query: setUsername) => Future<error, Ok>)
  & ((query: setLocation) => Future<error, Ok>)
  & ((query: changePhoneNumber) => Future<error, AuthenticationCodeInfo>)
  & ((query: resendChangePhoneNumberCode) => Future<error, AuthenticationCodeInfo>)
  & ((query: checkChangePhoneNumberCode) => Future<error, Ok>)
  & ((query: setCommands) => Future<error, Ok>)
  & ((query: deleteCommands) => Future<error, Ok>)
  & ((query: getCommands) => Future<error, BotCommands>)
  & ((query: getActiveSessions) => Future<error, Sessions>)
  & ((query: terminateSession) => Future<error, Ok>)
  & ((query: terminateAllOtherSessions) => Future<error, Ok>)
  & ((query: toggleSessionCanAcceptCalls) => Future<error, Ok>)
  & ((query: toggleSessionCanAcceptSecretChats) => Future<error, Ok>)
  & ((query: setInactiveSessionTtl) => Future<error, Ok>)
  & ((query: getConnectedWebsites) => Future<error, ConnectedWebsites>)
  & ((query: disconnectWebsite) => Future<error, Ok>)
  & ((query: disconnectAllWebsites) => Future<error, Ok>)
  & ((query: setSupergroupUsername) => Future<error, Ok>)
  & ((query: setSupergroupStickerSet) => Future<error, Ok>)
  & ((query: toggleSupergroupSignMessages) => Future<error, Ok>)
  & ((query: toggleSupergroupIsAllHistoryAvailable) => Future<error, Ok>)
  & ((query: toggleSupergroupIsBroadcastGroup) => Future<error, Ok>)
  & ((query: reportSupergroupSpam) => Future<error, Ok>)
  & ((query: getSupergroupMembers) => Future<error, ChatMembers>)
  & ((query: closeSecretChat) => Future<error, Ok>)
  & ((query: getChatEventLog) => Future<error, ChatEvents>)
  & ((query: getPaymentForm) => Future<error, PaymentForm>)
  & ((query: validateOrderInfo) => Future<error, ValidatedOrderInfo>)
  & ((query: sendPaymentForm) => Future<error, PaymentResult>)
  & ((query: getPaymentReceipt) => Future<error, PaymentReceipt>)
  & ((query: getSavedOrderInfo) => Future<error, OrderInfo>)
  & ((query: deleteSavedOrderInfo) => Future<error, Ok>)
  & ((query: deleteSavedCredentials) => Future<error, Ok>)
  & ((query: getSupportUser) => Future<error, User>)
  & ((query: getBackgrounds) => Future<error, Backgrounds>)
  & ((query: getBackgroundUrl) => Future<error, HttpUrl>)
  & ((query: searchBackground) => Future<error, Background>)
  & ((query: setBackground) => Future<error, Background>)
  & ((query: removeBackground) => Future<error, Ok>)
  & ((query: resetBackgrounds) => Future<error, Ok>)
  & ((query: getLocalizationTargetInfo) => Future<error, LocalizationTargetInfo>)
  & ((query: getLanguagePackInfo) => Future<error, LanguagePackInfo>)
  & ((query: getLanguagePackStrings) => Future<error, LanguagePackStrings>)
  & ((query: synchronizeLanguagePack) => Future<error, Ok>)
  & ((query: addCustomServerLanguagePack) => Future<error, Ok>)
  & ((query: setCustomLanguagePack) => Future<error, Ok>)
  & ((query: editCustomLanguagePackInfo) => Future<error, Ok>)
  & ((query: setCustomLanguagePackString) => Future<error, Ok>)
  & ((query: deleteLanguagePack) => Future<error, Ok>)
  & ((query: registerDevice) => Future<error, PushReceiverId>)
  & ((query: processPushNotification) => Future<error, Ok>)
  & ((query: getPushReceiverId) => Future<error, PushReceiverId>)
  & ((query: getRecentlyVisitedTMeUrls) => Future<error, TMeUrls>)
  & ((query: setUserPrivacySettingRules) => Future<error, Ok>)
  & ((query: getUserPrivacySettingRules) => Future<error, UserPrivacySettingRules>)
  & ((query: getOption) => Future<error, OptionValue>)
  & ((query: setOption) => Future<error, Ok>)
  & ((query: setAccountTtl) => Future<error, Ok>)
  & ((query: getAccountTtl) => Future<error, AccountTtl>)
  & ((query: deleteAccount) => Future<error, Ok>)
  & ((query: removeChatActionBar) => Future<error, Ok>)
  & ((query: reportChat) => Future<error, Ok>)
  & ((query: reportChatPhoto) => Future<error, Ok>)
  & ((query: getChatStatistics) => Future<error, ChatStatistics>)
  & ((query: getMessageStatistics) => Future<error, MessageStatistics>)
  & ((query: getStatisticalGraph) => Future<error, StatisticalGraph>)
  & ((query: getStorageStatistics) => Future<error, StorageStatistics>)
  & ((query: getStorageStatisticsFast) => Future<error, StorageStatisticsFast>)
  & ((query: getDatabaseStatistics) => Future<error, DatabaseStatistics>)
  & ((query: optimizeStorage) => Future<error, StorageStatistics>)
  & ((query: setNetworkType) => Future<error, Ok>)
  & ((query: getNetworkStatistics) => Future<error, NetworkStatistics>)
  & ((query: addNetworkStatistics) => Future<error, Ok>)
  & ((query: resetNetworkStatistics) => Future<error, Ok>)
  & ((query: getAutoDownloadSettingsPresets) => Future<error, AutoDownloadSettingsPresets>)
  & ((query: setAutoDownloadSettings) => Future<error, Ok>)
  & ((query: getBankCardInfo) => Future<error, BankCardInfo>)
  & ((query: getPassportElement) => Future<error, PassportElement>)
  & ((query: getAllPassportElements) => Future<error, PassportElements>)
  & ((query: setPassportElement) => Future<error, PassportElement>)
  & ((query: deletePassportElement) => Future<error, Ok>)
  & ((query: setPassportElementErrors) => Future<error, Ok>)
  & ((query: getPreferredCountryLanguage) => Future<error, Text>)
  & ((query: sendPhoneNumberVerificationCode) => Future<error, AuthenticationCodeInfo>)
  & ((query: resendPhoneNumberVerificationCode) => Future<error, AuthenticationCodeInfo>)
  & ((query: checkPhoneNumberVerificationCode) => Future<error, Ok>)
  & ((query: sendEmailAddressVerificationCode) => Future<error, EmailAddressAuthenticationCodeInfo>)
  & ((query: resendEmailAddressVerificationCode) => Future<error, EmailAddressAuthenticationCodeInfo>)
  & ((query: checkEmailAddressVerificationCode) => Future<error, Ok>)
  & ((query: getPassportAuthorizationForm) => Future<error, PassportAuthorizationForm>)
  & ((query: getPassportAuthorizationFormAvailableElements) => Future<error, PassportElementsWithErrors>)
  & ((query: sendPassportAuthorizationForm) => Future<error, Ok>)
  & ((query: sendPhoneNumberConfirmationCode) => Future<error, AuthenticationCodeInfo>)
  & ((query: resendPhoneNumberConfirmationCode) => Future<error, AuthenticationCodeInfo>)
  & ((query: checkPhoneNumberConfirmationCode) => Future<error, Ok>)
  & ((query: setBotUpdatesStatus) => Future<error, Ok>)
  & ((query: uploadStickerFile) => Future<error, File>)
  & ((query: getSuggestedStickerSetName) => Future<error, Text>)
  & ((query: checkStickerSetName) => Future<error, CheckStickerSetNameResult>)
  & ((query: createNewStickerSet) => Future<error, StickerSet>)
  & ((query: addStickerToSet) => Future<error, StickerSet>)
  & ((query: setStickerSetThumbnail) => Future<error, StickerSet>)
  & ((query: setStickerPositionInSet) => Future<error, Ok>)
  & ((query: removeStickerFromSet) => Future<error, Ok>)
  & ((query: getMapThumbnailFile) => Future<error, File>)
  & ((query: acceptTermsOfService) => Future<error, Ok>)
  & ((query: sendCustomRequest) => Future<error, CustomRequestResult>)
  & ((query: answerCustomQuery) => Future<error, Ok>)
  & ((query: setAlarm) => Future<error, Ok>)
  & ((query: getCountries) => Future<error, Countries>)
  & ((query: getCountryCode) => Future<error, Text>)
  & ((query: getPhoneNumberInfo) => Future<error, PhoneNumberInfo>)
  & ((query: getPhoneNumberInfoSync) => Future<error, PhoneNumberInfo>)
  & ((query: getApplicationDownloadLink) => Future<error, HttpUrl>)
  & ((query: getDeepLinkInfo) => Future<error, DeepLinkInfo>)
  & ((query: getApplicationConfig) => Future<error, JsonValue>)
  & ((query: saveApplicationLogEvent) => Future<error, Ok>)
  & ((query: addProxy) => Future<error, Proxy>)
  & ((query: editProxy) => Future<error, Proxy>)
  & ((query: enableProxy) => Future<error, Ok>)
  & ((query: disableProxy) => Future<error, Ok>)
  & ((query: removeProxy) => Future<error, Ok>)
  & ((query: getProxies) => Future<error, Proxies>)
  & ((query: getProxyLink) => Future<error, HttpUrl>)
  & ((query: pingProxy) => Future<error, Seconds>)
  & ((query: setLogStream) => Future<error, Ok>)
  & ((query: getLogStream) => Future<error, LogStream>)
  & ((query: setLogVerbosityLevel) => Future<error, Ok>)
  & ((query: getLogVerbosityLevel) => Future<error, LogVerbosityLevel>)
  & ((query: getLogTags) => Future<error, LogTags>)
  & ((query: setLogTagVerbosityLevel) => Future<error, Ok>)
  & ((query: getLogTagVerbosityLevel) => Future<error, LogVerbosityLevel>)
  & ((query: addLogMessage) => Future<error, Ok>)
  & ((query: testCallEmpty) => Future<error, Ok>)
  & ((query: testCallString) => Future<error, TestString>)
  & ((query: testCallBytes) => Future<error, TestBytes>)
  & ((query: testCallVectorInt) => Future<error, TestVectorInt>)
  & ((query: testCallVectorIntObject) => Future<error, TestVectorIntObject>)
  & ((query: testCallVectorString) => Future<error, TestVectorString>)
  & ((query: testCallVectorStringObject) => Future<error, TestVectorStringObject>)
  & ((query: testSquareInt) => Future<error, TestInt>)
  & ((query: testNetwork) => Future<error, Ok>)
  & ((query: testProxy) => Future<error, Ok>)
  & ((query: testGetDifference) => Future<error, Ok>)
  & ((query: testUseUpdate) => Future<error, Update>)
  & ((query: testReturnError) => Future<error, Error>)
